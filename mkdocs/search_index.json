{
    "docs": [
        {
            "location": "/", 
            "text": "JSTP / JavaScript Transfer Protocol\n\n\n\n\n\n\nInstallation\n\n\nJSTP works in Node.js and web browsers. To install it, simply run:\n\n\n$ npm install --save-dev metarhia-jstp\n\n\n\n\nThen\n\n\nconst jstp = require('metarhia-jstp');\n\n\n\n\nin your code.\n\n\nOr, alternatively, if you are developing a client-side application for browser\nenvironment and don't use a module bundler like Webpack, you can grab\n\njstp.min.js\n and\n\njstp.min.js.map\n.\nJSTP will be available globally as \napi.jstp\n.\n\n\nConcept\n\n\nJSTP is a family of data formats and corresponding libraries for their\nprocessing that are based on some simple assumptions:\n\n\n\n\nit is possible to trasfer data as plain JavaScript code easier and\n  more efficient than using JSON:\n\n\nin its simplest implementation it doesn't even require a specialized\n    parser since it is already built into transferer and receiver systems;\n\n\na human-readable format can be almost as minimalist as a binary one,\n    losing coding efficiency very slightly yet winning from the simplicity\n    of packet inspection;\n\n\nserialization format and data modeling must be maximally univocal and\n    must answer a question about why someone has done something this way;\n\n\n\n\nthere should be possibility to apply different formatting and use\n    comments;\n\n\n\n\n\n\nit is redundant to send a structure along with data each time, the\n  serialization format and the protocol must be optimized to exempt\n  metamodel and send it only when the receiver hasn't got it yet;\n\n\n\n\n\n\nthe protocol of interaction between two JavaScript applications must\n  have the following features:\n\n\n\n\ntwo-way asynchronous data transfer with support of plentiful parallel\n    non-blocking interactions and packet indentifiers allowing, for example,\n    to find the correspondence between a request and a response;\n\n\nsupport of RPC and multiple APIs must be so transparent that application\n    shouldn't event know whether a function call is inside the address space\n    of the application or it is a remote call sent to another system for\n    execution;\n\n\ndirect call and response via callback support;\n\n\nsupport of translation of named events with bound data and named channels\n    for event grouping;\n\n\nsupport of automatic synchronization of objects in applications memory\n    if they are registered for synchronization;\n\n\nonly one of sides can initiate a connection but both sides can send data\n    over open channel;\n\n\nthe transport layer must guarantee reliable data transfer with connection\n    establishment and guaranteed delivery (TCP is the basic transport and we\n    also support WebSocket but anything can be used, even RS232 or USB);\n\n\nall packet types (call, response, callback, event, data etc.) may be split\n    into several parts if their body is too large;\n\n\n\n\nthere should be a possibility to stop data transfer if the data transmitted\n    in parts is too large and the last part hasn't been received yet;\n\n\n\n\n\n\nit is required to minimize the transformation of data while tranferring them\n  between different systems, storing and processing, minimize putting them from\n  one structures to other, to save memory and connection channel;\n\n\n\n\n\n\namount of data structures needed for most systems is in fact finite and the\n  structures themselves must be standardized as a result of specialists\n  agreement, and there should be possibility of their versioning;\n\n\n\n\n\n\nnon-standard data structures can be sent between systems along with metadata\n  that will allow to interprete them and provide universal processing to the\n  possible extent if the remote sides trust each other and formalization of\n  data doesn't make sense.\n\n\n\n\n\n\nImplementations\n\n\n\n\n\n\n\n\nImplementation\n\n\nParser\n\n\nTCP Client\n\n\nTCP Server\n\n\nWebSocket Client\n\n\nWebSocket Server\n\n\nStatus\n\n\n\n\n\n\n\n\n\n\nJavaScript\nmetarhia/Impress\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\nreference implementation\n\n\n\n\n\n\nC++\nNechaiDO/JSTP-cpp\n\n\n\u2713\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\nstable\n\n\n\n\n\n\nQt C++\nNechaiDO/QJSTP\n\n\n\u2713\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\nstable\n\n\n\n\n\n\nSwift (iOS)\nJSTPMobile/iOS\n\n\n\u2713\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\nin development\n\n\n\n\n\n\nJava\nJSTPMobile/Java\n\n\n\u2713\n\n\n\u2713\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\nstable\n\n\n\n\n\n\nC#\nJSTPKPI/JSTP-CS\n\n\n\u2713\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\nstable\n\n\n\n\n\n\nPython\nmitchsvik/JSTP-Python\n\n\n\u00b1\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\nproof of concept\n\n\n\n\n\n\nHaskell\nDzyubSpirit/JSTPHaskellParser\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\u2717\n\n\n\u2717\n\n\nstable\n\n\n\n\n\n\nPHP\nRomm17/JSTPParserInPHP\n\n\n\u2713\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\nstable\n\n\n\n\n\n\nGoLang\nbelochub/jstp-go\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\n\u2717\n\n\nin development", 
            "title": "Home"
        }, 
        {
            "location": "/#jstp-javascript-transfer-protocol", 
            "text": "", 
            "title": "JSTP / JavaScript Transfer Protocol"
        }, 
        {
            "location": "/#installation", 
            "text": "JSTP works in Node.js and web browsers. To install it, simply run:  $ npm install --save-dev metarhia-jstp  Then  const jstp = require('metarhia-jstp');  in your code.  Or, alternatively, if you are developing a client-side application for browser\nenvironment and don't use a module bundler like Webpack, you can grab jstp.min.js  and jstp.min.js.map .\nJSTP will be available globally as  api.jstp .", 
            "title": "Installation"
        }, 
        {
            "location": "/#concept", 
            "text": "JSTP is a family of data formats and corresponding libraries for their\nprocessing that are based on some simple assumptions:   it is possible to trasfer data as plain JavaScript code easier and\n  more efficient than using JSON:  in its simplest implementation it doesn't even require a specialized\n    parser since it is already built into transferer and receiver systems;  a human-readable format can be almost as minimalist as a binary one,\n    losing coding efficiency very slightly yet winning from the simplicity\n    of packet inspection;  serialization format and data modeling must be maximally univocal and\n    must answer a question about why someone has done something this way;   there should be possibility to apply different formatting and use\n    comments;    it is redundant to send a structure along with data each time, the\n  serialization format and the protocol must be optimized to exempt\n  metamodel and send it only when the receiver hasn't got it yet;    the protocol of interaction between two JavaScript applications must\n  have the following features:   two-way asynchronous data transfer with support of plentiful parallel\n    non-blocking interactions and packet indentifiers allowing, for example,\n    to find the correspondence between a request and a response;  support of RPC and multiple APIs must be so transparent that application\n    shouldn't event know whether a function call is inside the address space\n    of the application or it is a remote call sent to another system for\n    execution;  direct call and response via callback support;  support of translation of named events with bound data and named channels\n    for event grouping;  support of automatic synchronization of objects in applications memory\n    if they are registered for synchronization;  only one of sides can initiate a connection but both sides can send data\n    over open channel;  the transport layer must guarantee reliable data transfer with connection\n    establishment and guaranteed delivery (TCP is the basic transport and we\n    also support WebSocket but anything can be used, even RS232 or USB);  all packet types (call, response, callback, event, data etc.) may be split\n    into several parts if their body is too large;   there should be a possibility to stop data transfer if the data transmitted\n    in parts is too large and the last part hasn't been received yet;    it is required to minimize the transformation of data while tranferring them\n  between different systems, storing and processing, minimize putting them from\n  one structures to other, to save memory and connection channel;    amount of data structures needed for most systems is in fact finite and the\n  structures themselves must be standardized as a result of specialists\n  agreement, and there should be possibility of their versioning;    non-standard data structures can be sent between systems along with metadata\n  that will allow to interprete them and provide universal processing to the\n  possible extent if the remote sides trust each other and formalization of\n  data doesn't make sense.", 
            "title": "Concept"
        }, 
        {
            "location": "/#implementations", 
            "text": "Implementation  Parser  TCP Client  TCP Server  WebSocket Client  WebSocket Server  Status      JavaScript metarhia/Impress  \u2713  \u2713  \u2713  \u2713  \u2713  reference implementation    C++ NechaiDO/JSTP-cpp  \u2713  \u2717  \u2717  \u2717  \u2717  stable    Qt C++ NechaiDO/QJSTP  \u2713  \u2717  \u2717  \u2717  \u2717  stable    Swift (iOS) JSTPMobile/iOS  \u2713  \u2717  \u2717  \u2717  \u2717  in development    Java JSTPMobile/Java  \u2713  \u2713  \u2717  \u2717  \u2717  stable    C# JSTPKPI/JSTP-CS  \u2713  \u2717  \u2717  \u2717  \u2717  stable    Python mitchsvik/JSTP-Python  \u00b1  \u2717  \u2717  \u2717  \u2717  proof of concept    Haskell DzyubSpirit/JSTPHaskellParser  \u2713  \u2713  \u2713  \u2717  \u2717  stable    PHP Romm17/JSTPParserInPHP  \u2713  \u2717  \u2717  \u2717  \u2717  stable    GoLang belochub/jstp-go  \u2717  \u2717  \u2717  \u2717  \u2717  in development", 
            "title": "Implementations"
        }, 
        {
            "location": "/data-formats/", 
            "text": "JSTP Data Formats Family\n\n\nData Formats Structure\n\n\n\n\n\n\nRecord Serialization\n\n  \n{ name: 'Marcus Aurelius', passport: 'AE127095' }\n\n\n\n\n\n\nObject Serialization\n\n  \n{ name: ['Marcus', 'Aurelius'].join(' '), passport: 'AE' + '127095' }\n\n\n\n\n\n\nRecord Metadata\n\n  \n{ name: 'string', passport: '[string]' }\n\n\n\n\n\n\nRecord Data\n\n  \n[ 'Marcus Aurelius', 'AE127095' ]\n\n\n\n\n\n\nJavaScript Transfer Protocol\n\n  \n{ event: [17, 'accounts'], insert: ['Marcus Aurelius', 'AE127095'] }\n\n\n\n\n\n\nRecord Serialization\n\n\nIt is in fact plain JavaScript that describes a data structure. Contrary\nto JSON it is not required to put keys into double quotes, it is possible\nto add comments, neat formatting and all you can do in JavaScript.\n\n\nFor example:\n\n\n{\n  name: 'Marcus Aurelius',\n  passport: 'AE127095',\n  birth: {\n    date: '1990-02-15',\n    place: 'Rome'\n  },\n  contacts: {\n    email: 'marcus@aurelius.it',\n    phone: '+380505551234',\n    address: {\n      country: 'Ukraine',\n      city: 'Kiev',\n      zip: '03056',\n      street: 'Pobedy',\n      building: '37',\n      floor: '1',\n      room: '158'\n    }\n  }\n}\n\n\n\n\nThe simplest way to parse the data in Node.js:\n\n\napi.jstp.parse = function(s) {\n  var sandbox = vm.createContext({});\n  var js = vm.createScript('(' + s + ')');\n  return js.runInNewContext(sandbox);\n};\n\n\n\n\nAnd here's the example of usage:\n\n\nfs.readFile('./person.record', function(err, s) {\n  var person = api.jstp.parse(s);\n  console.dir(person);\n});\n\n\n\n\nWarning:\n this excerpt, as well as next examples of code, is just a\ndemonstration of concept; of course, it is far more complicated in real world\nto do it properly, and that's what this library does.\n\n\nObject Serialization\n\n\nIf we complicate the parser a little bit, putting all the keys it exports into\nthe same sandbox, we could use expressions and functions:\n\n\napi.jstp.parse = function(s) {\n  var sandbox = vm.createContext({});\n  var js = vm.createScript('(' + s + ')');\n  var exported = js.runInNewContext(sandbox);\n  for (var key in exported) {\n    sandbox[key] = exported[key];\n  }\n  return exported;\n};\n\n\n\n\nExample of data:\n\n\n{\n  name: ['Marcus', 'Aurelius'].join(' '),\n  passport: 'AE' + '127095',\n  birth: {\n    date: new Date('1990-02-15'),\n    place: 'Rome'\n  },\n  age: function() {\n    var difference = new Date() - birth.date;\n    return Math.floor(difference / 31536000000);\n  }\n}\n\n\n\n\nAs you can see, it is possible to use links to structure fields, like\n\nbirth.date\n.\n\n\nAnd here's an example of usage:\n\n\nfs.readFile('./person.record', function(err, s) {\n  var person = api.jstp.parse(s);\n  console.log('Age = ' + person.age());\n});\n\n\n\n\nRecord Metadata\n\n\nThis is metadata, i.e., data about the structure data types, that are described\nin the same format of JavaScript objects. Field definitiions are described\nusing special syntax. For example, \nnumber(4)\n is a number that has less or\nfour digits and cannot be undefined, and \n[number(2, 4)]\n is a nullable number\nthat has two to four digits (\nTODO\n: controversial syntax, better to use \n?\n\nfor nullables and \n[...]\n for arrays, IMO).\n\n\nExamples:\n\n\n// File: Person.metadata\n{\n  name: 'string',\n  passport: '[string(8)]',\n  birth: '[Birth]',\n  address: '[Address]'\n}\n\n// File: Birth.metadata\n{\n  date: 'Date',\n  place: '[string]'\n}\n\n// File: Address.metadata\n{\n  country: 'string',\n  city: 'string',\n  zip: 'number(5)',\n  street: 'string',\n  building: 'string',\n  room: '[number]'\n}\n\n\n\n\nNames of built-in types begin with a lowercase letter (\nstring\n, \nnumber\n,\n\nboolean\n), and links to other records begin with a capital: \nBirth\n,\n\nAddress\n. All record definitions are stored in a special structure storage and\ncan be cached on servers and user devices.\n\n\nRecord Data\n\n\nIt is pure data without names of the fields and with objects replaced with\narrays.  If a field doesn't have a value (i.e., \nundefined\n) then the value in\nthe array is just omitted. For example, \n[1,,,4]\n means four fields, with the\nfirst and last having the values of \n1\n and \n4\n respectively and the second and\nthird equal to \nundefined\n.\n\n\nExample of \nPerson\n instance:\n\n\n['Marcus Aurelius','AE127095',['1990-02-15','Rome'],['Ukraine','Kiev','03056','Pobedy','37','158']]\n\n\n\n\nIf we have data data and corresponding metadata, we can restore the full\ndocument. For example:\n\n\nvar data = ['Marcus Aurelius','AE127095'];\nvar metadata = { name: 'string', passport: '[string(8)]' };\nvar person = api.jstp.decode(data, metadata);\nconsole.dir(person);\n{ name: 'Marcus Aurelius', passport: 'AE127095' }", 
            "title": "Formats"
        }, 
        {
            "location": "/data-formats/#jstp-data-formats-family", 
            "text": "", 
            "title": "JSTP Data Formats Family"
        }, 
        {
            "location": "/data-formats/#data-formats-structure", 
            "text": "Record Serialization \n   { name: 'Marcus Aurelius', passport: 'AE127095' }    Object Serialization \n   { name: ['Marcus', 'Aurelius'].join(' '), passport: 'AE' + '127095' }    Record Metadata \n   { name: 'string', passport: '[string]' }    Record Data \n   [ 'Marcus Aurelius', 'AE127095' ]    JavaScript Transfer Protocol \n   { event: [17, 'accounts'], insert: ['Marcus Aurelius', 'AE127095'] }", 
            "title": "Data Formats Structure"
        }, 
        {
            "location": "/data-formats/#record-serialization", 
            "text": "It is in fact plain JavaScript that describes a data structure. Contrary\nto JSON it is not required to put keys into double quotes, it is possible\nto add comments, neat formatting and all you can do in JavaScript.  For example:  {\n  name: 'Marcus Aurelius',\n  passport: 'AE127095',\n  birth: {\n    date: '1990-02-15',\n    place: 'Rome'\n  },\n  contacts: {\n    email: 'marcus@aurelius.it',\n    phone: '+380505551234',\n    address: {\n      country: 'Ukraine',\n      city: 'Kiev',\n      zip: '03056',\n      street: 'Pobedy',\n      building: '37',\n      floor: '1',\n      room: '158'\n    }\n  }\n}  The simplest way to parse the data in Node.js:  api.jstp.parse = function(s) {\n  var sandbox = vm.createContext({});\n  var js = vm.createScript('(' + s + ')');\n  return js.runInNewContext(sandbox);\n};  And here's the example of usage:  fs.readFile('./person.record', function(err, s) {\n  var person = api.jstp.parse(s);\n  console.dir(person);\n});  Warning:  this excerpt, as well as next examples of code, is just a\ndemonstration of concept; of course, it is far more complicated in real world\nto do it properly, and that's what this library does.", 
            "title": "Record Serialization"
        }, 
        {
            "location": "/data-formats/#object-serialization", 
            "text": "If we complicate the parser a little bit, putting all the keys it exports into\nthe same sandbox, we could use expressions and functions:  api.jstp.parse = function(s) {\n  var sandbox = vm.createContext({});\n  var js = vm.createScript('(' + s + ')');\n  var exported = js.runInNewContext(sandbox);\n  for (var key in exported) {\n    sandbox[key] = exported[key];\n  }\n  return exported;\n};  Example of data:  {\n  name: ['Marcus', 'Aurelius'].join(' '),\n  passport: 'AE' + '127095',\n  birth: {\n    date: new Date('1990-02-15'),\n    place: 'Rome'\n  },\n  age: function() {\n    var difference = new Date() - birth.date;\n    return Math.floor(difference / 31536000000);\n  }\n}  As you can see, it is possible to use links to structure fields, like birth.date .  And here's an example of usage:  fs.readFile('./person.record', function(err, s) {\n  var person = api.jstp.parse(s);\n  console.log('Age = ' + person.age());\n});", 
            "title": "Object Serialization"
        }, 
        {
            "location": "/data-formats/#record-metadata", 
            "text": "This is metadata, i.e., data about the structure data types, that are described\nin the same format of JavaScript objects. Field definitiions are described\nusing special syntax. For example,  number(4)  is a number that has less or\nfour digits and cannot be undefined, and  [number(2, 4)]  is a nullable number\nthat has two to four digits ( TODO : controversial syntax, better to use  ? \nfor nullables and  [...]  for arrays, IMO).  Examples:  // File: Person.metadata\n{\n  name: 'string',\n  passport: '[string(8)]',\n  birth: '[Birth]',\n  address: '[Address]'\n}\n\n// File: Birth.metadata\n{\n  date: 'Date',\n  place: '[string]'\n}\n\n// File: Address.metadata\n{\n  country: 'string',\n  city: 'string',\n  zip: 'number(5)',\n  street: 'string',\n  building: 'string',\n  room: '[number]'\n}  Names of built-in types begin with a lowercase letter ( string ,  number , boolean ), and links to other records begin with a capital:  Birth , Address . All record definitions are stored in a special structure storage and\ncan be cached on servers and user devices.", 
            "title": "Record Metadata"
        }, 
        {
            "location": "/data-formats/#record-data", 
            "text": "It is pure data without names of the fields and with objects replaced with\narrays.  If a field doesn't have a value (i.e.,  undefined ) then the value in\nthe array is just omitted. For example,  [1,,,4]  means four fields, with the\nfirst and last having the values of  1  and  4  respectively and the second and\nthird equal to  undefined .  Example of  Person  instance:  ['Marcus Aurelius','AE127095',['1990-02-15','Rome'],['Ukraine','Kiev','03056','Pobedy','37','158']]  If we have data data and corresponding metadata, we can restore the full\ndocument. For example:  var data = ['Marcus Aurelius','AE127095'];\nvar metadata = { name: 'string', passport: '[string(8)]' };\nvar person = api.jstp.decode(data, metadata);\nconsole.dir(person);\n{ name: 'Marcus Aurelius', passport: 'AE127095' }", 
            "title": "Record Data"
        }, 
        {
            "location": "/protocol/", 
            "text": "JavaScript Transfer Protocol\n\n\nJSTP is a data transfer protocol that uses JavaScript objects syntax as the\nencoding format and supports metadata. The protocol has 8 types of packets:\n\n\n\n\ncall\n \u2014 remote API call;\n\n\ncallback\n \u2014 remote API response;\n\n\nevent\n \u2014 event with attached data;\n\n\nstate\n \u2014 data synchronization;\n\n\nstream\n \u2014 data streaming;\n\n\nhandshake\n \u2014 protocol handshake;\n\n\nhealth\n \u2014 system data about resource state and usage;\n\n\ninspect\n \u2014 API introspection request;\n\n\nthis list is a subject to change.\n\n\n\n\n// Packet ID 17, remote call, interface auth, method newAccount\n{call:[17,'auth'],newAccount:['Payload data']}\n\n// Response to packet 17, operation is successful, record ID is 15703\n{callback:[17],ok:[15703]}\n\n// Event in packet 18, interface auth, event named insert\n{event:[18,'auth'],insert:['Marcus Aurelius','AE127095']}\n\n\n\n\nPacket structure:\n\n\n\n\n\n\na packet is an object with several keys;\n\n\n\n\n\n\nthe first one is a header, the name of this key is the packet type,\n  its elements are:\n\n\n\n\n\n\n[0]\n \u2014 unique number that identifies the packet inside the connection;\n    packet with ID \n0\n is sent by a client (the side that initiated the\n    connection) and the client increments it by \n1\n with each request;\n    a server has a separate counter that is being decremented by \n1\n with\n    each request or response to the client; if any of the sides sends a\n    request (like \ncall\n or \ninspect\n), another one responds with a\n    \ncallback\n packet with the same ID.\n\n\n\n\n\n\n[1]\n \u2014 resource identifier:\n\n\n\n\nin \ncall\n, \nevent\n and \ninspect\n \u2014 name of an interface;\n\n\nin \nstate\n \u2014 identifier of the mutating object;\n\n\n\n\n\n\n\n\nthe second key is identifier:\n\n\n\n\n\n\nin \ncall\n \u2014 method name;\n\n\n\n\n\n\nin \ncallback\n - response status (\nok\n or \nerror\n);\n\n\n\n\n\n\nin \nevent\n \u2014 event name;\n\n\n\n\n\n\nin \nstate\n \u2014 method identifier (\ninc\n, \ndec\n, \ndelete\n, \nlet\n, \npush\n,\n    \npop\n, \nshift\n, \nunshift\n);\n\n\n\n\n\n\nin \ninspect\n \u2014 no value;\n\n\n\n\n\n\nin \nstream\n \u2014 no value.\n\n\n\n\n\n\nRemote Call Packet \ncall\n\n\nExample:\n\n\n{call:[3,'interfaceName'],methodName:['Payload data']}\n\n\n\n\nRemote Call Response Packet \ncallback\n\n\nExamples:\n\n\n{callback:[14],ok:[15703]}\n\n{callback:[397],error:[4,'Data validation failed']}\n\n{callback:[-23],ok:[]}\n\n\n\n\nRemote Event Packet \nevent\n\n\nExamples:\n\n\n{event:[-12,'chat'],message:['Marcus','Hello there!']}\n\n{event:[51,'game'],vote:[5]}\n\n{event:[-79,'db'],insert:['Marcus','Aurelius','Rome','AE127095']}\n\n\n\n\nData Synchronization Packet \nstate\n\n\nExamples:\n\n\n{state:[-12,'object.path.prop1'],inc:5}\n{state:[-13,'object.path.prop2'],dec:1}\n{state:[-14,'object.path.prop3'],let:700}\n{state:[-15,'object.path.prop4'],let:'Hello'}\n{state:[-16,'object.path.prop5'],let:{f:55}}\n{state:[-17,'object.path.prop5'],let:[1,2,7]}\n{state:[-18,'object.path.prop6'],delete:0}\n{state:[-19,'object.path.set1'],let:['A','D']}\n{state:[-20,'object.path.set1'],push:'C'}\n{state:[-20,'object.path.set2'],let:[5,6,9]}\n{state:[-20,'object.path.set2'],push:12}\n{state:[-20,'object.path.set2'],pop:2}\n{state:[-20,'object.path.set2'],shift:3}\n{state:[-20,'object.path.set2'],delete:5}\n{state:[-20,'object.path.set2'],unshift:1}\n\n\n\n\nData Stream Packet \nstream\n\n\nExamples:\n\n\n{stream:[9],data:'Payload start...'}\n{stream:[9],data:'...continue...'}\n{stream:[9],data:'...end'}\n\n\n\n\nHandshake Packet \nhandshake\n\n\nHandshake packets always have ID equal to \n0\n. The response contains either\nthe key \nok\n with a value that is the session identifier or \nerror\n that is\nan array with error code and optional error message.\n\n\nSuccessful handshake:\n\n\nC: {handshake:[0,'example'],marcus:'7b458e1a9dda....67cb7a3e'}\nS: {handshake:[0],ok:'9b71d224bd62...bcdec043'}\n\n\n\n\nIn this excerpt \n'example'\n is the name of an application, \nmarcus\n\nis the user name and \n9b71d224bd62...bcdec043\n is the session id.\n\n\nSuccessful anonymous handshake:\n\n\nC: {handshake:[0,'example']}\nS: {handshake:[0],ok:'f3785d96d46a...def46f73'}\n\n\n\n\nIt may be necessary for registration or public service. Server responds\nwith a session ID.\n\n\nSuccessfull handshake of \nImpress\n worker\nconnecting to a private cloud controller:\n\n\nC: {handshake:[0,'impress'],S1N5:'d3ea3d73319b...5c2e5c3a'}\nS: {handshake:[0],ok:'PrivateCloud'}\n\n\n\n\nPrivateCloud\n is the name of a cloud and \nd3ea3d73319b...5c2e5c3a\n is the\ncloud access key.\n\n\nApplication not found:\n\n\nC: {handshake:[0,'example'],marcus:'fbc2890caada...0c466347'}\nS: {handshake:[0],error:[10,'Application not found']}\n\n\n\n\nIn this example \nmarcus\n is username and \nfbc2890caada...0c466347\n is salted\n\nsha512\n hash of a password.\n\n\nAuthentication error:\n\n\nC: {handshake:[0,'example'],marcus:'e2dff7251967...14b8c5da'}\nS: {handshake:[0],error:[11,'Authentication failed']}\n\n\n\n\nIntrospection Request Packet \ninspect\n\n\nThis packet is being sent for remote API introspection request and can be\ninitiated by either side.\n\n\nJust like the \ncall\n packet, the other side responds with a \ncallback\n packet.\n\n\nExample of a successful introspection retrieval:\n\n\nC: {inspect:[42,'interfaceName']}\nS: {callback:[42],ok:['method1','method2']}\n\n\n\n\nError getting the introspection:\n\n\nC: {inspect:[15,'unknownInterface']}\nS: {callback:[15],error:[12,'Interface not found']}\n\n\n\n\nData Transmission and Packet Aggregation\n\n\nTCP\n\n\nTCP protocol transfers a stream of data, so fragments sent sequentially are\nglued and cut in any positions by the protocol. In order to split the stream\ninto separate messages we must either specify the length of each packet or\ninclude message terminators. JSTP uses terminator that allows to accumulate\nand split the buffer quite efficiently.\n\n\nEach JSTP packet must end with a null character. When a TCP packet arrives,\neach null character is replaced with a comma and the result is put into\nthe buffer (while the empty buffer always has the \n[\n character). As soon\nas the received packet ends with a terminator, after character replacement\nand putting the data into the buffer, the \n]\n character is placed into the\nbuffer and its whole content is parsed.\n\n\nWebSocket\n\n\nSince the WebSocket API used in browsers doesn't expose the vanilla frame-based\nor streaming API (though supported by WebSocket protocol) but only\nmessage-based one which splits messages into frames and aggregates them back\ntogether automatically, and all the major WebSocket implementations are capable\nof that too, there's no need to build the same mechanism again on top of\nWebSocket and induce unnecessary overhead because of situation that will never\nhappen.", 
            "title": "Protocol"
        }, 
        {
            "location": "/protocol/#javascript-transfer-protocol", 
            "text": "JSTP is a data transfer protocol that uses JavaScript objects syntax as the\nencoding format and supports metadata. The protocol has 8 types of packets:   call  \u2014 remote API call;  callback  \u2014 remote API response;  event  \u2014 event with attached data;  state  \u2014 data synchronization;  stream  \u2014 data streaming;  handshake  \u2014 protocol handshake;  health  \u2014 system data about resource state and usage;  inspect  \u2014 API introspection request;  this list is a subject to change.   // Packet ID 17, remote call, interface auth, method newAccount\n{call:[17,'auth'],newAccount:['Payload data']}\n\n// Response to packet 17, operation is successful, record ID is 15703\n{callback:[17],ok:[15703]}\n\n// Event in packet 18, interface auth, event named insert\n{event:[18,'auth'],insert:['Marcus Aurelius','AE127095']}  Packet structure:    a packet is an object with several keys;    the first one is a header, the name of this key is the packet type,\n  its elements are:    [0]  \u2014 unique number that identifies the packet inside the connection;\n    packet with ID  0  is sent by a client (the side that initiated the\n    connection) and the client increments it by  1  with each request;\n    a server has a separate counter that is being decremented by  1  with\n    each request or response to the client; if any of the sides sends a\n    request (like  call  or  inspect ), another one responds with a\n     callback  packet with the same ID.    [1]  \u2014 resource identifier:   in  call ,  event  and  inspect  \u2014 name of an interface;  in  state  \u2014 identifier of the mutating object;     the second key is identifier:    in  call  \u2014 method name;    in  callback  - response status ( ok  or  error );    in  event  \u2014 event name;    in  state  \u2014 method identifier ( inc ,  dec ,  delete ,  let ,  push ,\n     pop ,  shift ,  unshift );    in  inspect  \u2014 no value;    in  stream  \u2014 no value.", 
            "title": "JavaScript Transfer Protocol"
        }, 
        {
            "location": "/protocol/#remote-call-packet-call", 
            "text": "Example:  {call:[3,'interfaceName'],methodName:['Payload data']}", 
            "title": "Remote Call Packet call"
        }, 
        {
            "location": "/protocol/#remote-call-response-packet-callback", 
            "text": "Examples:  {callback:[14],ok:[15703]}\n\n{callback:[397],error:[4,'Data validation failed']}\n\n{callback:[-23],ok:[]}", 
            "title": "Remote Call Response Packet callback"
        }, 
        {
            "location": "/protocol/#remote-event-packet-event", 
            "text": "Examples:  {event:[-12,'chat'],message:['Marcus','Hello there!']}\n\n{event:[51,'game'],vote:[5]}\n\n{event:[-79,'db'],insert:['Marcus','Aurelius','Rome','AE127095']}", 
            "title": "Remote Event Packet event"
        }, 
        {
            "location": "/protocol/#data-synchronization-packet-state", 
            "text": "Examples:  {state:[-12,'object.path.prop1'],inc:5}\n{state:[-13,'object.path.prop2'],dec:1}\n{state:[-14,'object.path.prop3'],let:700}\n{state:[-15,'object.path.prop4'],let:'Hello'}\n{state:[-16,'object.path.prop5'],let:{f:55}}\n{state:[-17,'object.path.prop5'],let:[1,2,7]}\n{state:[-18,'object.path.prop6'],delete:0}\n{state:[-19,'object.path.set1'],let:['A','D']}\n{state:[-20,'object.path.set1'],push:'C'}\n{state:[-20,'object.path.set2'],let:[5,6,9]}\n{state:[-20,'object.path.set2'],push:12}\n{state:[-20,'object.path.set2'],pop:2}\n{state:[-20,'object.path.set2'],shift:3}\n{state:[-20,'object.path.set2'],delete:5}\n{state:[-20,'object.path.set2'],unshift:1}", 
            "title": "Data Synchronization Packet state"
        }, 
        {
            "location": "/protocol/#data-stream-packet-stream", 
            "text": "Examples:  {stream:[9],data:'Payload start...'}\n{stream:[9],data:'...continue...'}\n{stream:[9],data:'...end'}", 
            "title": "Data Stream Packet stream"
        }, 
        {
            "location": "/protocol/#handshake-packet-handshake", 
            "text": "Handshake packets always have ID equal to  0 . The response contains either\nthe key  ok  with a value that is the session identifier or  error  that is\nan array with error code and optional error message.  Successful handshake:  C: {handshake:[0,'example'],marcus:'7b458e1a9dda....67cb7a3e'}\nS: {handshake:[0],ok:'9b71d224bd62...bcdec043'}  In this excerpt  'example'  is the name of an application,  marcus \nis the user name and  9b71d224bd62...bcdec043  is the session id.  Successful anonymous handshake:  C: {handshake:[0,'example']}\nS: {handshake:[0],ok:'f3785d96d46a...def46f73'}  It may be necessary for registration or public service. Server responds\nwith a session ID.  Successfull handshake of  Impress  worker\nconnecting to a private cloud controller:  C: {handshake:[0,'impress'],S1N5:'d3ea3d73319b...5c2e5c3a'}\nS: {handshake:[0],ok:'PrivateCloud'}  PrivateCloud  is the name of a cloud and  d3ea3d73319b...5c2e5c3a  is the\ncloud access key.  Application not found:  C: {handshake:[0,'example'],marcus:'fbc2890caada...0c466347'}\nS: {handshake:[0],error:[10,'Application not found']}  In this example  marcus  is username and  fbc2890caada...0c466347  is salted sha512  hash of a password.  Authentication error:  C: {handshake:[0,'example'],marcus:'e2dff7251967...14b8c5da'}\nS: {handshake:[0],error:[11,'Authentication failed']}", 
            "title": "Handshake Packet handshake"
        }, 
        {
            "location": "/protocol/#introspection-request-packet-inspect", 
            "text": "This packet is being sent for remote API introspection request and can be\ninitiated by either side.  Just like the  call  packet, the other side responds with a  callback  packet.  Example of a successful introspection retrieval:  C: {inspect:[42,'interfaceName']}\nS: {callback:[42],ok:['method1','method2']}  Error getting the introspection:  C: {inspect:[15,'unknownInterface']}\nS: {callback:[15],error:[12,'Interface not found']}", 
            "title": "Introspection Request Packet inspect"
        }, 
        {
            "location": "/protocol/#data-transmission-and-packet-aggregation", 
            "text": "", 
            "title": "Data Transmission and Packet Aggregation"
        }, 
        {
            "location": "/protocol/#tcp", 
            "text": "TCP protocol transfers a stream of data, so fragments sent sequentially are\nglued and cut in any positions by the protocol. In order to split the stream\ninto separate messages we must either specify the length of each packet or\ninclude message terminators. JSTP uses terminator that allows to accumulate\nand split the buffer quite efficiently.  Each JSTP packet must end with a null character. When a TCP packet arrives,\neach null character is replaced with a comma and the result is put into\nthe buffer (while the empty buffer always has the  [  character). As soon\nas the received packet ends with a terminator, after character replacement\nand putting the data into the buffer, the  ]  character is placed into the\nbuffer and its whole content is parsed.", 
            "title": "TCP"
        }, 
        {
            "location": "/protocol/#websocket", 
            "text": "Since the WebSocket API used in browsers doesn't expose the vanilla frame-based\nor streaming API (though supported by WebSocket protocol) but only\nmessage-based one which splits messages into frames and aggregates them back\ntogether automatically, and all the major WebSocket implementations are capable\nof that too, there's no need to build the same mechanism again on top of\nWebSocket and induce unnecessary overhead because of situation that will never\nhappen.", 
            "title": "WebSocket"
        }, 
        {
            "location": "/api/record-serialization/", 
            "text": "Record Serialization\n\n\nThis module provides parser and serializer for the \nJSTP Record Serialization\nformat\n which is very similar to\n\nJSON5\n.\n\n\nIn order to speed up the parser, a native addon will be used for the supported\nplatforms.  The platforms that will use a pure JavaScript implementation istead\ninclude web browsers, Windows, and Node.js older than version 4.0.  There's\nalso an experimental version of native JSRS serializer included, however it\nisn't currently faster than the JavaScript one. If you want to try it for some\nreason, change \nUSE_NATIVE_SERIALIZER\n in \nlib/record-serialization.js\n to\ntrue.\n\n\njstp.stringify(value)\n\n\n\n\nvalue\n {any} any JavaScript value.\n\n\nReturn: {String} JSRS representation of this value.\n\n\n\n\nThis function serializes a JavaScript value using the JSTP Record Serialization\nformat and returns a string representing it.\n\n\nExample:\n\n\nconst jstp = require('metarhia-jstp');\n\nconst event = {\n  type: 'notification',\n  text: 'Hello!'\n};\n\nconst serializedEvent = jstp.stringify(event);\n// '{type:\\'notification\\',text:\\'Hello!\\'}'\n\n\n\n\njstp.parse(string)\n\n\n\n\nstring {String} a string to parse.\n\n\nReturn: {any} parsed value.\n\n\n\n\nThis function deserializes a string in the JSTP Record Serialization format into\na JavaScript value and returns it.\n\n\nExample:\n\n\nconst jstp = require('metarhia-jstp');\n\nconst data = '{type:\\'notification\\',text:\\'Hello!\\'}';\nconst object = jstp.parse(data);\n// {\n//   type: 'notification',\n//   text: 'Hello!'\n// }", 
            "title": "Record Serialization"
        }, 
        {
            "location": "/api/record-serialization/#record-serialization", 
            "text": "This module provides parser and serializer for the  JSTP Record Serialization\nformat  which is very similar to JSON5 .  In order to speed up the parser, a native addon will be used for the supported\nplatforms.  The platforms that will use a pure JavaScript implementation istead\ninclude web browsers, Windows, and Node.js older than version 4.0.  There's\nalso an experimental version of native JSRS serializer included, however it\nisn't currently faster than the JavaScript one. If you want to try it for some\nreason, change  USE_NATIVE_SERIALIZER  in  lib/record-serialization.js  to\ntrue.", 
            "title": "Record Serialization"
        }, 
        {
            "location": "/api/record-serialization/#jstpstringifyvalue", 
            "text": "value  {any} any JavaScript value.  Return: {String} JSRS representation of this value.   This function serializes a JavaScript value using the JSTP Record Serialization\nformat and returns a string representing it.  Example:  const jstp = require('metarhia-jstp');\n\nconst event = {\n  type: 'notification',\n  text: 'Hello!'\n};\n\nconst serializedEvent = jstp.stringify(event);\n// '{type:\\'notification\\',text:\\'Hello!\\'}'", 
            "title": "jstp.stringify(value)"
        }, 
        {
            "location": "/api/record-serialization/#jstpparsestring", 
            "text": "string {String} a string to parse.  Return: {any} parsed value.   This function deserializes a string in the JSTP Record Serialization format into\na JavaScript value and returns it.  Example:  const jstp = require('metarhia-jstp');\n\nconst data = '{type:\\'notification\\',text:\\'Hello!\\'}';\nconst object = jstp.parse(data);\n// {\n//   type: 'notification',\n//   text: 'Hello!'\n// }", 
            "title": "jstp.parse(string)"
        }, 
        {
            "location": "/api/object-serialization/", 
            "text": "Object Serialization\n\n\nThis module provides parser and serializer for the \nJSTP Object Serialization\nformat\n.\n\n\nThe format is especially useful for different kinds of configuration files and\nwill also be used to store and transmit metadata (essentially, classes) when\n\nJSTP Record Metadata\n and \nJSTP Record\nData\n are implemented.\n\n\njstp.dump(value)\n\n\n\n\nvalue\n {any} any JavaScript value.\n\n\nReturn: {String} JSOS representation of this value.\n\n\n\n\nThis function serializes a JavaScript value using the JSTP Object Serialization\nformat and returns a string representing it.\n\n\nExamples:\n\n\nconst jstp = require('metarhia-jstp');\n\nconst event = {\n  type: 'notification',\n  text: 'Hello!'\n};\n\nconst serializedEvent = jstp.stringify(event);\n// '{type:\\'notification\\',text:\\'Hello!\\'}'\n\n\n\n\nconst jstp = require('metarhia-jstp');\n\nconst person = {\n  name: 'Marcus Aurelius',\n  passport: 'AE127095',\n  birth: {\n    date: new Date('1990-02-15'),\n    place: 'Rome'\n  },\n  age: function() {\n    var difference = new Date() - birth.date;\n    return Math.floor(difference / 31536000000);\n  }\n};\n\nconst data = jstp.dump(person);\n// '{name:\\'Marcus Aurelius\\',passport:\\'AE127095\\',\\\n// birth:{date:new Date(\\'1990-02-15T00:00:00.000Z\\'),\\\n// place:\\'Rome\\'},age:function () {\\nvar difference = \\\n// new Date() - birth.date;\\nreturn Math.floor(difference \\\n// / 31536000000);\\n}}'\n\n\n\n\njstp.interprete(string)\n\n\n\n\nstring {String} a string to parse.\n\n\nReturn: {any} parsed value.\n\n\n\n\nThis function deserializes a string in the JSTP Object Serialization format into\na JavaScript value and returns it.\n\n\nExamples:\n\n\nconst jstp = require('metarhia-jstp');\n\nconst data = '{type:\\'notification\\',text:\\'Hello!\\'}';\nconst object = jstp.parse(data);\n// {\n//   type: 'notification',\n//   text: 'Hello!'\n// }\n\n\n\n\nconst jstp = require('metarhia-jstp');\n\nconst data = `{\n  name: ['Marcus', 'Aurelius'].join(' '),\n  passport: 'AE' + '127095',\n  birth: {\n    date: new Date('1990-02-15'),\n    place: 'Rome'\n  },\n  age: function() {\n    var difference = new Date() - birth.date;\n    return Math.floor(difference / 31536000000);\n  }\n}`;\n\nconst person = jstp.interprete(data);\n// { name: 'Marcus Aurelius',\n//   passport: 'AE127095',\n//   birth: { date: 1990-02-15T00:00:00.000Z, place: 'Rome' },\n//   age: [Function: age] }", 
            "title": "Object Serialization"
        }, 
        {
            "location": "/api/object-serialization/#object-serialization", 
            "text": "This module provides parser and serializer for the  JSTP Object Serialization\nformat .  The format is especially useful for different kinds of configuration files and\nwill also be used to store and transmit metadata (essentially, classes) when JSTP Record Metadata  and  JSTP Record\nData  are implemented.", 
            "title": "Object Serialization"
        }, 
        {
            "location": "/api/object-serialization/#jstpdumpvalue", 
            "text": "value  {any} any JavaScript value.  Return: {String} JSOS representation of this value.   This function serializes a JavaScript value using the JSTP Object Serialization\nformat and returns a string representing it.  Examples:  const jstp = require('metarhia-jstp');\n\nconst event = {\n  type: 'notification',\n  text: 'Hello!'\n};\n\nconst serializedEvent = jstp.stringify(event);\n// '{type:\\'notification\\',text:\\'Hello!\\'}'  const jstp = require('metarhia-jstp');\n\nconst person = {\n  name: 'Marcus Aurelius',\n  passport: 'AE127095',\n  birth: {\n    date: new Date('1990-02-15'),\n    place: 'Rome'\n  },\n  age: function() {\n    var difference = new Date() - birth.date;\n    return Math.floor(difference / 31536000000);\n  }\n};\n\nconst data = jstp.dump(person);\n// '{name:\\'Marcus Aurelius\\',passport:\\'AE127095\\',\\\n// birth:{date:new Date(\\'1990-02-15T00:00:00.000Z\\'),\\\n// place:\\'Rome\\'},age:function () {\\nvar difference = \\\n// new Date() - birth.date;\\nreturn Math.floor(difference \\\n// / 31536000000);\\n}}'", 
            "title": "jstp.dump(value)"
        }, 
        {
            "location": "/api/object-serialization/#jstpinterpretestring", 
            "text": "string {String} a string to parse.  Return: {any} parsed value.   This function deserializes a string in the JSTP Object Serialization format into\na JavaScript value and returns it.  Examples:  const jstp = require('metarhia-jstp');\n\nconst data = '{type:\\'notification\\',text:\\'Hello!\\'}';\nconst object = jstp.parse(data);\n// {\n//   type: 'notification',\n//   text: 'Hello!'\n// }  const jstp = require('metarhia-jstp');\n\nconst data = `{\n  name: ['Marcus', 'Aurelius'].join(' '),\n  passport: 'AE' + '127095',\n  birth: {\n    date: new Date('1990-02-15'),\n    place: 'Rome'\n  },\n  age: function() {\n    var difference = new Date() - birth.date;\n    return Math.floor(difference / 31536000000);\n  }\n}`;\n\nconst person = jstp.interprete(data);\n// { name: 'Marcus Aurelius',\n//   passport: 'AE127095',\n//   birth: { date: 1990-02-15T00:00:00.000Z, place: 'Rome' },\n//   age: [Function: age] }", 
            "title": "jstp.interprete(string)"
        }, 
        {
            "location": "/api/errors/", 
            "text": "Errors\n\n\nMany operations in JSTP may end up with an error instead of a result.  Following\nthe common Node.js convention, errors are always being passed as the first\nargument of callbacks of these operations and if the operation was successful,\nthis argument will be null.  This behavior is both consistent with the core\nNode.js API and allows the JSTP API to be wrapped into promises easily and even\nto be used with async/await, if you use these advanced features, while keeping\ncompatibility with plain callback-based asynchronous code for those who prefer\nperformance over convenience or those who are forced to use older versions of\nNode.js.\n\n\nHanshakes, RPC invocations and introspection requests are special cases of such\noperations.  If they end up with an error, this error will be sent over\nnetwork.  As you can see in\n\nhandshake\n and\n\ncallback\n packets\ndescription, such errors are serialized into arrays that contain an error code\nand an optional error description. A high-level abstraction for these arrays is\nthe \nRemoteError\n class.\n\n\nCallbacks of the operations stated above will receive instances of \nRemoteError\n\nas the first argument if an error occured. However, when returning an error\nfrom a remote method, you can pass any of the following to a callback:\n\n\n\n\nRemoteError\n instance;\n\n\nError\n instance;\n\n\nnumeric error code;\n\n\nerror message as a string;\n\n\nany other object that will return an error message as a result\n  of its \ntoString\n method.\n\n\n\n\nIf an error code is unknown (i.e., in any case except the first and third ones)\nit will be equal to zero. However, it is recommended to leverage error codes\neven for custom errors and return them instead of \nError\n instances as it is\nmore efficient to send numbers than strings.\n\n\nIf a method throws an exception, the calling side will receive\n\nERR_INTERNAL_API_ERROR\n.\n\n\nPredefined Error Codes\n\n\njstp.ERR_APP_NOT_FOUND\n\n\nValue: \n10\n.\n\n\nDefault message: \nApplication not found\n.\n\n\njstp.ERR_AUTH_FAILED\n\n\nValue: \n11\n.\n\n\nDefault message: \nAuthentication failed\n.\n\n\njstp.ERR_INTERFACE_NOT_FOUND\n\n\nValue: \n12\n.\n\n\nDefault message: \nInterface not found\n.\n\n\njstp.ERR_INTERFACE_INCOMPATIBLE\n\n\nValue: \n13\n.\n\n\nDefault message: \nIncompatible interface\n.\n\n\njstp.ERR_METHOD_NOT_FOUND\n\n\nValue: \n14\n.\n\n\nDefault message: \nMethod not found\n.\n\n\njstp.ERR_NOT_A_SERVER\n\n\nValue: \n15\n.\n\n\nDefault message: \nNot a server\n.\n\n\njstp.ERR_INTERNAL_API_ERROR\n\n\nValue: \n16\n.\n\n\nDefault message: \nInternal API error\n.\n\n\nClass: RemoteError\n\n\nThis class is a subclass of \nError\n that represents an error that has been\nreceived from a remote method call over network.\n\n\nnew RemoteError(code, [message])\n\n\n\n\ncode {Number} error code.\n\n\nmessage {String} error message.\n\n\n\n\nIf \nmessage\n is not provided and \ncode\n is one of predefined codes, default\nmessage is used. If \nmessage\n is not provided and \ncode\n is unknown, error code\nwill become error message too.\n\n\nerror.code\n\n\nError code.\n\n\nerror.message\n\n\nError message.\n\n\nerror.toJstpArray()\n\n\nReturns an array for JSTP packets. This array will always contain the error\ncode and, if the message is not equal to code and the code is not one of\npredefined error codes, the error message.\n\n\nClass Method: RemoteError.fromJstpArray(array)\n\n\nThis factory method creates a \nRemoteError\n instance from an array found in a\nJSTP packet.\n\n\nClass Method: RemoteError.getJstpArrayFor(error)\n\n\nThis function returns an array suitable to be sent in a JSTP packet from a\n\nRemoteError\n instance, an \nError\n instance, an error code or an error message.\nIf there is no error code (i.e., an \nError\n or a \nString\n is passed), the error\ncode is assumed to be \n0\n.", 
            "title": "Errors"
        }, 
        {
            "location": "/api/errors/#errors", 
            "text": "Many operations in JSTP may end up with an error instead of a result.  Following\nthe common Node.js convention, errors are always being passed as the first\nargument of callbacks of these operations and if the operation was successful,\nthis argument will be null.  This behavior is both consistent with the core\nNode.js API and allows the JSTP API to be wrapped into promises easily and even\nto be used with async/await, if you use these advanced features, while keeping\ncompatibility with plain callback-based asynchronous code for those who prefer\nperformance over convenience or those who are forced to use older versions of\nNode.js.  Hanshakes, RPC invocations and introspection requests are special cases of such\noperations.  If they end up with an error, this error will be sent over\nnetwork.  As you can see in handshake  and callback  packets\ndescription, such errors are serialized into arrays that contain an error code\nand an optional error description. A high-level abstraction for these arrays is\nthe  RemoteError  class.  Callbacks of the operations stated above will receive instances of  RemoteError \nas the first argument if an error occured. However, when returning an error\nfrom a remote method, you can pass any of the following to a callback:   RemoteError  instance;  Error  instance;  numeric error code;  error message as a string;  any other object that will return an error message as a result\n  of its  toString  method.   If an error code is unknown (i.e., in any case except the first and third ones)\nit will be equal to zero. However, it is recommended to leverage error codes\neven for custom errors and return them instead of  Error  instances as it is\nmore efficient to send numbers than strings.  If a method throws an exception, the calling side will receive ERR_INTERNAL_API_ERROR .", 
            "title": "Errors"
        }, 
        {
            "location": "/api/errors/#predefined-error-codes", 
            "text": "", 
            "title": "Predefined Error Codes"
        }, 
        {
            "location": "/api/errors/#jstperr_app_not_found", 
            "text": "Value:  10 .  Default message:  Application not found .", 
            "title": "jstp.ERR_APP_NOT_FOUND"
        }, 
        {
            "location": "/api/errors/#jstperr_auth_failed", 
            "text": "Value:  11 .  Default message:  Authentication failed .", 
            "title": "jstp.ERR_AUTH_FAILED"
        }, 
        {
            "location": "/api/errors/#jstperr_interface_not_found", 
            "text": "Value:  12 .  Default message:  Interface not found .", 
            "title": "jstp.ERR_INTERFACE_NOT_FOUND"
        }, 
        {
            "location": "/api/errors/#jstperr_interface_incompatible", 
            "text": "Value:  13 .  Default message:  Incompatible interface .", 
            "title": "jstp.ERR_INTERFACE_INCOMPATIBLE"
        }, 
        {
            "location": "/api/errors/#jstperr_method_not_found", 
            "text": "Value:  14 .  Default message:  Method not found .", 
            "title": "jstp.ERR_METHOD_NOT_FOUND"
        }, 
        {
            "location": "/api/errors/#jstperr_not_a_server", 
            "text": "Value:  15 .  Default message:  Not a server .", 
            "title": "jstp.ERR_NOT_A_SERVER"
        }, 
        {
            "location": "/api/errors/#jstperr_internal_api_error", 
            "text": "Value:  16 .  Default message:  Internal API error .", 
            "title": "jstp.ERR_INTERNAL_API_ERROR"
        }, 
        {
            "location": "/api/errors/#class-remoteerror", 
            "text": "This class is a subclass of  Error  that represents an error that has been\nreceived from a remote method call over network.", 
            "title": "Class: RemoteError"
        }, 
        {
            "location": "/api/errors/#new-remoteerrorcode-91message93", 
            "text": "code {Number} error code.  message {String} error message.   If  message  is not provided and  code  is one of predefined codes, default\nmessage is used. If  message  is not provided and  code  is unknown, error code\nwill become error message too.", 
            "title": "new RemoteError(code, [message])"
        }, 
        {
            "location": "/api/errors/#errorcode", 
            "text": "Error code.", 
            "title": "error.code"
        }, 
        {
            "location": "/api/errors/#errormessage", 
            "text": "Error message.", 
            "title": "error.message"
        }, 
        {
            "location": "/api/errors/#errortojstparray", 
            "text": "Returns an array for JSTP packets. This array will always contain the error\ncode and, if the message is not equal to code and the code is not one of\npredefined error codes, the error message.", 
            "title": "error.toJstpArray()"
        }, 
        {
            "location": "/api/errors/#class-method-remoteerrorfromjstparrayarray", 
            "text": "This factory method creates a  RemoteError  instance from an array found in a\nJSTP packet.", 
            "title": "Class Method: RemoteError.fromJstpArray(array)"
        }, 
        {
            "location": "/api/errors/#class-method-remoteerrorgetjstparrayforerror", 
            "text": "This function returns an array suitable to be sent in a JSTP packet from a RemoteError  instance, an  Error  instance, an error code or an error message.\nIf there is no error code (i.e., an  Error  or a  String  is passed), the error\ncode is assumed to be  0 .", 
            "title": "Class Method: RemoteError.getJstpArrayFor(error)"
        }, 
        {
            "location": "/api/auth-provider/", 
            "text": "", 
            "title": "Authentication Provider"
        }, 
        {
            "location": "/api/apps-provider/", 
            "text": "", 
            "title": "Application Provider"
        }, 
        {
            "location": "/api/remote-proxy/", 
            "text": "", 
            "title": "Remote Proxy"
        }, 
        {
            "location": "/api/connection/", 
            "text": "", 
            "title": "Connection"
        }, 
        {
            "location": "/api/server/", 
            "text": "", 
            "title": "Server"
        }, 
        {
            "location": "/api/client/", 
            "text": "", 
            "title": "Client"
        }, 
        {
            "location": "/api/transport.tcp/", 
            "text": "", 
            "title": "TCP Transport"
        }, 
        {
            "location": "/api/transport.ws/", 
            "text": "", 
            "title": "WebSocket Transport (Node.js)"
        }, 
        {
            "location": "/api/transport.ws.browser/", 
            "text": "", 
            "title": "WebSocket Transport (Browser)"
        }
    ]
}