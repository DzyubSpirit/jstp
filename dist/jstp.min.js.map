{"version":3,"sources":["webpack:///jstp.min.js","webpack:///webpack/bootstrap f1354b8ed810e0271012","webpack:///./jstp.js","webpack:///./lib/common.js","webpack:///./~/util/util.js","webpack:///./~/events/events.js","webpack:///./lib/errors.js","webpack:///./~/buffer/index.js","webpack:///./~/timers-browserify/main.js","webpack:///./lib/connection.js","webpack:///./lib/record-serialization-nonnative.js","webpack:///./lib/remote-proxy.js","webpack:///./lib/serializer-factory.js","webpack:///./~/process/browser.js","webpack:///./lib/apps-provider.js","webpack:///./lib/client.js","webpack:///./lib/internal-constants.js","webpack:///./lib/object-serialization.js","webpack:///./lib/transport.ws.browser.js","webpack:///./~/base64-js/index.js","webpack:///./~/ieee754/index.js","webpack:///./~/indexof/index.js","webpack:///./~/isarray/index.js","webpack:///./~/metasync/metasync.js","webpack:///./~/util/~/inherits/inherits_browser.js","webpack:///./~/util/support/isBufferBrowser.js","webpack:///./~/vm-browserify/index.js"],"names":["api","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","i","Object","prototype","hasOwnProperty","_m","args","slice","fn","a","b","apply","this","concat","common","jstp","extend","RemoteProxy","Connection","Server","tcp","ws","simpleAuthProvider","Buffer","isNull","value","undefined","target","TypeError","sources","Array","arguments","filter","source","forEach","key","assign","forwardEvent","from","to","eventName","newEventName","on","eventArgs","emit","forwardMultipleEvents","eventNames","event","createZeroFilledBuffer","size","buffer","fill","alloc","global","process","inspect","obj","opts","ctx","seen","stylize","stylizeNoColor","length","depth","colors","isBoolean","showHidden","_extend","isUndefined","customInspect","stylizeWithColor","formatValue","str","styleType","style","styles","arrayToHash","array","hash","val","idx","recurseTimes","isFunction","constructor","ret","isString","primitive","formatPrimitive","keys","visibleKeys","getOwnPropertyNames","isError","indexOf","formatError","name","isRegExp","RegExp","toString","isDate","Date","base","braces","isArray","n","toUTCString","push","output","formatArray","map","formatProperty","pop","reduceToSingleString","simple","JSON","stringify","replace","isNumber","Error","l","String","match","desc","getOwnPropertyDescriptor","get","set","split","line","join","substr","numLinesEst","reduce","prev","cur","ar","arg","isNullOrUndefined","isSymbol","re","isObject","objectToString","d","e","isPrimitive","o","pad","timestamp","time","getHours","getMinutes","getSeconds","getDate","months","getMonth","prop","formatRegExp","format","f","objects","len","x","Number","_","deprecate","msg","deprecated","warned","throwDeprecation","traceDeprecation","console","trace","error","noDeprecation","debugEnviron","debugs","debuglog","env","NODE_DEBUG","toUpperCase","test","pid","bold","italic","underline","inverse","white","grey","black","blue","cyan","green","magenta","red","yellow","special","number","boolean","null","string","date","regexp","isBuffer","log","inherits","origin","add","EventEmitter","_events","_maxListeners","defaultMaxListeners","setMaxListeners","isNaN","type","er","handler","listeners","err","context","addListener","listener","newListener","once","g","removeListener","fired","list","position","splice","removeAllListeners","listenerCount","evlistener","emitter","RemoteError","code","message","captureStackTrace","stack","defaultMessages","util","errors","ERR_APP_NOT_FOUND","ERR_AUTH_FAILED","ERR_INTERFACE_NOT_FOUND","ERR_INTERFACE_INCOMPATIBLE","ERR_METHOD_NOT_FOUND","ERR_NOT_A_SERVER","ERR_INTERNAL_API_ERROR","toJstpArray","isMessagePresent","isMessageStandard","fromJstpArray","getJstpArrayFor","typedArraySupport","arr","Uint8Array","__proto__","foo","subarray","byteLength","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","encodingOrOffset","allocUnsafe","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","encoding","checked","isEncoding","actual","write","fromArrayLike","byteOffset","copy","isnan","data","SlowBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","start","end","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","bidirectionalIndexOf","dir","arrayIndexOf","lastIndexOf","read","buf","indexSize","readUInt16BE","arrLength","valLength","foundIndex","found","j","hexWrite","offset","remaining","strLen","parsed","parseInt","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","base64","fromByteArray","Math","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","out","toHex","bytes","checkOffset","ext","checkInt","max","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","stringtrim","INVALID_BASE64_RE","trim","units","Infinity","leadSurrogate","charCodeAt","byteArray","hi","lo","toByteArray","src","dst","INSPECT_MAX_BYTES","poolSize","_augment","Symbol","species","defineProperty","configurable","allocUnsafeSlow","_isBuffer","compare","y","pos","swap16","swap32","swap64","equals","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","maxBytes","writeUIntBE","writeUInt8","floor","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","setImmediate","clearImmediate","Timeout","clearFn","_id","_clearFn","nextTick","Function","immediateIds","nextImmediateId","setTimeout","window","clearTimeout","setInterval","clearInterval","timeout","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","transport","server","client","events","nextConnectionId","_nextPacketId","_packetIdDelta","remoteAddress","getRemoteAddress","_callbacks","handshakeDone","authenticated","sessionId","application","remoteProxies","_onSocketData","bind","_onSocketClose","_onSocketError","timers","jsrs","callMethod","interfaceName","methodName","callback","packet","createPacket","packetId","_send","result","emitRemoteEvent","notifyStateChange","path","verb","handshake","appName","login","password","self","inspectInterface","methods","proxy","kind","milliseconds","send","_end","packets","parse","_processPackets","index","_rejectPacket","PACKET_HANDLER_NAMES","fatal","_processHandshakePacket","_processHandshakeRequest","_processHandshakeResponse","_handshakeError","applicationName","getApplication","username","_emitPacketEvent","packetType","handshakeRequest","startAuthenticatedSession","_onAuthenticatedSessionCreated","startAnonymousSession","_onSessionCreated","ok","normalizedError","_processCallPacket","_remoteCallbackWrapper","_processCallbackPacket","sourcePacketUnknown","_processEventPacket","remoteEventName","remoteEventArgs","remoteProxy","_processInspectPacket","getMethods","_processStatePacket","state","connection","JsrsParser","lookaheadIndex","serializerFactory","createSerializer","parser","parseValue","skipClutter","throwUnexpected","lookahead","advance","character","SyntaxError","retreat","token","throwExpected","throwError","isWhitespace","isNewline","isLetter","isInitialDigit","isDecimalDigit","isDigit","isBinaryDigit","isOctalDigit","isHexadecimalDigit","isQuoteCharacter","isInititalIdentifierCharacter","isIdentifierCharacter","skipWhitespace","skipComments","skipLineCommentBody","skipMultilineCommentBody","done","look","parseNumber","parseIdentifier","parseString","parseArray","parseObject","negateResult","parseDecimal","parseMachineInteger","encountered","dot","sign","exponent","checkNumberPartEncountered","parseFloat","encounterContext","altCharacter","checkers","2","8","16","checkDigit","identifier","matching","true","false","quoteStyle","escapeMode","controlCharacters","r","t","v","controlCharacter","parseOctalEncodedStringCharacter","parseOneByteHexEncodedCharacter","parseUnicodeCharacter","digits","count","parseHexEncodedStringCharacter","nibblesCount","parseTwoByteHexEncodedCharacter","parseEs6UnicodeLiteral","hexDigits","digit","fromCodePoint","object","parseObjectKey","_connection","_interfaceName","wrapRemoteMethod","remoteMethodWrapper","dontRetranslate","instance","factory","additionalTypes","serialize","serializer","types","bool","content","toISOString","firstKey","objectKeys","objectKeysCount","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","run","Item","noop","title","browser","argv","version","versions","off","binding","cwd","chdir","umask","Application","ServerApplicationsProvider","_applications","ClientApplicationProvider","_application","apps","appInterface","method","registerApplication","Client","rawClient","applicationProvider","handshakeCallback","interfaces","sid","hasErrors","collector","metasync","DataCollector","_errors","collect","connect","createTransport","disconnect","connectAndHandshake","connectAndInspect","constants","WEBSOCKET_PROTOCOL_NAME","vm","PARSE_TIMEOUT","interprete","sandbox","createContext","script","createScript","exported","runInNewContext","dump","function","W3CWebSocketClient","url","socket","socketEventEmitter","socketDidOpen","W3CWebSocketTransport","_onMessage","createClient","appProvider","wsClient","jstpClient","WebSocket","onopen","_onOpen","onclose","_onClose","onerror","_onError","onmessage","_ensureConnected","placeHoldersCount","b64","tmp","placeHolders","Arr","L","revLookup","tripletToBase64","num","lookup","encodeChunk","uint8","extraBytes","parts","maxChunkLength","len2","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","s","NaN","rt","abs","LN2","composition","fns","parallel","sequential","counter","finished","finish","next","expected","items","sort","accepted","find","series","each","create","ctor","superCtor","super_","enumerable","writable","TempCtor","Context","Object_keys","xs","defineProp","globals","Script","runInContext","iframe","document","createElement","display","body","appendChild","win","contentWindow","wEval","eval","wExecScript","execScript","winKeys","removeChild","runInThisContext"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAAA,IAAqB,gBAARA,KAAmBA,OAAUA,IAAU,KAC3C,SAAUC,GCGnB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,IDKW,SAASD,GAEnB,IAAI,GAAIY,KAAKZ,GACZ,GAAGa,OAAOC,UAAUC,eAAeP,KAAKR,EAASY,GAChD,aAAcZ,GAAQY,IACtB,IAAK,WAAY,KACjB,KAAK,SAEJZ,EAAQY,GAAM,SAASI,GACtB,GAAIC,GAAOD,EAAGE,MAAM,GAAIC,EAAKnB,EAAQgB,EAAG,GACxC,OAAO,UAAUI,EAAEC,EAAEX,GACpBS,EAAGG,MAAMC,MAAOH,EAAEC,EAAEX,GAAGc,OAAOP,MAE9BjB,EAAQY,GACV,MACD,SAECZ,EAAQY,GAAKZ,EAAQA,EAAQY,IAKhC,MAAOZ,KAGF,SAASK,EAAQD,EAASH,GEpEhC,YAEA,IAAAwB,GAAAxB,EAAA,GAEAyB,IACArB,GAAAD,QAAAsB,EAEAD,EAAAE,OAAAD,EACAzB,EAAA,GACAA,EAAA,IACAA,EAAA,GACAA,EAAA,KAGAyB,EAAAE,YAAA3B,EAAA,GACAyB,EAAAG,WAAA5B,EAAA,GACAyB,EAAAI,OAAA7B,EAAA,IAEAyB,EAAAK,IAAA9B,EAAA,IACAyB,EAAAM,GAAA/B,EAAA,IAEAyB,EAAAO,mBAAAhC,EAAA,KF2EM,SAASI,EAAQD,EAASH,IGhGhC,SAAAiC,GAAA,YAQA,SAAAC,GAAAC,GACA,cAAAA,GAAAC,SAAAD,EAPA,GAAAX,KACApB,GAAAD,QAAAqB,EAiBAA,EAAAE,OAAA,SAAAW,GACA,GAAAH,EAAAG,GACA,SAAAC,WAAA,6CAGA,sBACAD,EAAA,GAAAzB,QAAAyB,GAGA,IAAAE,GAAAC,MAAA3B,UAAAI,MACAV,KAAAkC,UAAA,GACAC,OAAA,SAAAC,GACA,OAAAT,EAAAS,IAYA,OATAJ,GAAAK,QAAA,SAAAD,GACA,OAAAE,KAAAF,GACAA,EAAA7B,eAAA+B,KAGAR,EAAAQ,GAAAF,EAAAE,MAIAR,GAGAzB,OAAAkC,SACAtB,EAAAE,OAAAd,OAAAkC,QASAtB,EAAAuB,aAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACAH,EAAAI,GAAAF,EAAA,SAAAG,GACAJ,EAAAK,KAAAH,GAAAD,EAAAG,EAAAJ,MASAzB,EAAA+B,sBAAA,SAAAP,EAAAC,EAAAO,GACAA,EAAAZ,QAAA,SAAAa,GACAjC,EAAAuB,aAAAC,EAAAC,EAAAQ,MAOAjC,EAAAkC,uBAAA,SAAAC,GACA,GAAAC,GAAA,GAAA3B,GAAA0B,EAGA,OAFAC,GAAAC,KAAA,GAEAD,GAGA3B,EAAA6B,QACAtC,EAAAkC,uBAAAzB,EAAA6B,SHqG8BvD,KAAKJ,EAASH,EAAoB,GAAGiC,SAI7D,SAAS7B,EAAQD,EAASH,II9LhC,SAAA+D,EAAAC,GA4HA,QAAAC,GAAAC,EAAAC,GAEA,GAAAC,IACAC,QACAC,QAAAC,EAkBA,OAfA9B,WAAA+B,QAAA,IAAAJ,EAAAK,MAAAhC,UAAA,IACAA,UAAA+B,QAAA,IAAAJ,EAAAM,OAAAjC,UAAA,IACAkC,EAAAR,GAEAC,EAAAQ,WAAAT,EACGA,GAEHhE,EAAA0E,QAAAT,EAAAD,GAGAW,EAAAV,EAAAQ,cAAAR,EAAAQ,YAAA,GACAE,EAAAV,EAAAK,SAAAL,EAAAK,MAAA,GACAK,EAAAV,EAAAM,UAAAN,EAAAM,QAAA,GACAI,EAAAV,EAAAW,iBAAAX,EAAAW,eAAA,GACAX,EAAAM,SAAAN,EAAAE,QAAAU,GACAC,EAAAb,EAAAF,EAAAE,EAAAK,OAoCA,QAAAO,GAAAE,EAAAC,GACA,GAAAC,GAAAnB,EAAAoB,OAAAF,EAEA,OAAAC,GACA,KAAAnB,EAAAS,OAAAU,GAAA,OAAAF,EACA,KAAAjB,EAAAS,OAAAU,GAAA,OAEAF,EAKA,QAAAX,GAAAW,EAAAC,GACA,MAAAD,GAIA,QAAAI,GAAAC,GACA,GAAAC,KAMA,OAJAD,GAAA3C,QAAA,SAAA6C,EAAAC,GACAF,EAAAC,IAAA,IAGAD,EAIA,QAAAP,GAAAb,EAAAjC,EAAAwD,GAGA,GAAAvB,EAAAW,eACA5C,GACAyD,EAAAzD,EAAA8B,UAEA9B,EAAA8B,UAAA9D,EAAA8D,WAEA9B,EAAA0D,aAAA1D,EAAA0D,YAAAhF,YAAAsB,GAAA,CACA,GAAA2D,GAAA3D,EAAA8B,QAAA0B,EAAAvB,EAIA,OAHA2B,GAAAD,KACAA,EAAAb,EAAAb,EAAA0B,EAAAH,IAEAG,EAIA,GAAAE,GAAAC,EAAA7B,EAAAjC,EACA,IAAA6D,EACA,MAAAA,EAIA,IAAAE,GAAAtF,OAAAsF,KAAA/D,GACAgE,EAAAb,EAAAY,EAQA,IANA9B,EAAAQ,aACAsB,EAAAtF,OAAAwF,oBAAAjE,IAKAkE,EAAAlE,KACA+D,EAAAI,QAAA,eAAAJ,EAAAI,QAAA,mBACA,MAAAC,GAAApE,EAIA,QAAA+D,EAAA1B,OAAA,CACA,GAAAoB,EAAAzD,GAAA,CACA,GAAAqE,GAAArE,EAAAqE,KAAA,KAAArE,EAAAqE,KAAA,EACA,OAAApC,GAAAE,QAAA,YAAAkC,EAAA,eAEA,GAAAC,EAAAtE,GACA,MAAAiC,GAAAE,QAAAoC,OAAA7F,UAAA8F,SAAApG,KAAA4B,GAAA,SAEA,IAAAyE,EAAAzE,GACA,MAAAiC,GAAAE,QAAAuC,KAAAhG,UAAA8F,SAAApG,KAAA4B,GAAA,OAEA,IAAAkE,EAAAlE,GACA,MAAAoE,GAAApE,GAIA,GAAA2E,GAAA,GAAAvB,GAAA,EAAAwB,GAAA,IAA4C,IAS5C,IANAC,EAAA7E,KACAoD,GAAA,EACAwB,GAAA,UAIAnB,EAAAzD,GAAA,CACA,GAAA8E,GAAA9E,EAAAqE,KAAA,KAAArE,EAAAqE,KAAA,EACAM,GAAA,aAAAG,EAAA,IAkBA,GAdAR,EAAAtE,KACA2E,EAAA,IAAAJ,OAAA7F,UAAA8F,SAAApG,KAAA4B,IAIAyE,EAAAzE,KACA2E,EAAA,IAAAD,KAAAhG,UAAAqG,YAAA3G,KAAA4B,IAIAkE,EAAAlE,KACA2E,EAAA,IAAAP,EAAApE,IAGA,IAAA+D,EAAA1B,UAAAe,GAAA,GAAApD,EAAAqC,QACA,MAAAuC,GAAA,GAAAD,EAAAC,EAAA,EAGA,IAAApB,EAAA,EACA,MAAAc,GAAAtE,GACAiC,EAAAE,QAAAoC,OAAA7F,UAAA8F,SAAApG,KAAA4B,GAAA,UAEAiC,EAAAE,QAAA,qBAIAF,GAAAC,KAAA8C,KAAAhF,EAEA,IAAAiF,EAWA,OATAA,GADA7B,EACA8B,EAAAjD,EAAAjC,EAAAwD,EAAAQ,EAAAD,GAEAA,EAAAoB,IAAA,SAAAzE,GACA,MAAA0E,GAAAnD,EAAAjC,EAAAwD,EAAAQ,EAAAtD,EAAA0C,KAIAnB,EAAAC,KAAAmD,MAEAC,EAAAL,EAAAN,EAAAC,GAIA,QAAAd,GAAA7B,EAAAjC,GACA,GAAA2C,EAAA3C,GACA,MAAAiC,GAAAE,QAAA,wBACA,IAAAyB,EAAA5D,GAAA,CACA,GAAAuF,GAAA,IAAAC,KAAAC,UAAAzF,GAAA0F,QAAA,aACAA,QAAA,YACAA,QAAA,eACA,OAAAzD,GAAAE,QAAAoD,EAAA,UAEA,MAAAI,GAAA3F,GACAiC,EAAAE,QAAA,GAAAnC,EAAA,UACAwC,EAAAxC,GACAiC,EAAAE,QAAA,GAAAnC,EAAA,WAEAD,EAAAC,GACAiC,EAAAE,QAAA,eADA,OAKA,QAAAiC,GAAApE,GACA,UAAA4F,MAAAlH,UAAA8F,SAAApG,KAAA4B,GAAA,IAIA,QAAAkF,GAAAjD,EAAAjC,EAAAwD,EAAAQ,EAAAD,GAEA,OADAkB,MACAzG,EAAA,EAAAqH,EAAA7F,EAAAqC,OAAmC7D,EAAAqH,IAAOrH,EAC1CG,EAAAqB,EAAA8F,OAAAtH,IACAyG,EAAAD,KAAAI,EAAAnD,EAAAjC,EAAAwD,EAAAQ,EACA8B,OAAAtH,IAAA,IAEAyG,EAAAD,KAAA,GASA,OANAjB,GAAAtD,QAAA,SAAAC,GACAA,EAAAqF,MAAA,UACAd,EAAAD,KAAAI,EAAAnD,EAAAjC,EAAAwD,EAAAQ,EACAtD,GAAA,MAGAuE,EAIA,QAAAG,GAAAnD,EAAAjC,EAAAwD,EAAAQ,EAAAtD,EAAA0C,GACA,GAAAiB,GAAAtB,EAAAiD,CAsCA,IArCAA,EAAAvH,OAAAwH,yBAAAjG,EAAAU,KAAyDV,QAAAU,IACzDsF,EAAAE,IAEAnD,EADAiD,EAAAG,IACAlE,EAAAE,QAAA,6BAEAF,EAAAE,QAAA,sBAGA6D,EAAAG,MACApD,EAAAd,EAAAE,QAAA,uBAGAxD,EAAAqF,EAAAtD,KACA2D,EAAA,IAAA3D,EAAA,KAEAqC,IACAd,EAAAC,KAAAiC,QAAA6B,EAAAhG,OAAA,GAEA+C,EADAhD,EAAAyD,GACAV,EAAAb,EAAA+D,EAAAhG,MAAA,MAEA8C,EAAAb,EAAA+D,EAAAhG,MAAAwD,EAAA,GAEAT,EAAAoB,QAAA,WAEApB,EADAK,EACAL,EAAAqD,MAAA,MAAAjB,IAAA,SAAAkB,GACA,WAAAA,IACWC,KAAA,MAAAC,OAAA,GAEX,KAAAxD,EAAAqD,MAAA,MAAAjB,IAAA,SAAAkB,GACA,YAAAA,IACWC,KAAA,QAIXvD,EAAAd,EAAAE,QAAA,yBAGAQ,EAAA0B,GAAA,CACA,GAAAjB,GAAA1C,EAAAqF,MAAA,SACA,MAAAhD,EAEAsB,GAAAmB,KAAAC,UAAA,GAAA/E,GACA2D,EAAA0B,MAAA,iCACA1B,IAAAkC,OAAA,EAAAlC,EAAAhC,OAAA,GACAgC,EAAApC,EAAAE,QAAAkC,EAAA,UAEAA,IAAAqB,QAAA,YACAA,QAAA,YACAA,QAAA,gBACArB,EAAApC,EAAAE,QAAAkC,EAAA,WAIA,MAAAA,GAAA,KAAAtB,EAIA,QAAAuC,GAAAL,EAAAN,EAAAC,GACA,GAAA4B,GAAA,EACAnE,EAAA4C,EAAAwB,OAAA,SAAAC,EAAAC,GAGA,MAFAH,KACAG,EAAAxC,QAAA,UAAAqC,IACAE,EAAAC,EAAAjB,QAAA,sBAAArD,OAAA,GACG,EAEH,OAAAA,GAAA,GACAuC,EAAA,IACA,KAAAD,EAAA,GAAAA,EAAA,OACA,IACAM,EAAAqB,KAAA,SACA,IACA1B,EAAA,GAGAA,EAAA,GAAAD,EAAA,IAAAM,EAAAqB,KAAA,UAAA1B,EAAA,GAMA,QAAAC,GAAA+B,GACA,MAAAvG,OAAAwE,QAAA+B,GAIA,QAAApE,GAAAqE,GACA,uBAAAA,GAIA,QAAA9G,GAAA8G,GACA,cAAAA,EAIA,QAAAC,GAAAD,GACA,aAAAA,EAIA,QAAAlB,GAAAkB,GACA,sBAAAA,GAIA,QAAAjD,GAAAiD,GACA,sBAAAA,GAIA,QAAAE,GAAAF,GACA,sBAAAA,GAIA,QAAAlE,GAAAkE,GACA,gBAAAA,EAIA,QAAAvC,GAAA0C,GACA,MAAAC,GAAAD,IAAA,oBAAAE,EAAAF,GAIA,QAAAC,GAAAJ,GACA,sBAAAA,IAAA,OAAAA,EAIA,QAAApC,GAAA0C,GACA,MAAAF,GAAAE,IAAA,kBAAAD,EAAAC,GAIA,QAAAjD,GAAAkD,GACA,MAAAH,GAAAG,KACA,mBAAAF,EAAAE,gBAAAxB,QAIA,QAAAnC,GAAAoD,GACA,wBAAAA,GAIA,QAAAQ,GAAAR,GACA,cAAAA,GACA,iBAAAA,IACA,gBAAAA,IACA,gBAAAA,IACA,gBAAAA,IACA,mBAAAA,GAMA,QAAAK,GAAAI,GACA,MAAA7I,QAAAC,UAAA8F,SAAApG,KAAAkJ,GAIA,QAAAC,GAAAzC,GACA,MAAAA,GAAA,OAAAA,EAAAN,SAAA,IAAAM,EAAAN,SAAA,IAQA,QAAAgD,KACA,GAAAL,GAAA,GAAAzC,MACA+C,GAAAF,EAAAJ,EAAAO,YACAH,EAAAJ,EAAAQ,cACAJ,EAAAJ,EAAAS,eAAAtB,KAAA,IACA,QAAAa,EAAAU,UAAAC,EAAAX,EAAAY,YAAAN,GAAAnB,KAAA,KAqCA,QAAA3H,GAAAoD,EAAAiG,GACA,MAAAvJ,QAAAC,UAAAC,eAAAP,KAAA2D,EAAAiG,GAnjBA,GAAAC,GAAA,UACAjK,GAAAkK,OAAA,SAAAC,GACA,IAAAvE,EAAAuE,GAAA,CAEA,OADAC,MACA5J,EAAA,EAAmBA,EAAA8B,UAAA+B,OAAsB7D,IACzC4J,EAAApD,KAAAlD,EAAAxB,UAAA9B,IAEA,OAAA4J,GAAA9B,KAAA,KAsBA,OAnBA9H,GAAA,EACAK,EAAAyB,UACA+H,EAAAxJ,EAAAwD,OACAU,EAAA+C,OAAAqC,GAAAzC,QAAAuC,EAAA,SAAAK,GACA,UAAAA,EAAA,SACA,IAAA9J,GAAA6J,EAAA,MAAAC,EACA,QAAAA,GACA,eAAAxC,QAAAjH,EAAAL,KACA,gBAAA+J,QAAA1J,EAAAL,KACA,UACA,IACA,MAAAgH,MAAAC,UAAA5G,EAAAL,MACS,MAAAgK,GACT,mBAEA,QACA,MAAAF,MAGAA,EAAAzJ,EAAAL,GAAuBA,EAAA6J,EAASC,EAAAzJ,IAAAL,GAEhCuE,GADAhD,EAAAuI,KAAArB,EAAAqB,GACA,IAAAA,EAEA,IAAAxG,EAAAwG,EAGA,OAAAvF,IAOA/E,EAAAyK,UAAA,SAAA1J,EAAA2J,GAaA,QAAAC,KACA,IAAAC,EAAA,CACA,GAAA/G,EAAAgH,iBACA,SAAAjD,OAAA8C,EACO7G,GAAAiH,iBACPC,QAAAC,MAAAN,GAEAK,QAAAE,MAAAP,GAEAE,GAAA,EAEA,MAAA7J,GAAAG,MAAAC,KAAAmB,WAtBA,GAAAqC,EAAAf,EAAAC,SACA,kBACA,MAAA7D,GAAAyK,UAAA1J,EAAA2J,GAAAxJ,MAAAC,KAAAmB,WAIA,IAAAuB,EAAAqH,iBAAA,EACA,MAAAnK,EAGA,IAAA6J,IAAA,CAeA,OAAAD,GAIA,IACAQ,GADAC,IAEApL,GAAAqL,SAAA,SAAAlD,GAIA,GAHAxD,EAAAwG,KACAA,EAAAtH,EAAAyH,IAAAC,YAAA,IACApD,IAAAqD,eACAJ,EAAAjD,GACA,MAAA5B,QAAA,MAAA4B,EAAA,WAAAsD,KAAAN,GAAA,CACA,GAAAO,GAAA7H,EAAA6H,GACAN,GAAAjD,GAAA,WACA,GAAAuC,GAAA1K,EAAAkK,OAAAhJ,MAAAlB,EAAAsC,UACAyI,SAAAE,MAAA,YAAA9C,EAAAuD,EAAAhB,QAGAU,GAAAjD,GAAA,YAGA,OAAAiD,GAAAjD,IAoCAnI,EAAA8D,UAIAA,EAAAS,QACAoH,MAAA,MACAC,QAAA,MACAC,WAAA,MACAC,SAAA,MACAC,OAAA,OACAC,MAAA,OACAC,OAAA,OACAC,MAAA,OACAC,MAAA,OACAC,OAAA,OACAC,SAAA,OACAC,KAAA,OACAC,QAAA,QAIAzI,EAAAoB,QACAsH,QAAA,OACAC,OAAA,SACAC,QAAA,SACAzK,UAAA,OACA0K,KAAA,OACAC,OAAA,QACAC,KAAA,UAEAC,OAAA,OAkRA9M,EAAA6G,UAKA7G,EAAAwE,YAKAxE,EAAA+B,SAKA/B,EAAA8I,oBAKA9I,EAAA2H,WAKA3H,EAAA4F,WAKA5F,EAAA+I,WAKA/I,EAAA2E,cAKA3E,EAAAsG,WAKAtG,EAAAiJ,WAKAjJ,EAAAyG,SAMAzG,EAAAkG,UAKAlG,EAAAyF,aAUAzF,EAAAqJ,cAEArJ,EAAA+M,SAAAlN,EAAA,GAYA,IAAAiK,IAAA,sDACA,kBAaA9J,GAAAgN,IAAA,WACAjC,QAAAiC,IAAA,UAAAxD,IAAAxJ,EAAAkK,OAAAhJ,MAAAlB,EAAAsC,aAiBAtC,EAAAiN,SAAApN,EAAA,IAEAG,EAAA0E,QAAA,SAAAwI,EAAAC,GAEA,IAAAA,IAAAlE,EAAAkE,GAAA,MAAAD,EAIA,KAFA,GAAAnH,GAAAtF,OAAAsF,KAAAoH,GACA3M,EAAAuF,EAAA1B,OACA7D,KACA0M,EAAAnH,EAAAvF,IAAA2M,EAAApH,EAAAvF,GAEA,OAAA0M,MJuM8B9M,KAAKJ,EAAU,WAAa,MAAOmB,SAAYtB,EAAoB,MAI3F,SAASI,EAAQD,GK1vBvB,QAAAoN,KACAjM,KAAAkM,QAAAlM,KAAAkM,YACAlM,KAAAmM,cAAAnM,KAAAmM,eAAArL,OAwQA,QAAAwD,GAAAoD,GACA,wBAAAA,GAGA,QAAAlB,GAAAkB,GACA,sBAAAA,GAGA,QAAAI,GAAAJ,GACA,sBAAAA,IAAA,OAAAA,EAGA,QAAAlE,GAAAkE,GACA,gBAAAA,EAnRA5I,EAAAD,QAAAoN,EAGAA,iBAEAA,EAAA1M,UAAA2M,QAAApL,OACAmL,EAAA1M,UAAA4M,cAAArL,OAIAmL,EAAAG,oBAAA,GAIAH,EAAA1M,UAAA8M,gBAAA,SAAA1G,GACA,IAAAa,EAAAb,MAAA,GAAA2G,MAAA3G,GACA,KAAA3E,WAAA,8BAEA,OADAhB,MAAAmM,cAAAxG,EACA3F,MAGAiM,EAAA1M,UAAAyC,KAAA,SAAAuK,GACA,GAAAC,GAAAC,EAAAvD,EAAAxJ,EAAAL,EAAAqN,CAMA,IAJA1M,KAAAkM,UACAlM,KAAAkM,YAGA,UAAAK,KACAvM,KAAAkM,QAAApC,OACAhC,EAAA9H,KAAAkM,QAAApC,SAAA9J,KAAAkM,QAAApC,MAAA5G,QAAA,CAEA,GADAsJ,EAAArL,UAAA,GACAqL,YAAA/F,OACA,KAAA+F,EAGA,IAAAG,GAAA,GAAAlG,OAAA,yCAAA+F,EAAA,IAEA,MADAG,GAAAC,QAAAJ,EACAG,EAOA,GAFAF,EAAAzM,KAAAkM,QAAAK,GAEA/I,EAAAiJ,GACA,QAEA,IAAAnI,EAAAmI,GACA,OAAAtL,UAAA+B,QAEA,OACAuJ,EAAAxN,KAAAe,KACA,MACA,QACAyM,EAAAxN,KAAAe,KAAAmB,UAAA,GACA,MACA,QACAsL,EAAAxN,KAAAe,KAAAmB,UAAA,GAAAA,UAAA,GACA,MAEA,SACAzB,EAAAwB,MAAA3B,UAAAI,MAAAV,KAAAkC,UAAA,GACAsL,EAAA1M,MAAAC,KAAAN,OAEG,IAAAoI,EAAA2E,GAIH,IAHA/M,EAAAwB,MAAA3B,UAAAI,MAAAV,KAAAkC,UAAA,GACAuL,EAAAD,EAAA9M,QACAuJ,EAAAwD,EAAAxJ,OACA7D,EAAA,EAAeA,EAAA6J,EAAS7J,IACxBqN,EAAArN,GAAAU,MAAAC,KAAAN,EAGA,WAGAuM,EAAA1M,UAAAsN,YAAA,SAAAN,EAAAO,GACA,GAAA5N,EAEA,KAAAoF,EAAAwI,GACA,KAAA9L,WAAA,8BA2CA,OAzCAhB,MAAAkM,UACAlM,KAAAkM,YAIAlM,KAAAkM,QAAAa,aACA/M,KAAAgC,KAAA,cAAAuK,EACAjI,EAAAwI,YACAA,cAEA9M,KAAAkM,QAAAK,GAGAzE,EAAA9H,KAAAkM,QAAAK,IAEAvM,KAAAkM,QAAAK,GAAA1G,KAAAiH,GAGA9M,KAAAkM,QAAAK,IAAAvM,KAAAkM,QAAAK,GAAAO,GANA9M,KAAAkM,QAAAK,GAAAO,EASAhF,EAAA9H,KAAAkM,QAAAK,MAAAvM,KAAAkM,QAAAK,GAAA9C,SAIAvK,EAHAsE,EAAAxD,KAAAmM,eAGAF,EAAAG,oBAFApM,KAAAmM,cAKAjN,KAAA,GAAAc,KAAAkM,QAAAK,GAAArJ,OAAAhE,IACAc,KAAAkM,QAAAK,GAAA9C,QAAA,EACAG,QAAAE,MAAA,mIAGA9J,KAAAkM,QAAAK,GAAArJ,QACA,kBAAA0G,SAAAC,OAEAD,QAAAC,UAKA7J,MAGAiM,EAAA1M,UAAAuC,GAAAmK,EAAA1M,UAAAsN,YAEAZ,EAAA1M,UAAAyN,KAAA,SAAAT,EAAAO,GAMA,QAAAG,KACAjN,KAAAkN,eAAAX,EAAAU,GAEAE,IACAA,GAAA,EACAL,EAAA/M,MAAAC,KAAAmB,YAVA,IAAAmD,EAAAwI,GACA,KAAA9L,WAAA,8BAEA,IAAAmM,IAAA,CAcA,OAHAF,GAAAH,WACA9M,KAAA8B,GAAAyK,EAAAU,GAEAjN,MAIAiM,EAAA1M,UAAA2N,eAAA,SAAAX,EAAAO,GACA,GAAAM,GAAAC,EAAAnK,EAAA7D,CAEA,KAAAiF,EAAAwI,GACA,KAAA9L,WAAA,8BAEA,KAAAhB,KAAAkM,UAAAlM,KAAAkM,QAAAK,GACA,MAAAvM,KAMA,IAJAoN,EAAApN,KAAAkM,QAAAK,GACArJ,EAAAkK,EAAAlK,OACAmK,GAAA,EAEAD,IAAAN,GACAxI,EAAA8I,EAAAN,WAAAM,EAAAN,mBACA9M,MAAAkM,QAAAK,GACAvM,KAAAkM,QAAAgB,gBACAlN,KAAAgC,KAAA,iBAAAuK,EAAAO,OAEG,IAAAhF,EAAAsF,GAAA,CACH,IAAA/N,EAAA6D,EAAoB7D,KAAA,GACpB,GAAA+N,EAAA/N,KAAAyN,GACAM,EAAA/N,GAAAyN,UAAAM,EAAA/N,GAAAyN,aAAA,CACAO,EAAAhO,CACA,OAIA,GAAAgO,EAAA,EACA,MAAArN,KAEA,KAAAoN,EAAAlK,QACAkK,EAAAlK,OAAA,QACAlD,MAAAkM,QAAAK,IAEAa,EAAAE,OAAAD,EAAA,GAGArN,KAAAkM,QAAAgB,gBACAlN,KAAAgC,KAAA,iBAAAuK,EAAAO,GAGA,MAAA9M,OAGAiM,EAAA1M,UAAAgO,mBAAA,SAAAhB,GACA,GAAAhL,GAAAmL,CAEA,KAAA1M,KAAAkM,QACA,MAAAlM,KAGA,KAAAA,KAAAkM,QAAAgB,eAKA,MAJA,KAAA/L,UAAA+B,OACAlD,KAAAkM,WACAlM,KAAAkM,QAAAK,UACAvM,MAAAkM,QAAAK,GACAvM,IAIA,QAAAmB,UAAA+B,OAAA,CACA,IAAA3B,IAAAvB,MAAAkM,QACA,mBAAA3K,GACAvB,KAAAuN,mBAAAhM,EAIA,OAFAvB,MAAAuN,mBAAA,kBACAvN,KAAAkM,WACAlM,KAKA,GAFA0M,EAAA1M,KAAAkM,QAAAK,GAEAjI,EAAAoI,GACA1M,KAAAkN,eAAAX,EAAAG,OACG,IAAAA,EAEH,KAAAA,EAAAxJ,QACAlD,KAAAkN,eAAAX,EAAAG,IAAAxJ,OAAA,GAIA,cAFAlD,MAAAkM,QAAAK,GAEAvM,MAGAiM,EAAA1M,UAAAmN,UAAA,SAAAH,GACA,GAAA/H,EAOA,OAHAA,GAHAxE,KAAAkM,SAAAlM,KAAAkM,QAAAK,GAEAjI,EAAAtE,KAAAkM,QAAAK,KACAvM,KAAAkM,QAAAK,IAEAvM,KAAAkM,QAAAK,GAAA5M,YAIAsM,EAAA1M,UAAAiO,cAAA,SAAAjB,GACA,GAAAvM,KAAAkM,QAAA,CACA,GAAAuB,GAAAzN,KAAAkM,QAAAK,EAEA,IAAAjI,EAAAmJ,GACA,QACA,IAAAA,EACA,MAAAA,GAAAvK,OAEA,UAGA+I,EAAAuB,cAAA,SAAAE,EAAAnB,GACA,MAAAmB,GAAAF,cAAAjB,KLuyBM,SAASzN,EAAQD,EAASH,GMnkChC,YAsBA,SAAAiP,GAAAC,EAAAC,GACApH,MAAAqH,kBACArH,MAAAqH,kBAAA9N,KAAA2N,GAEA3N,KAAA+N,MAAA,GAAAtH,OAAAoH,GAAAE,MAGA/N,KAAA6N,WACAF,EAAAK,gBAAAJ,IACAA,EAAAvI,WAEArF,KAAA4N,OA/BA,GAAAK,GAAAvP,EAAA,GAEAwP,IACApP,GAAAD,QAAAqP,EAIAA,EAAAC,kBAAA,GACAD,EAAAE,gBAAA,GACAF,EAAAG,wBAAA,GACAH,EAAAI,2BAAA,GACAJ,EAAAK,qBAAA,GACAL,EAAAM,iBAAA,GACAN,EAAAO,uBAAA,GAqBAR,EAAAnC,SAAA6B,EAAAlH,OACAyH,EAAAP,cAEAA,EAAApO,UAAA2F,KAAA,cAKAyI,EAAApO,UAAAmP,YAAA,WACA,GAAAC,GAAA3O,KAAA6N,SAAA7N,KAAA6N,UAAA7N,KAAA4N,KAAAvI,WACAuJ,EAAAjB,EAAAK,gBAAAxO,eAAAQ,KAAA4N,KAEA,OAAAe,KAAAC,GACA5O,KAAA4N,KAAA5N,KAAA6N,UAEA7N,KAAA4N,OAOAD,EAAAkB,cAAA,SAAA5K,GACA,UAAA0J,GAAA1J,EAAA,GAAAA,EAAA,KAOA0J,EAAAmB,gBAAA,SAAAhF,GACA,MAAAA,aAAA6D,GACA7D,EAAA4E,cACGxN,MAAAwE,QAAAoE,GACHA,EACG,oBACHA,GACG,oBACH,EAAAA,IAEA,EAAAA,EAAAzE,aAMAsI,EAAAK,mBAEAL,EAAAK,gBAAAE,EAAAC,mBACA,wBAEAR,EAAAK,gBAAAE,EAAAE,iBACA,wBAEAT,EAAAK,gBAAAE,EAAAG,yBACA,sBAEAV,EAAAK,gBAAAE,EAAAI,4BACA,yBAEAX,EAAAK,gBAAAE,EAAAK,sBACA,mBAEAZ,EAAAK,gBAAAE,EAAAM,kBACA,eAEAb,EAAAK,gBAAAE,EAAAO,wBACA,sBN0kCM,SAAS3P,EAAQD,EAASH,IOjrChC,SAAAiC,EAAA8B,GAQA,YA2CA,SAAAsM,KACA,IACA,GAAAC,GAAA,GAAAC,YAAA,EAEA,OADAD,GAAAE,WAAqBA,UAAAD,WAAA1P,UAAA4P,IAAA,WAAmD,YACxE,KAAAH,EAAAG,OACA,kBAAAH,GAAAI,UACA,IAAAJ,EAAAI,SAAA,KAAAC,WACG,MAAApH,GACH,UAIA,QAAAqH,KACA,MAAA3O,GAAA4O,oBACA,WACA,WAGA,QAAAC,GAAAC,EAAAvM,GACA,GAAAoM,IAAApM,EACA,SAAAwM,YAAA,6BAcA,OAZA/O,GAAA4O,qBAEAE,EAAA,GAAAR,YAAA/L,GACAuM,EAAAP,UAAAvO,EAAApB,YAGA,OAAAkQ,IACAA,EAAA,GAAA9O,GAAAuC,IAEAuM,EAAAvM,UAGAuM,EAaA,QAAA9O,GAAA+G,EAAAiI,EAAAzM,GACA,KAAAvC,EAAA4O,qBAAAvP,eAAAW,IACA,UAAAA,GAAA+G,EAAAiI,EAAAzM,EAIA,oBAAAwE,GAAA,CACA,mBAAAiI,GACA,SAAAlJ,OACA,oEAGA,OAAAmJ,GAAA5P,KAAA0H,GAEA,MAAAhG,GAAA1B,KAAA0H,EAAAiI,EAAAzM,GAWA,QAAAxB,GAAA+N,EAAA5O,EAAA8O,EAAAzM,GACA,mBAAArC,GACA,SAAAG,WAAA,wCAGA,0BAAA6O,cAAAhP,YAAAgP,aACAC,EAAAL,EAAA5O,EAAA8O,EAAAzM,GAGA,gBAAArC,GACAkP,EAAAN,EAAA5O,EAAA8O,GAGAK,EAAAP,EAAA5O,GA4BA,QAAAoP,GAAA5N,GACA,mBAAAA,GACA,SAAArB,WAAA,mCACG,IAAAqB,EAAA,EACH,SAAAqN,YAAA,wCAIA,QAAAlN,GAAAiN,EAAApN,EAAAE,EAAA2N,GAEA,MADAD,GAAA5N,GACAA,GAAA,EACAmN,EAAAC,EAAApN,GAEAvB,SAAAyB,EAIA,gBAAA2N,GACAV,EAAAC,EAAApN,GAAAE,OAAA2N,GACAV,EAAAC,EAAApN,GAAAE,QAEAiN,EAAAC,EAAApN,GAWA,QAAAuN,GAAAH,EAAApN,GAGA,GAFA4N,EAAA5N,GACAoN,EAAAD,EAAAC,EAAApN,EAAA,MAAA8N,EAAA9N,KACA1B,EAAA4O,oBACA,OAAAlQ,GAAA,EAAmBA,EAAAgD,IAAUhD,EAC7BoQ,EAAApQ,GAAA,CAGA,OAAAoQ,GAgBA,QAAAM,GAAAN,EAAAhE,EAAAyE,GAKA,GAJA,gBAAAA,IAAA,KAAAA,IACAA,EAAA,SAGAvP,EAAAyP,WAAAF,GACA,SAAAlP,WAAA,6CAGA,IAAAkC,GAAA,EAAAmM,EAAA5D,EAAAyE,EACAT,GAAAD,EAAAC,EAAAvM,EAEA,IAAAmN,GAAAZ,EAAAa,MAAA7E,EAAAyE,EASA,OAPAG,KAAAnN,IAIAuM,IAAA9P,MAAA,EAAA0Q,IAGAZ,EAGA,QAAAc,GAAAd,EAAAxL,GACA,GAAAf,GAAAe,EAAAf,OAAA,MAAAiN,EAAAlM,EAAAf,OACAuM,GAAAD,EAAAC,EAAAvM,EACA,QAAA7D,GAAA,EAAiBA,EAAA6D,EAAY7D,GAAA,EAC7BoQ,EAAApQ,GAAA,IAAA4E,EAAA5E,EAEA,OAAAoQ,GAGA,QAAAK,GAAAL,EAAAxL,EAAAuM,EAAAtN,GAGA,GAFAe,EAAAoL,WAEAmB,EAAA,GAAAvM,EAAAoL,WAAAmB,EACA,SAAAd,YAAA,4BAGA,IAAAzL,EAAAoL,WAAAmB,GAAAtN,GAAA,GACA,SAAAwM,YAAA,4BAmBA,OAfAzL,GADAnD,SAAA0P,GAAA1P,SAAAoC,EACA,GAAA+L,YAAAhL,GACGnD,SAAAoC,EACH,GAAA+L,YAAAhL,EAAAuM,GAEA,GAAAvB,YAAAhL,EAAAuM,EAAAtN,GAGAvC,EAAA4O,qBAEAE,EAAAxL,EACAwL,EAAAP,UAAAvO,EAAApB,WAGAkQ,EAAAc,EAAAd,EAAAxL,GAEAwL,EAGA,QAAAO,GAAAP,EAAA7M,GACA,GAAAjC,EAAAiL,SAAAhJ,GAAA,CACA,GAAAsG,GAAA,EAAAiH,EAAAvN,EAAAM,OAGA,OAFAuM,GAAAD,EAAAC,EAAAvG,GAEA,IAAAuG,EAAAvM,OACAuM,GAGA7M,EAAA6N,KAAAhB,EAAA,IAAAvG,GACAuG,GAGA,GAAA7M,EAAA,CACA,sBAAAiN,cACAjN,EAAAN,iBAAAuN,cAAA,UAAAjN,GACA,sBAAAA,GAAAM,QAAAwN,EAAA9N,EAAAM,QACAsM,EAAAC,EAAA,GAEAc,EAAAd,EAAA7M,EAGA,eAAAA,EAAA2J,MAAA7G,EAAA9C,EAAA+N,MACA,MAAAJ,GAAAd,EAAA7M,EAAA+N,MAIA,SAAA3P,WAAA,sFAGA,QAAAmP,GAAAjN,GAGA,GAAAA,GAAAoM,IACA,SAAAI,YAAA,0DACAJ,IAAAjK,SAAA,aAEA,UAAAnC,EAGA,QAAA0N,GAAA1N,GAIA,OAHAA,OACAA,EAAA,GAEAvC,EAAA6B,OAAAU,GA+EA,QAAAmM,GAAA5D,EAAAyE,GACA,GAAAvP,EAAAiL,SAAAH,GACA,MAAAA,GAAAvI,MAEA,uBAAA2M,cAAA,kBAAAA,aAAAgB,SACAhB,YAAAgB,OAAApF,gBAAAoE,cACA,MAAApE,GAAA4D,UAEA,iBAAA5D,KACAA,EAAA,GAAAA,EAGA,IAAAvC,GAAAuC,EAAAvI,MACA,QAAAgG,EAAA,QAIA,KADA,GAAA4H,IAAA,IAEA,OAAAZ,GACA,YACA,aACA,aACA,MAAAhH,EACA,YACA,YACA,IAAApI,QACA,MAAAiQ,GAAAtF,GAAAvI,MACA,YACA,YACA,cACA,eACA,SAAAgG,CACA,WACA,MAAAA,KAAA,CACA,cACA,MAAA8H,GAAAvF,GAAAvI,MACA,SACA,GAAA4N,EAAA,MAAAC,GAAAtF,GAAAvI,MACAgN,IAAA,GAAAA,GAAAe,cACAH,GAAA,GAMA,QAAAI,GAAAhB,EAAAiB,EAAAC,GACA,GAAAN,IAAA,CAcA,KALAhQ,SAAAqQ,KAAA,KACAA,EAAA,GAIAA,EAAAnR,KAAAkD,OACA,QAOA,KAJApC,SAAAsQ,KAAApR,KAAAkD,UACAkO,EAAApR,KAAAkD,QAGAkO,GAAA,EACA,QAOA,IAHAA,KAAA,EACAD,KAAA,EAEAC,GAAAD,EACA,QAKA,KAFAjB,MAAA,UAGA,OAAAA,GACA,UACA,MAAAmB,GAAArR,KAAAmR,EAAAC,EAEA,YACA,YACA,MAAAE,GAAAtR,KAAAmR,EAAAC,EAEA,aACA,MAAAG,GAAAvR,KAAAmR,EAAAC,EAEA,cACA,aACA,MAAAI,GAAAxR,KAAAmR,EAAAC,EAEA,cACA,MAAAK,GAAAzR,KAAAmR,EAAAC,EAEA,YACA,YACA,cACA,eACA,MAAAM,GAAA1R,KAAAmR,EAAAC,EAEA,SACA,GAAAN,EAAA,SAAA9P,WAAA,qBAAAkP,EACAA,MAAA,IAAAe,cACAH,GAAA,GASA,QAAAa,GAAA7R,EAAA6F,EAAAzG,GACA,GAAAG,GAAAS,EAAA6F,EACA7F,GAAA6F,GAAA7F,EAAAZ,GACAY,EAAAZ,GAAAG,EAmIA,QAAAuS,GAAAtP,EAAA6B,EAAAqM,EAAAN,EAAA2B,GAEA,OAAAvP,EAAAY,OAAA,QAmBA,IAhBA,gBAAAsN,IACAN,EAAAM,EACAA,EAAA,GACGA,EAAA,WACHA,EAAA,WACGA,GAAA,aACHA,GAAA,YAEAA,KACAlE,MAAAkE,KAEAA,EAAAqB,EAAA,EAAAvP,EAAAY,OAAA,GAIAsN,EAAA,IAAAA,EAAAlO,EAAAY,OAAAsN,GACAA,GAAAlO,EAAAY,OAAA,CACA,GAAA2O,EAAA,QACArB,GAAAlO,EAAAY,OAAA,MACG,IAAAsN,EAAA,GACH,IAAAqB,EACA,QADArB,GAAA,EAUA,GALA,gBAAArM,KACAA,EAAAxD,EAAAe,KAAAyC,EAAA+L,IAIAvP,EAAAiL,SAAAzH,GAEA,WAAAA,EAAAjB,QACA,EAEA4O,EAAAxP,EAAA6B,EAAAqM,EAAAN,EAAA2B,EACG,oBAAA1N,GAEH,MADAA,IAAA,IACAxD,EAAA4O,qBACA,kBAAAN,YAAA1P,UAAAyF,QACA6M,EACA5C,WAAA1P,UAAAyF,QAAA/F,KAAAqD,EAAA6B,EAAAqM,GAEAvB,WAAA1P,UAAAwS,YAAA9S,KAAAqD,EAAA6B,EAAAqM,GAGAsB,EAAAxP,GAAA6B,GAAAqM,EAAAN,EAAA2B,EAGA,UAAA7Q,WAAA,wCAGA,QAAA8Q,GAAA9C,EAAA7K,EAAAqM,EAAAN,EAAA2B,GAmBA,QAAAG,GAAAC,EAAA5S,GACA,WAAA6S,EACAD,EAAA5S,GAEA4S,EAAAE,aAAA9S,EAAA6S,GAtBA,GAAAA,GAAA,EACAE,EAAApD,EAAA9L,OACAmP,EAAAlO,EAAAjB,MAEA,IAAApC,SAAAoP,IACAA,EAAAvJ,OAAAuJ,GAAAe,cACA,SAAAf,GAAA,UAAAA,GACA,YAAAA,GAAA,aAAAA,GAAA,CACA,GAAAlB,EAAA9L,OAAA,GAAAiB,EAAAjB,OAAA,EACA,QAEAgP,GAAA,EACAE,GAAA,EACAC,GAAA,EACA7B,GAAA,EAYA,GAAAnR,EACA,IAAAwS,EAAA,CACA,GAAAS,IAAA,CACA,KAAAjT,EAAAmR,EAAwBnR,EAAA+S,EAAe/S,IACvC,GAAA2S,EAAAhD,EAAA3P,KAAA2S,EAAA7N,EAAAmO,KAAA,IAAAjT,EAAAiT,IAEA,GADAA,KAAA,IAAAA,EAAAjT,GACAA,EAAAiT,EAAA,IAAAD,EAAA,MAAAC,GAAAJ,MAEAI,MAAA,IAAAjT,KAAAiT,GACAA,GAAA,MAKA,KADA9B,EAAA6B,EAAAD,IAAA5B,EAAA4B,EAAAC,GACAhT,EAAAmR,EAAwBnR,GAAA,EAAQA,IAAA,CAEhC,OADAkT,IAAA,EACAC,EAAA,EAAqBA,EAAAH,EAAeG,IACpC,GAAAR,EAAAhD,EAAA3P,EAAAmT,KAAAR,EAAA7N,EAAAqO,GAAA,CACAD,GAAA,CACA,OAGA,GAAAA,EAAA,MAAAlT,GAIA,SAeA,QAAAoT,GAAAR,EAAAxG,EAAAiH,EAAAxP,GACAwP,EAAAtJ,OAAAsJ,IAAA,CACA,IAAAC,GAAAV,EAAA/O,OAAAwP,CACAxP,IAGAA,EAAAkG,OAAAlG,GACAA,EAAAyP,IACAzP,EAAAyP,IAJAzP,EAAAyP,CASA,IAAAC,GAAAnH,EAAAvI,MACA,IAAA0P,EAAA,eAAA5R,WAAA,qBAEAkC,GAAA0P,EAAA,IACA1P,EAAA0P,EAAA,EAEA,QAAAvT,GAAA,EAAiBA,EAAA6D,IAAY7D,EAAA,CAC7B,GAAAwT,GAAAC,SAAArH,EAAArE,OAAA,EAAA/H,EAAA,MACA,IAAAiN,MAAAuG,GAAA,MAAAxT,EACA4S,GAAAS,EAAArT,GAAAwT,EAEA,MAAAxT,GAGA,QAAA0T,GAAAd,EAAAxG,EAAAiH,EAAAxP,GACA,MAAA8P,GAAAjC,EAAAtF,EAAAwG,EAAA/O,OAAAwP,GAAAT,EAAAS,EAAAxP,GAGA,QAAA+P,GAAAhB,EAAAxG,EAAAiH,EAAAxP,GACA,MAAA8P,GAAAE,EAAAzH,GAAAwG,EAAAS,EAAAxP,GAGA,QAAAiQ,GAAAlB,EAAAxG,EAAAiH,EAAAxP,GACA,MAAA+P,GAAAhB,EAAAxG,EAAAiH,EAAAxP,GAGA,QAAAkQ,GAAAnB,EAAAxG,EAAAiH,EAAAxP,GACA,MAAA8P,GAAAhC,EAAAvF,GAAAwG,EAAAS,EAAAxP,GAGA,QAAAmQ,GAAApB,EAAAxG,EAAAiH,EAAAxP,GACA,MAAA8P,GAAAM,EAAA7H,EAAAwG,EAAA/O,OAAAwP,GAAAT,EAAAS,EAAAxP,GAkFA,QAAAuO,GAAAQ,EAAAd,EAAAC,GACA,WAAAD,GAAAC,IAAAa,EAAA/O,OACAqQ,EAAAC,cAAAvB,GAEAsB,EAAAC,cAAAvB,EAAAtS,MAAAwR,EAAAC,IAIA,QAAAE,GAAAW,EAAAd,EAAAC,GACAA,EAAAqC,KAAAC,IAAAzB,EAAA/O,OAAAkO,EAIA,KAHA,GAAAuC,MAEAtU,EAAA8R,EACA9R,EAAA+R,GAAA,CACA,GAAAwC,GAAA3B,EAAA5S,GACAwU,EAAA,KACAC,EAAAF,EAAA,MACAA,EAAA,MACAA,EAAA,MACA,CAEA,IAAAvU,EAAAyU,GAAA1C,EAAA,CACA,GAAA2C,GAAAC,EAAAC,EAAAC,CAEA,QAAAJ,GACA,OACAF,EAAA,MACAC,EAAAD,EAEA,MACA,QACAG,EAAA9B,EAAA5S,EAAA,GACA,WAAA0U,KACAG,GAAA,GAAAN,IAAA,KAAAG,EACAG,EAAA,MACAL,EAAAK,GAGA,MACA,QACAH,EAAA9B,EAAA5S,EAAA,GACA2U,EAAA/B,EAAA5S,EAAA,GACA,WAAA0U,IAAA,WAAAC,KACAE,GAAA,GAAAN,IAAA,OAAAG,IAAA,KAAAC,EACAE,EAAA,OAAAA,EAAA,OAAAA,EAAA,SACAL,EAAAK,GAGA,MACA,QACAH,EAAA9B,EAAA5S,EAAA,GACA2U,EAAA/B,EAAA5S,EAAA,GACA4U,EAAAhC,EAAA5S,EAAA,GACA,WAAA0U,IAAA,WAAAC,IAAA,WAAAC,KACAC,GAAA,GAAAN,IAAA,OAAAG,IAAA,OAAAC,IAAA,KAAAC,EACAC,EAAA,OAAAA,EAAA,UACAL,EAAAK,KAMA,OAAAL,GAGAA,EAAA,MACAC,EAAA,GACKD,EAAA,QAELA,GAAA,MACAF,EAAA9N,KAAAgO,IAAA,eACAA,EAAA,WAAAA,GAGAF,EAAA9N,KAAAgO,GACAxU,GAAAyU,EAGA,MAAAK,GAAAR,GAQA,QAAAQ,GAAAC,GACA,GAAAlL,GAAAkL,EAAAlR,MACA,IAAAgG,GAAAmL,GACA,MAAA1N,QAAA2N,aAAAvU,MAAA4G,OAAAyN,EAMA,KAFA,GAAAT,GAAA,GACAtU,EAAA,EACAA,EAAA6J,GACAyK,GAAAhN,OAAA2N,aAAAvU,MACA4G,OACAyN,EAAAzU,MAAAN,KAAAgV,IAGA,OAAAV,GAGA,QAAApC,GAAAU,EAAAd,EAAAC,GACA,GAAA5M,GAAA,EACA4M,GAAAqC,KAAAC,IAAAzB,EAAA/O,OAAAkO,EAEA,QAAA/R,GAAA8R,EAAqB9R,EAAA+R,IAAS/R,EAC9BmF,GAAAmC,OAAA2N,aAAA,IAAArC,EAAA5S,GAEA,OAAAmF,GAGA,QAAAgN,GAAAS,EAAAd,EAAAC,GACA,GAAA5M,GAAA,EACA4M,GAAAqC,KAAAC,IAAAzB,EAAA/O,OAAAkO,EAEA,QAAA/R,GAAA8R,EAAqB9R,EAAA+R,IAAS/R,EAC9BmF,GAAAmC,OAAA2N,aAAArC,EAAA5S,GAEA,OAAAmF,GAGA,QAAA6M,GAAAY,EAAAd,EAAAC,GACA,GAAAlI,GAAA+I,EAAA/O,SAEAiO,KAAA,KAAAA,EAAA,KACAC,KAAA,GAAAA,EAAAlI,KAAAkI,EAAAlI,EAGA,QADAqL,GAAA,GACAlV,EAAA8R,EAAqB9R,EAAA+R,IAAS/R,EAC9BkV,GAAAC,EAAAvC,EAAA5S,GAEA,OAAAkV,GAGA,QAAA7C,GAAAO,EAAAd,EAAAC,GAGA,OAFAqD,GAAAxC,EAAAtS,MAAAwR,EAAAC,GACAuC,EAAA,GACAtU,EAAA,EAAiBA,EAAAoV,EAAAvR,OAAkB7D,GAAA,EACnCsU,GAAAhN,OAAA2N,aAAAG,EAAApV,GAAA,IAAAoV,EAAApV,EAAA,GAEA,OAAAsU,GA0CA,QAAAe,GAAAhC,EAAAiC,EAAAzR,GACA,GAAAwP,EAAA,OAAAA,EAAA,WAAAhD,YAAA,qBACA,IAAAgD,EAAAiC,EAAAzR,EAAA,SAAAwM,YAAA,yCA+JA,QAAAkF,GAAA3C,EAAApR,EAAA6R,EAAAiC,EAAAE,EAAAnB,GACA,IAAA/S,EAAAiL,SAAAqG,GAAA,SAAAjR,WAAA,8CACA,IAAAH,EAAAgU,GAAAhU,EAAA6S,EAAA,SAAAhE,YAAA,oCACA,IAAAgD,EAAAiC,EAAA1C,EAAA/O,OAAA,SAAAwM,YAAA,sBAkDA,QAAAoF,GAAA7C,EAAApR,EAAA6R,EAAAqC,GACAlU,EAAA,IAAAA,EAAA,MAAAA,EAAA,EACA,QAAAxB,GAAA,EAAAmT,EAAAiB,KAAAC,IAAAzB,EAAA/O,OAAAwP,EAAA,GAAuDrT,EAAAmT,IAAOnT,EAC9D4S,EAAAS,EAAArT,IAAAwB,EAAA,QAAAkU,EAAA1V,EAAA,EAAAA,MACA,GAAA0V,EAAA1V,EAAA,EAAAA,GA8BA,QAAA2V,GAAA/C,EAAApR,EAAA6R,EAAAqC,GACAlU,EAAA,IAAAA,EAAA,WAAAA,EAAA,EACA,QAAAxB,GAAA,EAAAmT,EAAAiB,KAAAC,IAAAzB,EAAA/O,OAAAwP,EAAA,GAAuDrT,EAAAmT,IAAOnT,EAC9D4S,EAAAS,EAAArT,GAAAwB,IAAA,GAAAkU,EAAA1V,EAAA,EAAAA,GAAA,IAmJA,QAAA4V,GAAAhD,EAAApR,EAAA6R,EAAAiC,EAAAE,EAAAnB,GACA,GAAAhB,EAAAiC,EAAA1C,EAAA/O,OAAA,SAAAwM,YAAA,qBACA,IAAAgD,EAAA,WAAAhD,YAAA,sBAGA,QAAAwF,GAAAjD,EAAApR,EAAA6R,EAAAqC,EAAAI,GAKA,MAJAA,IACAF,EAAAhD,EAAApR,EAAA6R,EAAA,gDAEA0C,EAAA9E,MAAA2B,EAAApR,EAAA6R,EAAAqC,EAAA,MACArC,EAAA,EAWA,QAAA2C,GAAApD,EAAApR,EAAA6R,EAAAqC,EAAAI,GAKA,MAJAA,IACAF,EAAAhD,EAAApR,EAAA6R,EAAA,kDAEA0C,EAAA9E,MAAA2B,EAAApR,EAAA6R,EAAAqC,EAAA,MACArC,EAAA,EAgIA,QAAA4C,GAAA1R,GAIA,GAFAA,EAAA2R,EAAA3R,GAAA2C,QAAAiP,GAAA,IAEA5R,EAAAV,OAAA,UAEA,MAAAU,EAAAV,OAAA,OACAU,GAAA,GAEA,OAAAA,GAGA,QAAA2R,GAAA3R,GACA,MAAAA,GAAA6R,KAAA7R,EAAA6R,OACA7R,EAAA2C,QAAA,iBAGA,QAAAiO,GAAA7O,GACA,MAAAA,GAAA,OAAAA,EAAAN,SAAA,IACAM,EAAAN,SAAA,IAGA,QAAA0L,GAAAtF,EAAAiK,GACAA,KAAAC,GAMA,QALA9B,GACA3Q,EAAAuI,EAAAvI,OACA0S,EAAA,KACAnB,KAEApV,EAAA,EAAiBA,EAAA6D,IAAY7D,EAAA,CAI7B,GAHAwU,EAAApI,EAAAoK,WAAAxW,GAGAwU,EAAA,OAAAA,EAAA,OAEA,IAAA+B,EAAA,CAEA,GAAA/B,EAAA,QAEA6B,GAAA,OAAAjB,EAAA5O,KAAA,YACA,UACS,GAAAxG,EAAA,IAAA6D,EAAA,EAETwS,GAAA,OAAAjB,EAAA5O,KAAA,YACA,UAIA+P,EAAA/B,CAEA,UAIA,GAAAA,EAAA,QACA6B,GAAA,OAAAjB,EAAA5O,KAAA,aACA+P,EAAA/B,CACA,UAIAA,GAAA+B,EAAA,UAAA/B,EAAA,iBACK+B,KAELF,GAAA,OAAAjB,EAAA5O,KAAA,YAMA,IAHA+P,EAAA,KAGA/B,EAAA,KACA,IAAA6B,GAAA,UACAjB,GAAA5O,KAAAgO,OACK,IAAAA,EAAA,MACL,IAAA6B,GAAA,UACAjB,GAAA5O,KACAgO,GAAA,MACA,GAAAA,EAAA,SAEK,IAAAA,EAAA,OACL,IAAA6B,GAAA,UACAjB,GAAA5O,KACAgO,GAAA,OACAA,GAAA,SACA,GAAAA,EAAA,SAEK,MAAAA,EAAA,SASL,SAAApN,OAAA,qBARA,KAAAiP,GAAA,UACAjB,GAAA5O,KACAgO,GAAA,OACAA,GAAA,UACAA,GAAA,SACA,GAAAA,EAAA,MAOA,MAAAY,GAGA,QAAAvB,GAAAtP,GAEA,OADAkS,MACAzW,EAAA,EAAiBA,EAAAuE,EAAAV,SAAgB7D,EAEjCyW,EAAAjQ,KAAA,IAAAjC,EAAAiS,WAAAxW,GAEA,OAAAyW,GAGA,QAAAxC,GAAA1P,EAAA8R,GAGA,OAFAvW,GAAA4W,EAAAC,EACAF,KACAzW,EAAA,EAAiBA,EAAAuE,EAAAV,WACjBwS,GAAA,QADiCrW,EAGjCF,EAAAyE,EAAAiS,WAAAxW,GACA0W,EAAA5W,GAAA,EACA6W,EAAA7W,EAAA,IACA2W,EAAAjQ,KAAAmQ,GACAF,EAAAjQ,KAAAkQ,EAGA,OAAAD,GAGA,QAAA9E,GAAApN,GACA,MAAA2P,GAAA0C,YAAAX,EAAA1R,IAGA,QAAAoP,GAAAkD,EAAAC,EAAAzD,EAAAxP,GACA,OAAA7D,GAAA,EAAiBA,EAAA6D,KACjB7D,EAAAqT,GAAAyD,EAAAjT,QAAA7D,GAAA6W,EAAAhT,UAD6B7D,EAE7B8W,EAAA9W,EAAAqT,GAAAwD,EAAA7W,EAEA,OAAAA,GAGA,QAAAqR,GAAAvM,GACA,MAAAA,OAjvDA,GAAAoP,GAAA7U,EAAA,IACA0W,EAAA1W,EAAA,IACAgH,EAAAhH,EAAA,GAEAG,GAAA8B,SACA9B,EAAA+R,aACA/R,EAAAuX,kBAAA,GA0BAzV,EAAA4O,oBAAAzO,SAAA2B,EAAA8M,oBACA9M,EAAA8M,oBACAR,IAKAlQ,EAAAyQ,eAkEA3O,EAAA0V,SAAA,KAGA1V,EAAA2V,SAAA,SAAAtH,GAEA,MADAA,GAAAE,UAAAvO,EAAApB,UACAyP,GA2BArO,EAAAe,KAAA,SAAAb,EAAA8O,EAAAzM,GACA,MAAAxB,GAAA,KAAAb,EAAA8O,EAAAzM,IAGAvC,EAAA4O,sBACA5O,EAAApB,UAAA2P,UAAAD,WAAA1P,UACAoB,EAAAuO,UAAAD,WACA,mBAAAsH,gBAAAC,SACA7V,EAAA4V,OAAAC,WAAA7V,GAEArB,OAAAmX,eAAA9V,EAAA4V,OAAAC,SACA3V,MAAA,KACA6V,cAAA,KAiCA/V,EAAA6B,MAAA,SAAAH,EAAAE,EAAA2N,GACA,MAAA1N,GAAA,KAAAH,EAAAE,EAAA2N,IAiBAvP,EAAAiP,YAAA,SAAAvN,GACA,MAAAuN,GAAA,KAAAvN,IAKA1B,EAAAgW,gBAAA,SAAAtU,GACA,MAAAuN,GAAA,KAAAvN,IAiHA1B,EAAAiL,SAAA,SAAA9L,GACA,cAAAA,MAAA8W,YAGAjW,EAAAkW,QAAA,SAAAhX,EAAAC,GACA,IAAAa,EAAAiL,SAAA/L,KAAAc,EAAAiL,SAAA9L,GACA,SAAAkB,WAAA,4BAGA,IAAAnB,IAAAC,EAAA,QAKA,QAHAqJ,GAAAtJ,EAAAqD,OACA4T,EAAAhX,EAAAoD,OAEA7D,EAAA,EAAA6J,EAAAuK,KAAAC,IAAAvK,EAAA2N,GAAuCzX,EAAA6J,IAAS7J,EAChD,GAAAQ,EAAAR,KAAAS,EAAAT,GAAA,CACA8J,EAAAtJ,EAAAR,GACAyX,EAAAhX,EAAAT,EACA,OAIA,MAAA8J,GAAA2N,GAAA,EACAA,EAAA3N,EAAA,EACA,GAGAxI,EAAAyP,WAAA,SAAAF,GACA,OAAAvJ,OAAAuJ,GAAAe,eACA,UACA,WACA,YACA,YACA,aACA,aACA,aACA,WACA,YACA,cACA,eACA,QACA,SACA,WAIAtQ,EAAAV,OAAA,SAAAmN,EAAAlK,GACA,IAAAwC,EAAA0H,GACA,SAAApM,WAAA,8CAGA,QAAAoM,EAAAlK,OACA,MAAAvC,GAAA6B,MAAA,EAGA,IAAAnD,EACA,IAAAyB,SAAAoC,EAEA,IADAA,EAAA,EACA7D,EAAA,EAAeA,EAAA+N,EAAAlK,SAAiB7D,EAChC6D,GAAAkK,EAAA/N,GAAA6D,MAIA,IAAAZ,GAAA3B,EAAAiP,YAAA1M,GACA6T,EAAA,CACA,KAAA1X,EAAA,EAAaA,EAAA+N,EAAAlK,SAAiB7D,EAAA,CAC9B,GAAA4S,GAAA7E,EAAA/N,EACA,KAAAsB,EAAAiL,SAAAqG,GACA,SAAAjR,WAAA,8CAEAiR,GAAAxB,KAAAnO,EAAAyU,GACAA,GAAA9E,EAAA/O,OAEA,MAAAZ,IA8CA3B,EAAA0O,aA0EA1O,EAAApB,UAAAqX,WAAA,EAQAjW,EAAApB,UAAAyX,OAAA,WACA,GAAA9N,GAAAlJ,KAAAkD,MACA,IAAAgG,EAAA,MACA,SAAAwG,YAAA,4CAEA,QAAArQ,GAAA,EAAiBA,EAAA6J,EAAS7J,GAAA,EAC1BsS,EAAA3R,KAAAX,IAAA,EAEA,OAAAW,OAGAW,EAAApB,UAAA0X,OAAA,WACA,GAAA/N,GAAAlJ,KAAAkD,MACA,IAAAgG,EAAA,MACA,SAAAwG,YAAA,4CAEA,QAAArQ,GAAA,EAAiBA,EAAA6J,EAAS7J,GAAA,EAC1BsS,EAAA3R,KAAAX,IAAA,GACAsS,EAAA3R,KAAAX,EAAA,EAAAA,EAAA,EAEA,OAAAW,OAGAW,EAAApB,UAAA2X,OAAA,WACA,GAAAhO,GAAAlJ,KAAAkD,MACA,IAAAgG,EAAA,MACA,SAAAwG,YAAA,4CAEA,QAAArQ,GAAA,EAAiBA,EAAA6J,EAAS7J,GAAA,EAC1BsS,EAAA3R,KAAAX,IAAA,GACAsS,EAAA3R,KAAAX,EAAA,EAAAA,EAAA,GACAsS,EAAA3R,KAAAX,EAAA,EAAAA,EAAA,GACAsS,EAAA3R,KAAAX,EAAA,EAAAA,EAAA,EAEA,OAAAW,OAGAW,EAAApB,UAAA8F,SAAA,WACA,GAAAnC,GAAA,EAAAlD,KAAAkD,MACA,YAAAA,EAAA,GACA,IAAA/B,UAAA+B,OAAAoO,EAAAtR,KAAA,EAAAkD,GACAgO,EAAAnR,MAAAC,KAAAmB,YAGAR,EAAApB,UAAA4X,OAAA,SAAArX,GACA,IAAAa,EAAAiL,SAAA9L,GAAA,SAAAkB,WAAA,4BACA,OAAAhB,QAAAF,GACA,IAAAa,EAAAkW,QAAA7W,KAAAF,IAGAa,EAAApB,UAAAoD,QAAA,WACA,GAAAiB,GAAA,GACAiR,EAAAhW,EAAAuX,iBAKA,OAJApW,MAAAkD,OAAA,IACAU,EAAA5D,KAAAqF,SAAA,QAAAwP,GAAAjO,MAAA,SAAkDO,KAAA,KAClDnH,KAAAkD,OAAA2R,IAAAjR,GAAA,UAEA,WAAAA,EAAA,KAGAjD,EAAApB,UAAAsX,QAAA,SAAA9V,EAAAoQ,EAAAC,EAAAgG,EAAAC,GACA,IAAA1W,EAAAiL,SAAA7K,GACA,SAAAC,WAAA,4BAgBA,IAbAF,SAAAqQ,IACAA,EAAA,GAEArQ,SAAAsQ,IACAA,EAAArQ,IAAAmC,OAAA,GAEApC,SAAAsW,IACAA,EAAA,GAEAtW,SAAAuW,IACAA,EAAArX,KAAAkD,QAGAiO,EAAA,GAAAC,EAAArQ,EAAAmC,QAAAkU,EAAA,GAAAC,EAAArX,KAAAkD,OACA,SAAAwM,YAAA,qBAGA,IAAA0H,GAAAC,GAAAlG,GAAAC,EACA,QAEA,IAAAgG,GAAAC,EACA,QAEA,IAAAlG,GAAAC,EACA,QAQA,IALAD,KAAA,EACAC,KAAA,EACAgG,KAAA,EACAC,KAAA,EAEArX,OAAAe,EAAA,QASA,QAPAoI,GAAAkO,EAAAD,EACAN,EAAA1F,EAAAD,EACAjI,EAAAuK,KAAAC,IAAAvK,EAAA2N,GAEAQ,EAAAtX,KAAAL,MAAAyX,EAAAC,GACAE,EAAAxW,EAAApB,MAAAwR,EAAAC,GAEA/R,EAAA,EAAiBA,EAAA6J,IAAS7J,EAC1B,GAAAiY,EAAAjY,KAAAkY,EAAAlY,GAAA,CACA8J,EAAAmO,EAAAjY,GACAyX,EAAAS,EAAAlY,EACA,OAIA,MAAA8J,GAAA2N,GAAA,EACAA,EAAA3N,EAAA,EACA,GA6HAxI,EAAApB,UAAAiY,SAAA,SAAArT,EAAAqM,EAAAN,GACA,MAAAlQ,MAAAgF,QAAAb,EAAAqM,EAAAN,MAAA,GAGAvP,EAAApB,UAAAyF,QAAA,SAAAb,EAAAqM,EAAAN,GACA,MAAA0B,GAAA5R,KAAAmE,EAAAqM,EAAAN,GAAA,IAGAvP,EAAApB,UAAAwS,YAAA,SAAA5N,EAAAqM,EAAAN,GACA,MAAA0B,GAAA5R,KAAAmE,EAAAqM,EAAAN,GAAA,IAkDAvP,EAAApB,UAAA+Q,MAAA,SAAA7E,EAAAiH,EAAAxP,EAAAgN,GAEA,GAAApP,SAAA4R,EACAxC,EAAA,OACAhN,EAAAlD,KAAAkD,OACAwP,EAAA,MAEG,IAAA5R,SAAAoC,GAAA,gBAAAwP,GACHxC,EAAAwC,EACAxP,EAAAlD,KAAAkD,OACAwP,EAAA,MAEG,KAAA+E,SAAA/E,GAWH,SAAAjM,OACA,0EAXAiM,IAAA,EACA+E,SAAAvU,IACAA,GAAA,EACApC,SAAAoP,MAAA,UAEAA,EAAAhN,EACAA,EAAApC,QASA,GAAA6R,GAAA3S,KAAAkD,OAAAwP,CAGA,KAFA5R,SAAAoC,KAAAyP,KAAAzP,EAAAyP,GAEAlH,EAAAvI,OAAA,IAAAA,EAAA,GAAAwP,EAAA,IAAAA,EAAA1S,KAAAkD,OACA,SAAAwM,YAAA,yCAGAQ,OAAA,OAGA,KADA,GAAAY,IAAA,IAEA,OAAAZ,GACA,UACA,MAAAuC,GAAAzS,KAAAyL,EAAAiH,EAAAxP,EAEA,YACA,YACA,MAAA6P,GAAA/S,KAAAyL,EAAAiH,EAAAxP,EAEA,aACA,MAAA+P,GAAAjT,KAAAyL,EAAAiH,EAAAxP,EAEA,cACA,aACA,MAAAiQ,GAAAnT,KAAAyL,EAAAiH,EAAAxP,EAEA,cAEA,MAAAkQ,GAAApT,KAAAyL,EAAAiH,EAAAxP,EAEA,YACA,YACA,cACA,eACA,MAAAmQ,GAAArT,KAAAyL,EAAAiH,EAAAxP,EAEA,SACA,GAAA4N,EAAA,SAAA9P,WAAA,qBAAAkP,EACAA,IAAA,GAAAA,GAAAe,cACAH,GAAA,IAKAnQ,EAAApB,UAAAmY,OAAA,WACA,OACAnL,KAAA,SACAoE,KAAAzP,MAAA3B,UAAAI,MAAAV,KAAAe,KAAA2X,MAAA3X,KAAA,IAwFA,IAAAqU,IAAA,IA8DA1T,GAAApB,UAAAI,MAAA,SAAAwR,EAAAC,GACA,GAAAlI,GAAAlJ,KAAAkD,MACAiO,OACAC,EAAAtQ,SAAAsQ,EAAAlI,IAAAkI,EAEAD,EAAA,GACAA,GAAAjI,EACAiI,EAAA,IAAAA,EAAA,IACGA,EAAAjI,IACHiI,EAAAjI,GAGAkI,EAAA,GACAA,GAAAlI,EACAkI,EAAA,IAAAA,EAAA,IACGA,EAAAlI,IACHkI,EAAAlI,GAGAkI,EAAAD,IAAAC,EAAAD,EAEA,IAAAyG,EACA,IAAAjX,EAAA4O,oBACAqI,EAAA5X,KAAAoP,SAAA+B,EAAAC,GACAwG,EAAA1I,UAAAvO,EAAApB,cACG,CACH,GAAAsY,GAAAzG,EAAAD,CACAyG,GAAA,GAAAjX,GAAAkX,EAAA/W,OACA,QAAAzB,GAAA,EAAmBA,EAAAwY,IAAcxY,EACjCuY,EAAAvY,GAAAW,KAAAX,EAAA8R,GAIA,MAAAyG,IAWAjX,EAAApB,UAAAuY,WAAA,SAAApF,EAAArD,EAAA8F,GACAzC,GAAA,EACArD,GAAA,EACA8F,GAAAT,EAAAhC,EAAArD,EAAArP,KAAAkD,OAKA,KAHA,GAAAiB,GAAAnE,KAAA0S,GACAqF,EAAA,EACA1Y,EAAA,IACAA,EAAAgQ,IAAA0I,GAAA,MACA5T,GAAAnE,KAAA0S,EAAArT,GAAA0Y,CAGA,OAAA5T,IAGAxD,EAAApB,UAAAyY,WAAA,SAAAtF,EAAArD,EAAA8F,GACAzC,GAAA,EACArD,GAAA,EACA8F,GACAT,EAAAhC,EAAArD,EAAArP,KAAAkD,OAKA,KAFA,GAAAiB,GAAAnE,KAAA0S,IAAArD,GACA0I,EAAA,EACA1I,EAAA,IAAA0I,GAAA,MACA5T,GAAAnE,KAAA0S,IAAArD,GAAA0I,CAGA,OAAA5T,IAGAxD,EAAApB,UAAA0Y,UAAA,SAAAvF,EAAAyC,GAEA,MADAA,IAAAT,EAAAhC,EAAA,EAAA1S,KAAAkD,QACAlD,KAAA0S,IAGA/R,EAAApB,UAAA2Y,aAAA,SAAAxF,EAAAyC,GAEA,MADAA,IAAAT,EAAAhC,EAAA,EAAA1S,KAAAkD,QACAlD,KAAA0S,GAAA1S,KAAA0S,EAAA,OAGA/R,EAAApB,UAAA4S,aAAA,SAAAO,EAAAyC,GAEA,MADAA,IAAAT,EAAAhC,EAAA,EAAA1S,KAAAkD,QACAlD,KAAA0S,IAAA,EAAA1S,KAAA0S,EAAA,IAGA/R,EAAApB,UAAA4Y,aAAA,SAAAzF,EAAAyC,GAGA,MAFAA,IAAAT,EAAAhC,EAAA,EAAA1S,KAAAkD,SAEAlD,KAAA0S,GACA1S,KAAA0S,EAAA,MACA1S,KAAA0S,EAAA,QACA,SAAA1S,KAAA0S,EAAA,IAGA/R,EAAApB,UAAA6Y,aAAA,SAAA1F,EAAAyC,GAGA,MAFAA,IAAAT,EAAAhC,EAAA,EAAA1S,KAAAkD,QAEA,SAAAlD,KAAA0S,IACA1S,KAAA0S,EAAA,OACA1S,KAAA0S,EAAA,MACA1S,KAAA0S,EAAA,KAGA/R,EAAApB,UAAA8Y,UAAA,SAAA3F,EAAArD,EAAA8F,GACAzC,GAAA,EACArD,GAAA,EACA8F,GAAAT,EAAAhC,EAAArD,EAAArP,KAAAkD,OAKA,KAHA,GAAAiB,GAAAnE,KAAA0S,GACAqF,EAAA,EACA1Y,EAAA,IACAA,EAAAgQ,IAAA0I,GAAA,MACA5T,GAAAnE,KAAA0S,EAAArT,GAAA0Y,CAMA,OAJAA,IAAA,IAEA5T,GAAA4T,IAAA5T,GAAAsP,KAAA6E,IAAA,IAAAjJ,IAEAlL,GAGAxD,EAAApB,UAAAgZ,UAAA,SAAA7F,EAAArD,EAAA8F,GACAzC,GAAA,EACArD,GAAA,EACA8F,GAAAT,EAAAhC,EAAArD,EAAArP,KAAAkD,OAKA,KAHA,GAAA7D,GAAAgQ,EACA0I,EAAA,EACA5T,EAAAnE,KAAA0S,IAAArT,GACAA,EAAA,IAAA0Y,GAAA,MACA5T,GAAAnE,KAAA0S,IAAArT,GAAA0Y,CAMA,OAJAA,IAAA,IAEA5T,GAAA4T,IAAA5T,GAAAsP,KAAA6E,IAAA,IAAAjJ,IAEAlL,GAGAxD,EAAApB,UAAAiZ,SAAA,SAAA9F,EAAAyC,GAEA,MADAA,IAAAT,EAAAhC,EAAA,EAAA1S,KAAAkD,QACA,IAAAlD,KAAA0S,IACA,IAAA1S,KAAA0S,GAAA,MADA1S,KAAA0S,IAIA/R,EAAApB,UAAAkZ,YAAA,SAAA/F,EAAAyC,GACAA,GAAAT,EAAAhC,EAAA,EAAA1S,KAAAkD,OACA,IAAAiB,GAAAnE,KAAA0S,GAAA1S,KAAA0S,EAAA,KACA,cAAAvO,EAAA,WAAAA,KAGAxD,EAAApB,UAAAmZ,YAAA,SAAAhG,EAAAyC,GACAA,GAAAT,EAAAhC,EAAA,EAAA1S,KAAAkD,OACA,IAAAiB,GAAAnE,KAAA0S,EAAA,GAAA1S,KAAA0S,IAAA,CACA,cAAAvO,EAAA,WAAAA,KAGAxD,EAAApB,UAAAoZ,YAAA,SAAAjG,EAAAyC,GAGA,MAFAA,IAAAT,EAAAhC,EAAA,EAAA1S,KAAAkD,QAEAlD,KAAA0S,GACA1S,KAAA0S,EAAA,MACA1S,KAAA0S,EAAA,OACA1S,KAAA0S,EAAA,QAGA/R,EAAApB,UAAAqZ,YAAA,SAAAlG,EAAAyC,GAGA,MAFAA,IAAAT,EAAAhC,EAAA,EAAA1S,KAAAkD,QAEAlD,KAAA0S,IAAA,GACA1S,KAAA0S,EAAA,OACA1S,KAAA0S,EAAA,MACA1S,KAAA0S,EAAA,IAGA/R,EAAApB,UAAAsZ,YAAA,SAAAnG,EAAAyC,GAEA,MADAA,IAAAT,EAAAhC,EAAA,EAAA1S,KAAAkD,QACAkS,EAAApD,KAAAhS,KAAA0S,GAAA,SAGA/R,EAAApB,UAAAuZ,YAAA,SAAApG,EAAAyC,GAEA,MADAA,IAAAT,EAAAhC,EAAA,EAAA1S,KAAAkD,QACAkS,EAAApD,KAAAhS,KAAA0S,GAAA,SAGA/R,EAAApB,UAAAwZ,aAAA,SAAArG,EAAAyC,GAEA,MADAA,IAAAT,EAAAhC,EAAA,EAAA1S,KAAAkD,QACAkS,EAAApD,KAAAhS,KAAA0S,GAAA,SAGA/R,EAAApB,UAAAyZ,aAAA,SAAAtG,EAAAyC,GAEA,MADAA,IAAAT,EAAAhC,EAAA,EAAA1S,KAAAkD,QACAkS,EAAApD,KAAAhS,KAAA0S,GAAA,SASA/R,EAAApB,UAAA0Z,YAAA,SAAApY,EAAA6R,EAAArD,EAAA8F,GAIA,GAHAtU,KACA6R,GAAA,EACArD,GAAA,GACA8F,EAAA,CACA,GAAA+D,GAAAzF,KAAA6E,IAAA,IAAAjJ,GAAA,CACAuF,GAAA5U,KAAAa,EAAA6R,EAAArD,EAAA6J,EAAA,GAGA,GAAAnB,GAAA,EACA1Y,EAAA,CAEA,KADAW,KAAA0S,GAAA,IAAA7R,IACAxB,EAAAgQ,IAAA0I,GAAA,MACA/X,KAAA0S,EAAArT,GAAAwB,EAAAkX,EAAA,GAGA,OAAArF,GAAArD,GAGA1O,EAAApB,UAAA4Z,YAAA,SAAAtY,EAAA6R,EAAArD,EAAA8F,GAIA,GAHAtU,KACA6R,GAAA,EACArD,GAAA,GACA8F,EAAA,CACA,GAAA+D,GAAAzF,KAAA6E,IAAA,IAAAjJ,GAAA,CACAuF,GAAA5U,KAAAa,EAAA6R,EAAArD,EAAA6J,EAAA,GAGA,GAAA7Z,GAAAgQ,EAAA,EACA0I,EAAA,CAEA,KADA/X,KAAA0S,EAAArT,GAAA,IAAAwB,IACAxB,GAAA,IAAA0Y,GAAA,MACA/X,KAAA0S,EAAArT,GAAAwB,EAAAkX,EAAA,GAGA,OAAArF,GAAArD,GAGA1O,EAAApB,UAAA6Z,WAAA,SAAAvY,EAAA6R,EAAAyC,GAMA,MALAtU,MACA6R,GAAA,EACAyC,GAAAP,EAAA5U,KAAAa,EAAA6R,EAAA,SACA/R,EAAA4O,sBAAA1O,EAAA4S,KAAA4F,MAAAxY,IACAb,KAAA0S,GAAA,IAAA7R,EACA6R,EAAA,GAWA/R,EAAApB,UAAA+Z,cAAA,SAAAzY,EAAA6R,EAAAyC,GAUA,MATAtU,MACA6R,GAAA,EACAyC,GAAAP,EAAA5U,KAAAa,EAAA6R,EAAA,WACA/R,EAAA4O,qBACAvP,KAAA0S,GAAA,IAAA7R,EACAb,KAAA0S,EAAA,GAAA7R,IAAA,GAEAiU,EAAA9U,KAAAa,EAAA6R,GAAA,GAEAA,EAAA,GAGA/R,EAAApB,UAAAga,cAAA,SAAA1Y,EAAA6R,EAAAyC,GAUA,MATAtU,MACA6R,GAAA,EACAyC,GAAAP,EAAA5U,KAAAa,EAAA6R,EAAA,WACA/R,EAAA4O,qBACAvP,KAAA0S,GAAA7R,IAAA,EACAb,KAAA0S,EAAA,OAAA7R,GAEAiU,EAAA9U,KAAAa,EAAA6R,GAAA,GAEAA,EAAA,GAUA/R,EAAApB,UAAAia,cAAA,SAAA3Y,EAAA6R,EAAAyC,GAYA,MAXAtU,MACA6R,GAAA,EACAyC,GAAAP,EAAA5U,KAAAa,EAAA6R,EAAA,gBACA/R,EAAA4O,qBACAvP,KAAA0S,EAAA,GAAA7R,IAAA,GACAb,KAAA0S,EAAA,GAAA7R,IAAA,GACAb,KAAA0S,EAAA,GAAA7R,IAAA,EACAb,KAAA0S,GAAA,IAAA7R,GAEAmU,EAAAhV,KAAAa,EAAA6R,GAAA,GAEAA,EAAA,GAGA/R,EAAApB,UAAAka,cAAA,SAAA5Y,EAAA6R,EAAAyC,GAYA,MAXAtU,MACA6R,GAAA,EACAyC,GAAAP,EAAA5U,KAAAa,EAAA6R,EAAA,gBACA/R,EAAA4O,qBACAvP,KAAA0S,GAAA7R,IAAA,GACAb,KAAA0S,EAAA,GAAA7R,IAAA,GACAb,KAAA0S,EAAA,GAAA7R,IAAA,EACAb,KAAA0S,EAAA,OAAA7R,GAEAmU,EAAAhV,KAAAa,EAAA6R,GAAA,GAEAA,EAAA,GAGA/R,EAAApB,UAAAma,WAAA,SAAA7Y,EAAA6R,EAAArD,EAAA8F,GAGA,GAFAtU,KACA6R,GAAA,GACAyC,EAAA,CACA,GAAAwE,GAAAlG,KAAA6E,IAAA,IAAAjJ,EAAA,EAEAuF,GAAA5U,KAAAa,EAAA6R,EAAArD,EAAAsK,EAAA,GAAAA,GAGA,GAAAta,GAAA,EACA0Y,EAAA,EACA6B,EAAA,CAEA,KADA5Z,KAAA0S,GAAA,IAAA7R,IACAxB,EAAAgQ,IAAA0I,GAAA,MACAlX,EAAA,OAAA+Y,GAAA,IAAA5Z,KAAA0S,EAAArT,EAAA,KACAua,EAAA,GAEA5Z,KAAA0S,EAAArT,IAAAwB,EAAAkX,GAAA,GAAA6B,EAAA,GAGA,OAAAlH,GAAArD,GAGA1O,EAAApB,UAAAsa,WAAA,SAAAhZ,EAAA6R,EAAArD,EAAA8F,GAGA,GAFAtU,KACA6R,GAAA,GACAyC,EAAA,CACA,GAAAwE,GAAAlG,KAAA6E,IAAA,IAAAjJ,EAAA,EAEAuF,GAAA5U,KAAAa,EAAA6R,EAAArD,EAAAsK,EAAA,GAAAA,GAGA,GAAAta,GAAAgQ,EAAA,EACA0I,EAAA,EACA6B,EAAA,CAEA,KADA5Z,KAAA0S,EAAArT,GAAA,IAAAwB,IACAxB,GAAA,IAAA0Y,GAAA,MACAlX,EAAA,OAAA+Y,GAAA,IAAA5Z,KAAA0S,EAAArT,EAAA,KACAua,EAAA,GAEA5Z,KAAA0S,EAAArT,IAAAwB,EAAAkX,GAAA,GAAA6B,EAAA,GAGA,OAAAlH,GAAArD,GAGA1O,EAAApB,UAAAua,UAAA,SAAAjZ,EAAA6R,EAAAyC,GAOA,MANAtU,MACA6R,GAAA,EACAyC,GAAAP,EAAA5U,KAAAa,EAAA6R,EAAA,YACA/R,EAAA4O,sBAAA1O,EAAA4S,KAAA4F,MAAAxY,IACAA,EAAA,IAAAA,EAAA,IAAAA,EAAA,GACAb,KAAA0S,GAAA,IAAA7R,EACA6R,EAAA,GAGA/R,EAAApB,UAAAwa,aAAA,SAAAlZ,EAAA6R,EAAAyC,GAUA,MATAtU,MACA6R,GAAA,EACAyC,GAAAP,EAAA5U,KAAAa,EAAA6R,EAAA,gBACA/R,EAAA4O,qBACAvP,KAAA0S,GAAA,IAAA7R,EACAb,KAAA0S,EAAA,GAAA7R,IAAA,GAEAiU,EAAA9U,KAAAa,EAAA6R,GAAA,GAEAA,EAAA,GAGA/R,EAAApB,UAAAya,aAAA,SAAAnZ,EAAA6R,EAAAyC,GAUA,MATAtU,MACA6R,GAAA,EACAyC,GAAAP,EAAA5U,KAAAa,EAAA6R,EAAA,gBACA/R,EAAA4O,qBACAvP,KAAA0S,GAAA7R,IAAA,EACAb,KAAA0S,EAAA,OAAA7R,GAEAiU,EAAA9U,KAAAa,EAAA6R,GAAA,GAEAA,EAAA,GAGA/R,EAAApB,UAAA0a,aAAA,SAAApZ,EAAA6R,EAAAyC,GAYA,MAXAtU,MACA6R,GAAA,EACAyC,GAAAP,EAAA5U,KAAAa,EAAA6R,EAAA,0BACA/R,EAAA4O,qBACAvP,KAAA0S,GAAA,IAAA7R,EACAb,KAAA0S,EAAA,GAAA7R,IAAA,EACAb,KAAA0S,EAAA,GAAA7R,IAAA,GACAb,KAAA0S,EAAA,GAAA7R,IAAA,IAEAmU,EAAAhV,KAAAa,EAAA6R,GAAA,GAEAA,EAAA,GAGA/R,EAAApB,UAAA2a,aAAA,SAAArZ,EAAA6R,EAAAyC,GAaA,MAZAtU,MACA6R,GAAA,EACAyC,GAAAP,EAAA5U,KAAAa,EAAA6R,EAAA,0BACA7R,EAAA,IAAAA,EAAA,WAAAA,EAAA,GACAF,EAAA4O,qBACAvP,KAAA0S,GAAA7R,IAAA,GACAb,KAAA0S,EAAA,GAAA7R,IAAA,GACAb,KAAA0S,EAAA,GAAA7R,IAAA,EACAb,KAAA0S,EAAA,OAAA7R,GAEAmU,EAAAhV,KAAAa,EAAA6R,GAAA,GAEAA,EAAA,GAgBA/R,EAAApB,UAAA4a,aAAA,SAAAtZ,EAAA6R,EAAAyC,GACA,MAAAD,GAAAlV,KAAAa,EAAA6R,GAAA,EAAAyC,IAGAxU,EAAApB,UAAA6a,aAAA,SAAAvZ,EAAA6R,EAAAyC,GACA,MAAAD,GAAAlV,KAAAa,EAAA6R,GAAA,EAAAyC,IAWAxU,EAAApB,UAAA8a,cAAA,SAAAxZ,EAAA6R,EAAAyC,GACA,MAAAE,GAAArV,KAAAa,EAAA6R,GAAA,EAAAyC,IAGAxU,EAAApB,UAAA+a,cAAA,SAAAzZ,EAAA6R,EAAAyC,GACA,MAAAE,GAAArV,KAAAa,EAAA6R,GAAA,EAAAyC,IAIAxU,EAAApB,UAAAkR,KAAA,SAAA1P,EAAAwZ,EAAApJ,EAAAC,GAQA,GAPAD,MAAA,GACAC,GAAA,IAAAA,MAAApR,KAAAkD,QACAqX,GAAAxZ,EAAAmC,SAAAqX,EAAAxZ,EAAAmC,QACAqX,MAAA,GACAnJ,EAAA,GAAAA,EAAAD,IAAAC,EAAAD,GAGAC,IAAAD,EAAA,QACA,QAAApQ,EAAAmC,QAAA,IAAAlD,KAAAkD,OAAA,QAGA,IAAAqX,EAAA,EACA,SAAA7K,YAAA,4BAEA,IAAAyB,EAAA,GAAAA,GAAAnR,KAAAkD,OAAA,SAAAwM,YAAA,4BACA,IAAA0B,EAAA,WAAA1B,YAAA,0BAGA0B,GAAApR,KAAAkD,SAAAkO,EAAApR,KAAAkD,QACAnC,EAAAmC,OAAAqX,EAAAnJ,EAAAD,IACAC,EAAArQ,EAAAmC,OAAAqX,EAAApJ,EAGA,IACA9R,GADA6J,EAAAkI,EAAAD,CAGA,IAAAnR,OAAAe,GAAAoQ,EAAAoJ,KAAAnJ,EAEA,IAAA/R,EAAA6J,EAAA,EAAqB7J,GAAA,IAAQA,EAC7B0B,EAAA1B,EAAAkb,GAAAva,KAAAX,EAAA8R,OAEG,IAAAjI,EAAA,MAAAvI,EAAA4O,oBAEH,IAAAlQ,EAAA,EAAeA,EAAA6J,IAAS7J,EACxB0B,EAAA1B,EAAAkb,GAAAva,KAAAX,EAAA8R,OAGAlC,YAAA1P,UAAAyH,IAAA/H,KACA8B,EACAf,KAAAoP,SAAA+B,IAAAjI,GACAqR,EAIA,OAAArR,IAOAvI,EAAApB,UAAAgD,KAAA,SAAA4B,EAAAgN,EAAAC,EAAAlB,GAEA,mBAAA/L,GAAA,CASA,GARA,gBAAAgN,IACAjB,EAAAiB,EACAA,EAAA,EACAC,EAAApR,KAAAkD,QACK,gBAAAkO,KACLlB,EAAAkB,EACAA,EAAApR,KAAAkD,QAEA,IAAAiB,EAAAjB,OAAA,CACA,GAAA0K,GAAAzJ,EAAA0R,WAAA,EACAjI,GAAA,MACAzJ,EAAAyJ,GAGA,GAAA9M,SAAAoP,GAAA,gBAAAA,GACA,SAAAlP,WAAA,4BAEA,oBAAAkP,KAAAvP,EAAAyP,WAAAF,GACA,SAAAlP,WAAA,qBAAAkP,OAEG,gBAAA/L,KACHA,GAAA;AAIA,GAAAgN,EAAA,GAAAnR,KAAAkD,OAAAiO,GAAAnR,KAAAkD,OAAAkO,EACA,SAAA1B,YAAA,qBAGA,IAAA0B,GAAAD,EACA,MAAAnR,KAGAmR,MAAA,EACAC,EAAAtQ,SAAAsQ,EAAApR,KAAAkD,OAAAkO,IAAA,EAEAjN,MAAA,EAEA,IAAA9E,EACA,oBAAA8E,GACA,IAAA9E,EAAA8R,EAAmB9R,EAAA+R,IAAS/R,EAC5BW,KAAAX,GAAA8E,MAEG,CACH,GAAAsQ,GAAA9T,EAAAiL,SAAAzH,GACAA,EACA4M,EAAA,GAAApQ,GAAAwD,EAAA+L,GAAA7K,YACA6D,EAAAuL,EAAAvR,MACA,KAAA7D,EAAA,EAAeA,EAAA+R,EAAAD,IAAiB9R,EAChCW,KAAAX,EAAA8R,GAAAsD,EAAApV,EAAA6J,GAIA,MAAAlJ,MAMA,IAAAwV,IAAA,uBPo0C8BvW,KAAKJ,EAASH,EAAoB,GAAGiC,OAAS,WAAa,MAAOX,WAI1F,SAASlB,EAAQD,EAASH,IQr7FhC,SAAA8b,EAAAC,GAiBA,QAAAC,GAAA3b,EAAA4b,GACA3a,KAAA4a,IAAA7b,EACAiB,KAAA6a,SAAAF,EAnBA,GAAAG,GAAApc,EAAA,IAAAoc,SACA/a,EAAAgb,SAAAxb,UAAAQ,MACAJ,EAAAuB,MAAA3B,UAAAI,MACAqb,KACAC,EAAA,CAIApc,GAAAqc,WAAA,WACA,UAAAR,GAAA3a,EAAAd,KAAAic,WAAAC,OAAAha,WAAAia,eAEAvc,EAAAwc,YAAA,WACA,UAAAX,GAAA3a,EAAAd,KAAAoc,YAAAF,OAAAha,WAAAma,gBAEAzc,EAAAuc,aACAvc,EAAAyc,cAAA,SAAAC,GAA2CA,EAAAC,SAM3Cd,EAAAnb,UAAAkc,MAAAf,EAAAnb,UAAAmc,IAAA,aACAhB,EAAAnb,UAAAic,MAAA,WACAxb,KAAA6a,SAAA5b,KAAAkc,OAAAnb,KAAA4a,MAIA/b,EAAA8c,OAAA,SAAAC,EAAAC,GACAT,aAAAQ,EAAAE,gBACAF,EAAAG,aAAAF,GAGAhd,EAAAmd,SAAA,SAAAJ,GACAR,aAAAQ,EAAAE,gBACAF,EAAAG,cAAA,GAGAld,EAAAod,aAAApd,EAAAqd,OAAA,SAAAN,GACAR,aAAAQ,EAAAE,eAEA,IAAAD,GAAAD,EAAAG,YACAF,IAAA,IACAD,EAAAE,eAAAZ,WAAA,WACAU,EAAAO,YACAP,EAAAO,cACKN,KAKLhd,EAAA2b,aAAA,kBAAAA,KAAA,SAAA5a,GACA,GAAAb,GAAAkc,IACAvb,IAAAyB,UAAA+B,OAAA,IAAAvD,EAAAV,KAAAkC,UAAA,EAkBA,OAhBA6Z,GAAAjc,IAAA,EAEA+b,EAAA,WACAE,EAAAjc,KAGAW,EACAE,EAAAG,MAAA,KAAAL,GAEAE,EAAAX,KAAA,MAGAJ,EAAA4b,eAAA1b,MAIAA,GAGAF,EAAA4b,eAAA,kBAAAA,KAAA,SAAA1b,SACAic,GAAAjc,MRy7F8BE,KAAKJ,EAASH,EAAoB,GAAG8b,aAAc9b,EAAoB,GAAG+b,iBAIlG,SAAS3b,EAAQD,EAASH,GSvgGhC,YAwBA,SAAA4B,GAAA8b,EAAAC,EAAAC,GAUA,GATAC,EAAAtQ,aAAAhN,KAAAe,MAEAA,KAAAoc,YACApc,KAAAqc,SACArc,KAAAsc,SAEAtc,KAAAjB,GAAAyd,IACAxc,KAAAyc,cAAA,EAEAJ,IAAAC,EACAtc,KAAA0c,gBAAA,MACG,KAAAJ,GAAAD,EAGH,SAAA5V,OAAA,sCAFAzG,MAAA0c,eAAA,EAKA1c,KAAA2c,cAAAP,EAAAQ,mBAEA5c,KAAA6c,cAEA7c,KAAA8c,eAAA,EACA9c,KAAA+c,eAAA,EACA/c,KAAAgd,UAAA,KAEAhd,KAAAid,YAAA,KACAjd,KAAAkd,iBAEAd,EAAAta,GAAA,OAAA9B,KAAAmd,cAAAC,KAAApd,OACAoc,EAAAta,GAAA,QAAA9B,KAAAqd,eAAAD,KAAApd,OACAoc,EAAAta,GAAA,QAAA9B,KAAAsd,eAAAF,KAAApd,OArDA,GAAAuc,GAAA7d,EAAA,GACA6e,EAAA7e,EAAA,GACAuP,EAAAvP,EAAA,GAEA8e,EAAA9e,EAAA,GACAwB,EAAAxB,EAAA,GACAwP,EAAAxP,EAAA,GACA2B,EAAA3B,EAAA,EAEAI,GAAAD,QAAAyB,CAEA,IAAAkc,GAAA,CA6CAvO,GAAAnC,SAAAxL,EAAAic,EAAAtQ,cASA3L,EAAAf,UAAAke,WACA,SAAAC,EAAAC,EAAAje,EAAAke,GACA,GAAAC,GAAA7d,KAAA8d,aAAA,OAAAJ,EAAAC,EAAAje,EAEA,IAAAke,EAAA,CACA,GAAAG,GAAAF,EAAA5e,KAAA,EACAe,MAAA6c,WAAAkB,GAAAH,EAGA5d,KAAAge,MAAAH,IAQAvd,EAAAf,UAAAqe,SAAA,SAAAG,EAAAjU,EAAAmU,GACA,GAAAJ,EAEA/T,IACAA,EAAAoE,EAAAP,YAAAmB,gBAAAhF,GACA+T,EAAA7d,KAAA8d,aAAA,wBAAAhU,IAEA+T,EAAA7d,KAAA8d,aAAA,qBAAAG,GAGAJ,EAAAD,SAAA,GAAAG,EAEA/d,KAAAge,MAAAH,IAQAvd,EAAAf,UAAA2e,gBACA,SAAAR,EAAA9b,EAAAlC,GACA,GAAAme,GAAA7d,KAAA8d,aAAA,QAAAJ,EAAA9b,EAAAlC,EACAM,MAAAge,MAAAH,IASAvd,EAAAf,UAAA4e,kBAAA,SAAAC,EAAAC,EAAAxd,GACA,GAAAgd,GAAA7d,KAAA8d,aAAA,QAAAM,EAAAC,EAAAxd,EACAb,MAAAge,MAAAH,IASAvd,EAAAf,UAAA+e,UAAA,SAAAC,EAAAC,EAAAC,EAAAb,GACA,GAAAC,GAAA7d,KAAA8d,aAAA,YAAAS,EAAAC,EAAAC,EAEA,IAAAb,EAAA,CACA,GAAAG,GAAAF,EAAAS,UAAA,GACAI,EAAA1e,IAEAA,MAAA6c,WAAAkB,GAAA,SAAAjU,EAAAkT,GACAwB,GAAAC,IAAA3U,IACA4U,EAAA3B,eAAA,GAGAa,EAAA9T,EAAAkT,IAIAhd,KAAAge,MAAAH,IAQAvd,EAAAf,UAAAof,iBAAA,SAAAjB,EAAAE,GACA,GAAAC,GAAA7d,KAAA8d,aAAA,UAAAJ,EAAA,WACAK,EAAAF,EAAAlb,QAAA,GACA+b,EAAA1e,IAEAA,MAAA6c,WAAAkB,GAAA,SAAAjU,GACA,GAAAA,EACA,MAAA8T,GAAA9T,EAGA,IAAA8U,GAAA1d,MAAA3B,UAAAI,MAAAV,KAAAkC,UAAA,GACA0d,EAAA,GAAAxe,GAAAL,KAAA0d,EAAAkB,EAEAF,GAAAxB,cAAAQ,GAAAmB,EAEAjB,GACAA,EAAA,KAAAiB,IAIA7e,KAAAge,MAAAH,IASAvd,EAAAf,UAAAue,aAAA,SAAAgB,EAAA/d,EAAAsd,EAAA3e,GACA,GAAAme,KAYA,OAVAA,GAAAiB,GAAA/d,GACAf,KAAAyc,cAAA1b,IACAf,KAAAyc,eAEA4B,IACAR,EAAAQ,GAAA3e,GAGAM,KAAAyc,eAAAzc,KAAA0c,eAEAmB,GAKAvd,EAAAf,UAAAic,MAAA,WACAxb,KAAAoc,UAAAhL,OAOA9Q,EAAAf,UAAA2b,WAAA,SAAA6D,EAAAnB,GACAL,EAAA5B,OAAA3b,KAAA+e,GACAxB,EAAAtB,aAAAjc,MAEAA,KAAAgN,KAAA,WAAA4Q,IAKAtd,EAAAf,UAAA4c,WAAA,WACAnc,KAAAgC,KAAA,aAMA1B,EAAAf,UAAAye,MAAA,SAAAH,GACA,GAAAlN,GAAA6M,EAAAlX,UAAAuX,EACA7d,MAAAoc,UAAA4C,KAAArO,IAMArQ,EAAAf,UAAA0f,KAAA,SAAApB,GACA,GAAAA,EAAA,CACA,GAAAlN,GAAA6M,EAAAlX,UAAAuX,EACA7d,MAAAoc,UAAAhL,IAAAT,OAEA3Q,MAAAoc,UAAAhL,OAOA9Q,EAAAf,UAAA4d,cAAA,SAAAxM,GACA3Q,KAAAgC,KAAA,OAAA2O,EAEA,IAAAuO,GAAA1B,EAAA2B,MAAAxO,EACA3Q,MAAAof,gBAAAF,IAKA5e,EAAAf,UAAA8d,eAAA,WACArd,KAAAgC,KAAA,QAAAhC,MAEAA,KAAAqc,QACArc,KAAAqc,OAAAra,KAAA,aAAAhC,OAOAM,EAAAf,UAAA+d,eAAA,SAAAxT,GACA9J,KAAAgC,KAAA,QAAA8H,EAAA9J,OAMAM,EAAAf,UAAA6f,gBAAA,SAAAF,GACA,OAAAG,GAAA,EAAqBA,EAAAH,EAAAhc,OAAwBmc,IAAA,CAC7C,GAAAxB,GAAAqB,EAAAG,EACArf,MAAAgC,KAAA,SAAA6b,EAAA7d,KAEA,IAAA4E,GAAAtF,OAAAsF,KAAAiZ,GACAiB,EAAAla,EAAA,EAEA,KAAA5E,KAAA8c,eAAA,cAAAgC,EAEA,WADA9e,MAAAsf,cAAAzB,GAAA,EAIA,IAAApR,GAAAnM,EAAAif,qBAAAT,EACArS,GACAzM,KAAAyM,GAAAoR,EAAAjZ,GAEA5E,KAAAsf,cAAAzB,KASAvd,EAAAf,UAAA+f,cAAA,SAAAzB,EAAA2B,GACAxf,KAAAgC,KAAA,iBAAA6b,EAAA7d,MAEAwf,GACAxf,KAAAif,QAQA3e,EAAAf,UAAAkgB,wBAAA,SAAA5B,EAAAjZ,GACA,MAAA5E,MAAA8c,kBACA9c,MAAAgC,KAAA,oBAAA6b,EAAA7d,WAIA6d,EAAAS,UAAA,GACAte,KAAA0f,yBAAA7B,EAAAjZ,GAEA5E,KAAA2f,0BAAA9B,EAAAjZ,KAQAtE,EAAAf,UAAAmgB,yBAAA,SAAA7B,EAAAjZ,GACA,IAAA5E,KAAAqc,OAEA,WADArc,MAAA4f,gBAAA1R,EAAAM,iBAIA,IAAAqR,GAAAhC,EAAAS,UAAA,GACArB,EAAAjd,KAAAqc,OAAAyD,eAAAD,EAEA,KAAA5C,EAEA,WADAjd,MAAA4f,gBAAA1R,EAAAC,kBAIAnO,MAAAid,aAEA,IAAA8C,GAAAnb,EAAA,GACA6Z,EAAAZ,EAAAkC,EAEA/f,MAAAggB,iBAAA,mBAAAnC,IAAAS,UAAA,IACA2B,WAAA,YACAC,kBAAA,EACAH,WACAtB,aAGAsB,EACA/f,KAAAqc,OAAA8D,0BAAAngB,KAAAid,EACA8C,EAAAtB,EAAAze,KAAAogB,+BAAAhD,KAAApd,OAEAA,KAAAqc,OAAAgE,sBAAArgB,KAAAid,EACAjd,KAAAsgB,kBAAAlD,KAAApd,QAaAM,EAAAf,UAAA+gB,kBAAA,SAAAxW,EAAAkT,GACA,GAAAlT,EAEA,WADA9J,MAAA4f,gBAAA1R,EAAAE,gBAIApO,MAAA8c,eAAA,EAEA9c,KAAAgC,KAAA,SAAAgb,EAAAhd,MACAA,KAAAqc,OAAAra,KAAA,UAAAhC,KAEA,IAAA6d,GAAA7d,KAAA8d,aAAA,sBAAAd,EACAhd,MAAAge,MAAAH,IAOAvd,EAAAf,UAAA6gB,+BACA,SAAAtW,EAAAkT,GACAlT,IACA9J,KAAA+c,eAAA,GAGA/c,KAAAsgB,kBAAAxW,EAAAkT,IAMA1c,EAAAf,UAAAogB,0BAAA,SAAA9B,GACA,GAAAE,GAAAF,EAAAS,UAAA,GACAV,EAAA5d,KAAA6c,WAAAkB,EAEAH,IACA5d,KAAAsf,cAAAzB,GAGAA,EAAA0C,UACAvgB,MAAA6c,WAAAkB,GAEA/d,KAAA8c,eAAA,EACA9c,KAAAid,YAAAjd,KAAAsc,OAAAwD,iBACA9f,KAAAggB,iBAAA,YAAAnC,EAAAE,GACAf,UAAAa,EAAA0C,KAGA3C,EAAA,KAAAC,EAAA0C,KACG1C,EAAA/T,aACH9J,MAAA6c,WAAAkB,GACAH,EAAA1P,EAAAP,YAAAkB,cAAAgP,EAAA/T,SAEA9J,KAAAsf,cAAAzB,GAAA,IAOAvd,EAAAf,UAAAqgB,gBAAA,SAAA9V,GACA,GAAA0W,GAAAtS,EAAAP,YAAAmB,gBAAAhF,GACA+T,EAAA7d,KAAA8d,aAAA,yBAAA0C,EAEAxgB,MAAAif,KAAApB,IAOAvd,EAAAf,UAAAkhB,mBAAA,SAAA5C,EAAAjZ,GACA,GAAAmZ,GAAAF,EAAA5e,KAAA,GACAye,EAAAG,EAAA5e,KAAA,GACA0e,EAAA/Y,EAAA,GACAlF,EAAAme,EAAAF,EAEA3d,MAAAggB,iBAAA,OAAAnC,EAAAE,GACAL,gBACAC,cAGA,IAAAC,GAAA5d,KAAA0gB,uBAAAtD,KAAApd,KAAA+d,EACAre,GAAAmG,KAAA+X,EAEA,KACA5d,KAAAid,YAAAQ,WAAAzd,KAAA0d,EAAAC,EAAAje,GACG,MAAAoK,GACH,KAAAA,YAAAoE,GAAAP,aAIA,KADAiQ,GAAA1P,EAAAO,wBACA3E,CAHA8T,GAAA9T,KAWAxJ,EAAAf,UAAAohB,uBAAA,SAAA9C,GACA,GAAAE,GAAAF,EAAAD,SAAA,GACAA,EAAA5d,KAAA6c,WAAAkB,EAEAH,WACA5d,MAAA6c,WAAAkB,GAEAF,EAAA0C,GACA3C,EAAA7d,MAAAC,MAAA,MAAAC,OAAA4d,EAAA0C,KACK1C,EAAA/T,MACL8T,EAAA1P,EAAAP,YAAAkB,cAAAgP,EAAA/T,QAEA9J,KAAAsf,cAAAzB,GAIA,IAAA9b,GAAA6b,EACA,MACKgD,qBAAA,EAEL5gB,MAAAggB,iBAAA,WAAAnC,EAAAE,EAAAhc,GAEA6b,GACA5d,KAAAgC,KAAA,2BAAA+b,EAAAF,EAAA7d,OAQAM,EAAAf,UAAAshB,oBAAA,SAAAhD,EAAAjZ,GACA,GAAA8Y,GAAAG,EAAA1b,MAAA,GACAP,EAAAgD,EAAA,GACA7C,EAAA8b,EAAAjc,EAEA5B,MAAAggB,iBAAA,QAAAnC,IAAA1b,MAAA,IACAub,gBACAoD,gBAAAlf,EACAmf,gBAAAhf,GAGA,IAAAif,GAAAhhB,KAAAkd,cAAAQ,EACAsD,IACAA,EAAAhf,KAAAJ,EAAAG,GAAA,IAOAzB,EAAAf,UAAA0hB,sBAAA,SAAApD,GACA,GAAAE,GAAAF,EAAAlb,QAAA,GACA+a,EAAAG,EAAAlb,QAAA,EAEA3C,MAAAggB,iBAAA,UAAAnC,EAAAE,GACAL,iBAGA,IAAAkB,GAAA5e,KAAAid,YAAAiE,WAAAxD,EACAkB,GACA5e,KAAA4d,SAAAG,EAAA,KAAAa,GAEA5e,KAAA4d,SAAAG,EAAA7P,EAAAG,0BAOA/N,EAAAf,UAAA4hB,oBAAA,SAAAtD,EAAAjZ,GACA,GAAAwZ,GAAAP,EAAAuD,MAAA,GACA/C,EAAAzZ,EAAA,GACA/D,EAAAgd,EAAAQ,EAEAre,MAAAggB,iBAAA,QAAAnC,IAAAuD,MAAA,IACAhD,OACAC,OACAxd,WAUAP,EAAAf,UAAAmhB,uBAAA,SAAA3C,EAAAjU,GACA,GAAAmU,GAAA/c,MAAA3B,UAAAI,MAAAV,KAAAkC,UAAA,EACAnB,MAAA4d,SAAAG,EAAAjU,EAAAmU,IAYA3d,EAAAf,UAAAygB,iBAAA,SAAAlB,EAAAjB,EAAAE,EAAAre,GACA,GAAAqC,IACAsf,WAAArhB,KACAigB,WAAAnB,EACAjB,SACAE,WACAd,YAAAjd,KAAAid,YAGAvd,IACAQ,EAAAE,OAAA2B,EAAArC,GAGAM,KAAAgC,KAAA8c,EAAA/c,IAKAzB,EAAAif,sBACAjB,UAAA,0BACArf,KAAA,qBACA2e,SAAA,yBACAzb,MAAA,sBACAQ,QAAA,wBACAye,MAAA,wBT+gGM,SAAStiB,EAAQD,EAASH,GUhmHhC,YAwBA,SAAA4iB,GAAA7V,GACAzL,KAAAyL,SACAzL,KAAAuhB,eAAA,EAxBA,GAAAC,GAAA9iB,EAAA,IAEA8e,IACA1e,GAAAD,QAAA2e,EAKAA,EAAAlX,UAAAkb,EAAAC,mBAMAjE,EAAA2B,MAAA,SAAA1T,GACA,GAAAiW,GAAA,GAAAJ,GAAA7V,EACA,OAAAiW,GAAAvC,SAaAmC,EAAA/hB,UAAA4f,MAAA,WACA,GAAAte,GAAAb,KAAA2hB,YAOA,OALA3hB,MAAA4hB,cACA5hB,KAAAuhB,eAAAvhB,KAAAyL,OAAAvI,QACAlD,KAAA6hB,kBAGAhhB,GAKAygB,EAAA/hB,UAAAuiB,UAAA,WACA,MAAA9hB,MAAAyL,OAAAzL,KAAAuhB,iBAMAD,EAAA/hB,UAAAwiB,QAAA,WACA,GAAAC,GAAAhiB,KAAAyL,OAAAzL,KAAAuhB,iBACA,IAAAvhB,KAAAuhB,eAAAvhB,KAAAyL,OAAAvI,OACA,SAAA+e,aAAA,yBAEA,OAAAD,IAKAV,EAAA/hB,UAAA2iB,QAAA,WAEA,GADAliB,KAAAuhB,iBACAvhB,KAAAuhB,eAAA,EACA,SAAAU,aAAA,gBAQAX,EAAA/hB,UAAAqH,MAAA,SAAAub,GACAniB,KAAA+hB,YAAAI,GACAniB,KAAAoiB,cAAAD,IAOAb,EAAA/hB,UAAA8iB,WAAA,SAAAxU,GACA,SAAAoU,aAAApU,EAAA,gBAAA7N,KAAAuhB,iBAMAD,EAAA/hB,UAAA6iB,cAAA,SAAAD,GACAniB,KAAAqiB,WAAAF,EAAA,cAMAb,EAAA/hB,UAAAsiB,gBAAA,SAAAM,GACAA,KAAAniB,KAAA8hB,YACAhhB,SAAAqhB,IACAA,EAAA,eAGAniB,KAAAqiB,WAAA,cAAAF,IAMAb,EAAA/hB,UAAA+iB,aAAA,SAAAN,GACA,oBAAAhd,QAAAgd,MAAA,GAMAV,EAAA/hB,UAAAgjB,UAAA,SAAAP,GACA,aAAAA,GAAA,OAAAA,GAMAV,EAAA/hB,UAAAijB,SAAA,SAAAR,GACA,MAAAA,IAAA,KAAAA,GAAA,KAMAV,EAAA/hB,UAAAkjB,eAAA,SAAAT,GACA,MAAAhiB,MAAA0iB,eAAAV,IACA,MAAAA,GAAA,MAAAA,GACA,MAAAA,GAMAV,EAAA/hB,UAAAojB,QAAA,SAAAX,GACA,MAAAhiB,MAAAyiB,eAAAT,IACA,MAAAA,GAAA,MAAAA,GAMAV,EAAA/hB,UAAAqjB,cAAA,SAAAZ,GACA,YAAAA,GAAA,MAAAA,GAMAV,EAAA/hB,UAAAsjB,aAAA,SAAAb,GACA,MAAAA,IAAA,KAAAA,GAAA,KAMAV,EAAA/hB,UAAAmjB,eAAA,SAAAV,GACA,MAAAA,IAAA,KAAAA,GAAA,KAMAV,EAAA/hB,UAAAujB,mBAAA,SAAAd,GACA,MAAAA,IAAA,KAAAA,GAAA,KACAA,GAAA,KAAAA,GAAA,KACAA,GAAA,KAAAA,GAAA,KAMAV,EAAA/hB,UAAAwjB,iBAAA,SAAAf,GACA,YAAAA,GAAA,MAAAA,GAMAV,EAAA/hB,UAAAyjB,8BAAA,SAAAhB,GACA,MAAAA,IAAA,KAAAA,GAAA,KACAA,GAAA,KAAAA,GAAA,KACA,MAAAA,GAAA,MAAAA,GAMAV,EAAA/hB,UAAA0jB,sBAAA,SAAAjB,GACA,MAAAhiB,MAAAgjB,8BAAAhB,IACAhiB,KAAA0iB,eAAAV,IAKAV,EAAA/hB,UAAAqiB,YAAA,WACA5hB,KAAAkjB,iBACAljB,KAAAmjB,eACAnjB,KAAAkjB,kBAKA5B,EAAA/hB,UAAA2jB,eAAA,WACA,KAAAljB,KAAAsiB,aAAAtiB,KAAA8hB,cACA9hB,KAAA+hB,WAMAT,EAAA/hB,UAAA4jB,aAAA,WACA,MAAAnjB,KAAA8hB,cAIA9hB,KAAA+hB,UAEA,MAAA/hB,KAAA8hB,aACA9hB,KAAA+hB,UACA/hB,KAAAojB,uBACG,MAAApjB,KAAA8hB,aACH9hB,KAAA+hB,UACA/hB,KAAAqjB,4BAEArjB,KAAAkiB,YAMAZ,EAAA/hB,UAAA6jB,oBAAA,WACA,MAAApjB,KAAAuiB,UAAAviB,KAAA8hB,cACAhhB,SAAAd,KAAA8hB,aACA9hB,KAAA+hB,WAMAT,EAAA/hB,UAAA8jB,yBAAA,WAGA,IAFA,GAAAC,IAAA,GAEAA,GAAA,CACA,WAAAtjB,KAAA8hB,aACA9hB,KAAA+hB,SAEA/hB,MAAA+hB,UAEA,MAAA/hB,KAAA8hB,cACA9hB,KAAA+hB,UACAuB,GAAA,KAOAhC,EAAA/hB,UAAAoiB,WAAA,WACA3hB,KAAA4hB,aAEA,IAAA2B,GAAAvjB,KAAA8hB,WACA,OAAA9hB,MAAAyiB,eAAAc,GACAvjB,KAAAwjB,cACGxjB,KAAAwiB,SAAAe,GACHvjB,KAAAyjB,kBACGzjB,KAAA+iB,iBAAAQ,GACHvjB,KAAA0jB,cACG,MAAAH,EACHvjB,KAAA2jB,aACG,MAAAJ,EACHvjB,KAAA4jB,kBAEA5jB,MAAA6hB,mBAMAP,EAAA/hB,UAAAikB,YAAA,WACAxjB,KAAA4hB,aAEA,IAAAiC,IAAA,EACAN,EAAAvjB,KAAA8hB,WAEA,OAAAyB,GAAA,MAAAA,IACAM,EAAA,MAAAN,EACAvjB,KAAA+hB,UAGA,IAAAvc,GAAA,EAEA,OAAAxF,KAAA8hB,cACA9hB,KAAA+hB,UACAwB,EAAAvjB,KAAA8hB,YAEA9hB,KAAA0iB,eAAAa,GACAvjB,KAAAqiB,WAAA,iCACK,MAAAkB,GACL/d,EAAA,EACAxF,KAAA+hB,WACK,MAAAwB,GACL/d,EAAA,EACAxF,KAAA+hB,WACK,MAAAwB,GACL/d,EAAA,GACAxF,KAAA+hB,WAEA/hB,KAAAkiB,UAIA,IAAArhB,GAAA,KAAA2E,EACAxF,KAAA8jB,eACA9jB,KAAA+jB,oBAAAve,EAMA,OAJA8G,OAAAzL,IACAb,KAAAqiB,WAAA,yBAGAwB,GACAhjB,EACAA,GAMAygB,EAAA/hB,UAAAukB,aAAA,WASA,IARA,GAAAxY,GAAA,GAEA0Y,GACAC,KAAA,EACAC,MAAA,EACAC,UAAA,GAGAnkB,KAAA2iB,QAAA3iB,KAAA8hB,cACA9hB,KAAAokB,2BAAAJ,EAAA,WACAhkB,KAAAokB,2BAAAJ,EAAA,gBACAhkB,KAAAokB,2BAAAJ,EAAA,oBAEA1Y,GAAAtL,KAAA+hB,SAGA,OAAAsC,YAAA/Y,IAYAgW,EAAA/hB,UAAA6kB,2BACA,SAAAE,EAAApf,EAAA8c,EAAAuC,GACA,GAAAhB,GAAAvjB,KAAA8hB,aACAyB,IAAAvB,GAAAuC,GAAAhB,IAAAgB,KACAD,EAAApf,IACAlF,KAAA6hB,kBAEAyC,EAAApf,IAAA,IASAoc,EAAA/hB,UAAAwkB,oBAAA,SAAAve,GAUA,IATA,GAAAkZ,GAAA1e,KACAwkB,GACAC,EAAA/F,EAAAkE,cACA8B,EAAAhG,EAAAmE,aACA8B,GAAAjG,EAAAoE,oBAEA8B,EAAAJ,EAAAhf,GAEA8F,EAAA,GACAsZ,EAAA5kB,KAAA8hB,cACAxW,GAAAtL,KAAA+hB,SAGA,OAAAjP,UAAAxH,EAAA9F,IAKA8b,EAAA/hB,UAAAkkB,gBAAA,WACAzjB,KAAA4hB,aAGA,KADA,GAAAiD,GAAA,GACA7kB,KAAAwiB,SAAAxiB,KAAA8hB,cACA+C,GAAA7kB,KAAA+hB,SAGA,IAAA+C,IACAhkB,iBACA0K,KAAA,KACAuZ,MAAA,EACAC,OAAA,EAGA,OAAAF,GAAAtlB,eAAAqlB,GACAC,EAAAD,OAEA7kB,MAAA6hB,mBAMAP,EAAA/hB,UAAAmkB,YAAA,WACA1jB,KAAA4hB,aAEA,IAAAqD,GAAAjlB,KAAA8hB,WACA9hB,MAAA+iB,iBAAAkC,IACAjlB,KAAAoiB,cAAA,SAGA,IAAA3W,GAAA,GACAyZ,GAAA,CAIA,KAFAllB,KAAA+hB,UAEAmD,GAAAllB,KAAA8hB,cAAAmD,GAAA,CACA,GAAA1B,GAAAvjB,KAAA+hB,SAEA,IAAAmD,EAAA,CACA,GAAAC,IACArlB,EAAA,KAAAkJ,EAAA,KAAArD,EAAA,KACAyf,EAAA,KAAAC,EAAA,KAAAC,EAAA,MAGAC,EAAAJ,EAAA5B,EAEAgC,GACA9Z,GAAA8Z,EACOvlB,KAAA6iB,aAAAU,IACPvjB,KAAAkiB,UACAzW,GAAAzL,KAAAwlB,oCACO,MAAAjC,GACPvjB,KAAAkiB,UACAzW,GAAAzL,KAAAylB,mCACO,MAAAlC,GACPvjB,KAAAkiB,UACAzW,GAAAzL,KAAA0lB,yBAEAja,GAAA8X,EAGA2B,GAAA,MACK,OAAA3B,EACL2B,GAAA,EAEAzZ,GAAA8X,EAMA,MAFAvjB,MAAA4G,MAAAqe,GAEAxZ,GAMA6V,EAAA/hB,UAAAimB,iCAAA,WAGA,OAFAG,GAAA,GAEAC,EAAA,EAAqBA,EAAA,EAAWA,IAAA,CAChC,GAAArC,GAAAvjB,KAAA+hB,SACA,KAAA/hB,KAAA6iB,aAAAU,GAAA,CACAvjB,KAAAkiB,SACA,OAGAyD,GAAApC,EAGA,IAAAoC,EAAAziB,QACAlD,KAAAoiB,cAAA,eAGA,IAAAxU,GAAAkF,SAAA6S,EAAA,EACA,OAAAhf,QAAA2N,aAAA1G,IAOA0T,EAAA/hB,UAAAsmB,+BAAA,SAAAC,GAGA,OAFAH,GAAA,GAEAtmB,EAAA,EAAiBA,EAAAymB,EAAkBzmB,IAAA,CACnC,GAAAkkB,GAAAvjB,KAAA+hB,SACA/hB,MAAA8iB,mBAAAS,IACAvjB,KAAAoiB,cAAA,qBAGAuD,GAAApC,EAGA,GAAA3V,GAAAkF,SAAA6S,EAAA,GACA,OAAAhf,QAAA2N,aAAA1G,IAMA0T,EAAA/hB,UAAAkmB,gCAAA,WAEA,MADAzlB,MAAA4G,MAAA,KACA5G,KAAA6lB,+BAAA,IAMAvE,EAAA/hB,UAAAwmB,gCAAA,WAEA,MADA/lB,MAAA4G,MAAA,KACA5G,KAAA6lB,+BAAA,IAMAvE,EAAA/hB,UAAAmmB,sBAAA,WAGA,MAFA1lB,MAAA4G,MAAA,KAEA,MAAA5G,KAAA8hB,YACA9hB,KAAAgmB,0BAEAhmB,KAAAkiB,UACAliB,KAAA+lB,oCAOAzE,EAAA/hB,UAAAymB,uBAAA,WACAhmB,KAAA4G,MAAA,IAIA,KAFA,GAAAqf,GAAA,GAEA,MAAAjmB,KAAA8hB,aAAgC,CAChC,GAAAoE,GAAAlmB,KAAA+hB,SACA/hB,MAAA8iB,mBAAAoD,IACAlmB,KAAAoiB,cAAA,qBAGA6D,GAAAC,GAGA,IAAAD,EAAA/iB,QAAA+iB,EAAA/iB,OAAA,IACAlD,KAAAqiB,WAAA,sBAGAriB,KAAA4G,MAAA,IAEA,IAAAgH,GAAAkF,SAAAmT,EAAA,GACA,OAAAtf,QAAAwf,cAAAvY,IAKA0T,EAAA/hB,UAAAokB,WAAA,WACA3jB,KAAA4hB,cACA5hB,KAAA4G,MAAA,IAIA,KAFA,GAAA3C,MAEA,MAAAjE,KAAA8hB,aAAA,CAGA,GAFA9hB,KAAA4hB,cAEA,MAAA5hB,KAAA8hB,YACA7d,EAAA4B,KAAA/E,YACK,UAAAd,KAAA8hB,YACL,KAEA,IAAAjhB,GAAAb,KAAA2hB,YACA1d,GAAA4B,KAAAhF,GAGAb,KAAA4hB,cACA,MAAA5hB,KAAA8hB,aACA9hB,KAAA4G,MAAA,KAMA,MAFA5G,MAAA4G,MAAA,KAEA3C,GAKAqd,EAAA/hB,UAAAqkB,YAAA,WACA5jB,KAAA4hB,aAEA,IAAAwE,KAIA,KAFApmB,KAAA4G,MAAA,KAEA,MAAA5G,KAAA8hB,aAAgC,CAChC,GAAAvgB,GAAAvB,KAAAqmB,gBACArmB,MAAA4G,MAAA,IACA,IAAA/F,GAAAb,KAAA2hB,YAEA7gB,UAAAD,IACAulB,EAAA7kB,GAAAV,GAGAb,KAAA4hB,cACA,MAAA5hB,KAAA8hB,cACA9hB,KAAA4G,MAAA,KACA5G,KAAA4hB,eAOA,MAHA5hB,MAAA4hB,cACA5hB,KAAA4G,MAAA,KAEAwf,GAKA9E,EAAA/hB,UAAA8mB,eAAA,WAGA,GAFArmB,KAAA4hB,cAEA5hB,KAAA+iB,iBAAA/iB,KAAA8hB,aACA,MAAA9hB,MAAA0jB,aAGA1jB,MAAAgjB,8BAAAhjB,KAAA8hB,cACA9hB,KAAAoiB,cAAA,uBAIA,KADA,GAAA7gB,GAAA,GACAvB,KAAAijB,sBAAAjjB,KAAA8hB,cACAvgB,GAAAvB,KAAA+hB,SAGA,OAAAxgB,KVymHM,SAASzC,EAAQD,EAASH,GWtvIhC,YAaA,SAAA2B,GAAAghB,EAAA3D,EAAAkB,GAMA,GALArC,EAAAtQ,aAAAhN,KAAAe,MAEAA,KAAAsmB,YAAAjF,EACArhB,KAAAumB,eAAA7I,EAEAkB,EACA,OAAAvf,GAAA,EAAmBA,EAAAuf,EAAA1b,OAAoB7D,IACvCgB,EAAAmmB,iBAAAxmB,KAAA4e,EAAAvf,IAwCA,QAAAonB,GAAA9I,GACA,GAAAC,GAAAzc,oBAAA+B,OAAA,GACAxD,EAAAwB,MAAA3B,UAAAI,MAAAV,KAAAkC,UAAA,KAEA,wBACAzB,EAAAmG,KAAA+X,GACAA,EAAA,MAGA5d,KAAAsmB,YAAA7I,WAAAzd,KAAAumB,eAAA5I,EAAAje,EAAAke,GApEA,GAAArB,GAAA7d,EAAA,GACAuP,EAAAvP,EAAA,EAEAI,GAAAD,QAAAwB,EAqBA4N,EAAAnC,SAAAzL,EAAAkc,EAAAtQ,cAYA5L,EAAAd,UAAAyC,KAAA,SAAAJ,EAAAG,EAAA2kB,GACAA,GACA1mB,KAAAsmB,YAAApI,gBAAAle,KAAAumB,eAAA3kB,EAAAG,GAGAwa,EAAAtQ,aAAA1M,UAAAyC,KAAA/C,KAAAe,KAAA4B,EAAAG,IAUA1B,EAAAmmB,iBAAA,SAAAG,EAAAhJ,GACAgJ,EAAAhJ,GAAA8I,EAAArJ,KAAAuJ,EAAAhJ,KX8wIM,SAAS7e,EAAQD,EAASH,GYp0IhC,YAEA,IAAAwB,GAAAxB,EAAA,GAEAkoB,IACA9nB,GAAAD,QAAA+nB,EAWAA,EAAAnF,iBAAA,SAAAoF,GACA,QAAAC,GAAAV,GACA,GAAA7Z,EAEAA,GADArL,MAAAwE,QAAA0gB,GACA,QACKA,YAAA7gB,MACL,OACK,OAAA6gB,EACL,aAEA,EAGA,IAAAW,GAAAD,EAAAE,MAAAza,EACA,OAAAwa,GACAA,EAAAX,GAGA,GA+EA,MA5EAU,GAAAE,OACA1b,OAAA,SAAAA,GACA,MAAAA,GAAA,IAGAC,QAAA,SAAA0b,GACA,MAAAA,GAAA,gBAGAnmB,UAAA,WACA,mBAGA0K,KAAA,WACA,cAGAC,OAAA,SAAAA,GACA,GAAAyb,GAAA7gB,KAAAC,UAAAmF,GAAA9L,MAAA,KACA,WAAAunB,EAAA3gB,QAAA,iBAGAmF,KAAA,SAAAA,GACA,UAAAA,EAAAyb,cAAA,KAGAljB,MAAA,SAAAA,GAGA,OAFAga,GAAA,IAEAoB,EAAA,EAAyBA,EAAApb,EAAAf,OAAsBmc,IAAA,CAC/C,GAAAxe,GAAAoD,EAAAob,EACAve,UAAAD,IACAod,GAAA6I,EAAAjmB,IAGAwe,IAAApb,EAAAf,OAAA,IACA+a,GAAA,KAIA,MAAAA,GAAA,KAGAmI,OAAA,SAAAA,GAOA,OANAnI,GAAA,IACAmJ,GAAA,EAEAC,EAAA/nB,OAAAsF,KAAAwhB,GACAkB,EAAAD,EAAAnkB,OAEA7D,EAAA,EAAqBA,EAAAioB,EAAqBjoB,IAAA,CAC1C,GAAAkC,GAAA8lB,EAAAhoB,GACAwB,EAAAimB,EAAAV,EAAA7kB,GAEA,MAAAV,GAAA,cAAAA,IAIA,iBAAAyJ,KAAA/I,KACAA,EAAAulB,EAAAE,MAAAvb,OAAAlK,IAGA6lB,EACAA,GAAA,EAEAnJ,GAAA,IAGAA,GAAA1c,EAAA,IAAAV,GAGA,MAAAod,GAAA,MAIA/d,EAAAE,OAAA0mB,EAAAE,MAAAH,GACAC,IZ40IM,SAAShoB,EAAQD,Gal7IvB,QAAA0oB,KACA,SAAA9gB,OAAA,mCAEA,QAAA+gB,KACA,SAAA/gB,OAAA,qCAsBA,QAAAghB,GAAAC,GACA,GAAAC,IAAAzM,WAEA,MAAAA,YAAAwM,EAAA,EAGA,KAAAC,IAAAJ,IAAAI,IAAAzM,WAEA,MADAyM,GAAAzM,WACAA,WAAAwM,EAAA,EAEA,KAEA,MAAAC,GAAAD,EAAA,GACK,MAAAzf,GACL,IAEA,MAAA0f,GAAA1oB,KAAA,KAAAyoB,EAAA,GACS,MAAAzf,GAET,MAAA0f,GAAA1oB,KAAAe,KAAA0nB,EAAA,KAMA,QAAAE,GAAAC,GACA,GAAAC,IAAA1M,aAEA,MAAAA,cAAAyM,EAGA,KAAAC,IAAAN,IAAAM,IAAA1M,aAEA,MADA0M,GAAA1M,aACAA,aAAAyM,EAEA,KAEA,MAAAC,GAAAD,GACK,MAAA5f,GACL,IAEA,MAAA6f,GAAA7oB,KAAA,KAAA4oB,GACS,MAAA5f,GAGT,MAAA6f,GAAA7oB,KAAAe,KAAA6nB,KAYA,QAAAE,KACAC,GAAAC,IAGAD,GAAA,EACAC,EAAA/kB,OACAglB,EAAAD,EAAAhoB,OAAAioB,GAEAC,GAAA,EAEAD,EAAAhlB,QACAklB,KAIA,QAAAA,KACA,IAAAJ,EAAA,CAGA,GAAAzM,GAAAkM,EAAAM,EACAC,IAAA,CAGA,KADA,GAAA9e,GAAAgf,EAAAhlB,OACAgG,GAAA,CAGA,IAFA+e,EAAAC,EACAA,OACAC,EAAAjf,GACA+e,GACAA,EAAAE,GAAAE,KAGAF,IAAA,EACAjf,EAAAgf,EAAAhlB,OAEA+kB,EAAA,KACAD,GAAA,EACAJ,EAAArM,IAiBA,QAAA+M,GAAAZ,EAAAzjB,GACAjE,KAAA0nB,MACA1nB,KAAAiE,QAYA,QAAAskB,MAhKA,GAOAZ,GACAG,EARAplB,EAAA5D,EAAAD,YAgBA,WACA,IAEA8oB,EADA,kBAAAzM,YACAA,WAEAqM,EAEK,MAAAtf,GACL0f,EAAAJ,EAEA,IAEAO,EADA,kBAAA1M,cACAA,aAEAoM,EAEK,MAAAvf,GACL6f,EAAAN,KAuDA,IAEAS,GAFAC,KACAF,GAAA,EAEAG,GAAA,CAyCAzlB,GAAAoY,SAAA,SAAA4M,GACA,GAAAhoB,GAAA,GAAAwB,OAAAC,UAAA+B,OAAA,EACA,IAAA/B,UAAA+B,OAAA,EACA,OAAA7D,GAAA,EAAuBA,EAAA8B,UAAA+B,OAAsB7D,IAC7CK,EAAAL,EAAA,GAAA8B,UAAA9B,EAGA6oB,GAAAriB,KAAA,GAAAyiB,GAAAZ,EAAAhoB,IACA,IAAAwoB,EAAAhlB,QAAA8kB,GACAP,EAAAW,IASAE,EAAA/oB,UAAA8oB,IAAA,WACAroB,KAAA0nB,IAAA3nB,MAAA,KAAAC,KAAAiE,QAEAvB,EAAA8lB,MAAA,UACA9lB,EAAA+lB,SAAA,EACA/lB,EAAAyH,OACAzH,EAAAgmB,QACAhmB,EAAAimB,QAAA,GACAjmB,EAAAkmB,YAIAlmB,EAAAZ,GAAAymB,EACA7lB,EAAAmK,YAAA0b,EACA7lB,EAAAsK,KAAAub,EACA7lB,EAAAmmB,IAAAN,EACA7lB,EAAAwK,eAAAqb,EACA7lB,EAAA6K,mBAAAgb,EACA7lB,EAAAV,KAAAumB,EAEA7lB,EAAAomB,QAAA,SAAA5jB,GACA,SAAAuB,OAAA,qCAGA/D,EAAAqmB,IAAA,WAA2B,WAC3BrmB,EAAAsmB,MAAA,SAAAnX,GACA,SAAApL,OAAA,mCAEA/D,EAAAumB,MAAA,WAA4B,Wbo8ItB,SAASnqB,EAAQD,EAASH,GcvnJhC,YAYA,SAAAwqB,GAAAhkB,EAAA1G,GACAwB,KAAAkF,OACAlF,KAAAxB,MA2CA,QAAA2qB,KACAnpB,KAAAopB,iBAiCA,QAAAC,GAAApM,EAAAze,GACAye,YAAAiM,GACAlpB,KAAAspB,aAAArM,EAEAjd,KAAAspB,aAAA,GAAAJ,GAAAjM,EAAAze,GA7FA,GAAA0P,GAAAxP,EAAA,GAEA6qB,IACAzqB,GAAAD,QAAA0qB,EAYAA,EAAAL,cAQAA,EAAA3pB,UAAAke,WACA,SAAA4D,EAAA3D,EAAAC,EAAAje,GACA,GAAA8pB,GAAAxpB,KAAAxB,IAAAkf,EACA,KAAA8L,EACA,SAAAtb,GAAAP,YAAAO,EAAAG,wBAGA,IAAAob,GAAAD,EAAA7L,EACA,KAAA8L,EACA,SAAAvb,GAAAP,YAAAO,EAAAK,qBAGA,IAAA3B,IAAmByU,aACnBoI,GAAA1pB,MAAA6M,EAAAlN,IAMAwpB,EAAA3pB,UAAA2hB,WAAA,SAAAxD,GACA,GAAA8L,GAAAxpB,KAAAxB,IAAAkf,EAEA,OAAA8L,GACAlqB,OAAAsF,KAAA4kB,GAEA,MAWAD,EAAAJ,6BAKAA,EAAA5pB,UAAAugB,eACA,SAAAD,GACA,MAAA7f,MAAAopB,cAAAvJ,IAQAsJ,EAAA5pB,UAAAmqB,oBACA,SAAAzM,EAAAze,GACA,qBACAye,EAAA,GAAAiM,GAAAjM,EAAAze,IAGAwB,KAAAopB,cAAAnM,EAAA/X,MAAA+X,GAiBAsM,EAAAF,4BAIAA,EAAA9pB,UAAAugB,eAAA,WACA,MAAA9f,MAAAspB,ed+nJM,SAASxqB,EAAQD,EAASH,GevuJhC,YAgBA,SAAAirB,GAAAC,EAAAC,GACAtN,EAAAtQ,aAAAhN,KAAAe,MAEAA,KAAA4pB,YACA5pB,KAAA6pB,sBAEA3pB,EAAA+B,sBAAA2nB,EAAA5pB,MACA,UACA,QACA,UA6EA,QAAA8pB,GAAAC,EAAAnM,EAAA9T,EAAAuX,EAAA2I,GACA,GAAAlgB,EACA,MAAA8T,GAAA9T,EAGA,IAAAoE,MACA+b,GAAA,EAEAC,EAAA,GAAAC,GAAAC,cAAAL,EAAA7mB,OAAA,SAAA1E,GACAyrB,IACAzrB,EAAA6rB,QAAAnc,GAGA0P,EAAA,KAAAyD,EAAA2I,EAAAxrB,IAGAurB,GAAAzoB,QAAA,SAAAoc,GACA2D,EAAA1C,iBAAAjB,EAAA,SAAA5T,EAAA0f,GACA1f,IACA0f,EAAA,KACAtb,EAAAwP,GAAA5T,EACAmgB,GAAA,GAGAC,EAAAI,QAAA5M,EAAA8L,OA5HA,GAAAjN,GAAA7d,EAAA,GACAuP,EAAAvP,EAAA,GAEAyrB,EAAAzrB,EAAA,IAEAwB,EAAAxB,EAAA,GACA4B,EAAA5B,EAAA,EAEAI,GAAAD,QAAA8qB,EAmBA1b,EAAAnC,SAAA6d,EAAApN,EAAAtQ,cAKA0d,EAAApqB,UAAAgrB,QAAA,SAAA3M,GACA5d,KAAA4pB,UAAAW,QAAA,SAAAzgB,GACA,GAAAA,EACA,MAAA8T,GAAA9T,EAGA,IAAAsS,GAAApc,KAAA4pB,UAAAY,kBACAnJ,EAAA,GAAA/gB,GAAA8b,EAAA,KAAApc,KAEA4d,GAAA,KAAAyD,IACGjE,KAAApd,QAMH2pB,EAAApqB,UAAAkrB,WAAA,SAAA7M,GACA5d,KAAA4pB,UAAAa,WAAA7M,IAKA+L,EAAApqB,UAAAugB,eAAA,WACA,MAAA9f,MAAA6pB,oBAAA/J,kBAUA6J,EAAApqB,UAAAmrB,oBACA,SAAAnM,EAAAwB,EAAAtB,EAAAb,GACA5d,KAAAuqB,QAAA,SAAAzgB,EAAAuX,GACA,MAAAvX,GACA8T,EAAA9T,OAGAuX,GAAA/C,UAAAC,EAAAwB,EAAAtB,EAAA,SAAA3U,EAAAkgB,GACA,MAAAlgB,GACA8T,EAAA9T,OAGA8T,GAAA,KAAAyD,EAAA2I,QAeAL,EAAApqB,UAAAorB,kBACA,SAAApM,EAAAwB,EAAAtB,EAAAsL,EAAAnM,GACA5d,KAAA0qB,oBAAAnM,EAAAwB,EAAAtB,EACAqL,EAAA1M,KAAApd,KAAA+pB,EAAAnM,Mf8wJM,SAAS9e,EAAQD,GgB/2JvB,YAEA,IAAA+rB,KACA9rB,GAAAD,QAAA+rB,EAEAA,EAAAC,wBAAA,iBhBs3JM,SAAS/rB,EAAQD,EAASH,GiB33JhC,YAEA,IAAAosB,GAAApsB,EAAA,IACA8iB,EAAA9iB,EAAA,IAEAqsB,EAAA,GAEAhE,IACAjoB,GAAAD,QAAAkoB,EAKAA,EAAAiE,WAAA,SAAAvf,GACA,GAAAwf,GAAAH,EAAAI,kBACAC,EAAAL,EAAAM,aAAA,iBAA6C3f,EAAA,KAC7C4f,EAAAF,EAAAG,gBAAAL,GACA1P,QAAAwP,GAGA,yBAAA7pB,MAAAwE,QAAA2lB,GACA,OAAA9pB,KAAA8pB,GACAA,EAAA7rB,eAAA+B,KACA0pB,EAAA1pB,GAAA8pB,EAAA9pB,GAKA,OAAA8pB,IAMAtE,EAAAwE,KAAA/J,EAAAC,kBACA/V,KAAA,SAAAA,GACA,GAAAD,GAAAC,EAAAyb,aACA,oBAAA1b,EAAA,MAGA+f,SAAA,SAAA5rB,GACA,MAAAA,GAAAyF,ejBo4JM,SAASvG,EAAQD,EAASH,IkB76JhC,SAAAiC,GACA,YA0BA,SAAA8qB,GAAAC,GACAnP,EAAAtQ,aAAAhN,KAAAe,MAEAA,KAAA0rB,MACA1rB,KAAA2rB,OAAA,KACA3rB,KAAA4rB,mBAAA,KACA5rB,KAAA6rB,eAAA,EA2GA,QAAAC,GAAAH,EAAAC,GACArP,EAAAtQ,aAAAhN,KAAAe,MAEAA,KAAA2rB,SACA3rB,KAAA4rB,qBAEA1rB,EAAA+B,sBAAA2pB,EAAA5rB,MACA,QACA,UAGAA,KAAA4rB,mBAAA9pB,GAAA,UAAA9B,KAAA+rB,WAAA3O,KAAApd,OApJA,GAAAuc,GAAA7d,EAAA,GACAuP,EAAAvP,EAAA,GAEAirB,EAAAjrB,EAAA,IACAwB,EAAAxB,EAAA,GACAksB,EAAAlsB,EAAA,IAEA+B,IACA3B,GAAAD,QAAA4B,EAMAA,EAAAurB,aAAA,SAAAN,EAAAO,GACA,GAAAC,GAAA,GAAAT,GAAAC,GACAS,EAAA,GAAAxC,GAAAuC,EAAAD,EAEA,OAAAE,IAeAle,EAAAnC,SAAA2f,EAAAlP,EAAAtQ,cACAxL,EAAAgrB,qBAKAA,EAAAlsB,UAAAgrB,QAAA,SAAA3M,GACA,GAAA5d,KAAA6rB,cAIA,YAHAjO,GACAA,EAAA,GAAAnX,OAAA,sBAKA,KACAzG,KAAA2rB,OAAA,GAAAS,WAAApsB,KAAA0rB,IAAAd,EAAAC,yBACG,MAAA/gB,GAIH,YAHA8T,GACAA,EAAA9T,IAKA9J,KAAA4rB,mBAAA,GAAArP,GAAAtQ,aAEAjM,KAAA2rB,OAAAU,OAAArsB,KAAAssB,QAAAlP,KAAApd,MACAA,KAAA2rB,OAAAY,QAAAvsB,KAAAwsB,SAAApP,KAAApd,MACAA,KAAA2rB,OAAAc,QAAAzsB,KAAA0sB,SAAAtP,KAAApd,MACAA,KAAA2rB,OAAAgB,UAAA3sB,KAAA+rB,WAAA3O,KAAApd,MAEAA,KAAA4rB,mBAAA5e,KAAA,yBAAAlD,GACA8T,GACAA,EAAA9T,KAIA9J,KAAA4rB,mBAAA5e,KAAA,kBACA4Q,GACAA,OAOA6N,EAAAlsB,UAAAkrB,WAAA,SAAA7M,GACA5d,KAAA4sB,mBAEAhP,GACA5d,KAAAqhB,WAAArU,KAAA,QAAA4Q,GAGA5d,KAAA2rB,OAAAnQ,SAKAiQ,EAAAlsB,UAAAirB,gBAAA,WAEA,MADAxqB,MAAA4sB,mBACA,GAAAd,GAAA9rB,KAAA2rB,OAAA3rB,KAAA4rB,qBAKAH,EAAAlsB,UAAAqtB,iBAAA,WACA,IAAA5sB,KAAA6rB,cACA,SAAAplB,OAAA,sBAMAglB,EAAAlsB,UAAA+sB,QAAA,WACAtsB,KAAA6rB,eAAA,EACA7rB,KAAA4rB,mBAAA5pB,KAAA,SAKAypB,EAAAlsB,UAAAitB,SAAA,WACAxsB,KAAA6rB,eAAA,EACA7rB,KAAA4rB,mBAAA5pB,KAAA,UAKAypB,EAAAlsB,UAAAmtB,SAAA,SAAA5iB,GACA9J,KAAA6rB,cACA7rB,KAAA4rB,mBAAA5pB,KAAA,QAAA8H,GAEA9J,KAAA4rB,mBAAA5pB,KAAA,gBAAA8H,IAMA2hB,EAAAlsB,UAAAwsB,WAAA,SAAAle,GACA7N,KAAA4rB,mBAAA5pB,KAAA,UAAA6L,IAqBAI,EAAAnC,SAAAggB,EAAAvP,EAAAtQ,cACAxL,EAAAqrB,wBAIAA,EAAAvsB,UAAAqd,iBAAA,WACA,MAAA5c,MAAA2rB,OAAAD,KAMAI,EAAAvsB,UAAAyf,KAAA,SAAArO,GACAhQ,EAAAiL,SAAA+E,KACAA,IAAAtL,YAGArF,KAAA2rB,OAAA3M,KAAArO,IAMAmb,EAAAvsB,UAAA6R,IAAA,SAAAT,GACAA,GACA3Q,KAAAgf,KAAArO,GAGA3Q,KAAA2rB,OAAAnQ,SAMAsQ,EAAAvsB,UAAAwsB,WAAA,SAAAle,GACA,GAAA8C,GAAA,gBAAA9C,GAAA,KACAA,EAAA8C,KACA,GAAAhQ,GAAAkN,EAAA8C,MAAAtL,UAEArF,MAAAgC,KAAA,WAAA2O,EAAA,QlBk7J8B1R,KAAKJ,EAASH,EAAoB,GAAGiC,SAI7D,SAAS7B,EAAQD,GmBvnKvB,YAmBA,SAAAguB,GAAAC,GACA,GAAA5jB,GAAA4jB,EAAA5pB,MACA,IAAAgG,EAAA,IACA,SAAAzC,OAAA,iDAQA,aAAAqmB,EAAA5jB,EAAA,WAAA4jB,EAAA5jB,EAAA,OAGA,QAAAmG,GAAAyd,GAEA,SAAAA,EAAA5pB,OAAA,EAAA2pB,EAAAC,GAGA,QAAA7W,GAAA6W,GACA,GAAAztB,GAAAmT,EAAA9L,EAAAqmB,EAAAC,EAAAhe,EACA9F,EAAA4jB,EAAA5pB,MACA8pB,GAAAH,EAAAC,GAEA9d,EAAA,GAAAie,GAAA,EAAA/jB,EAAA,EAAA8jB,GAGAtmB,EAAAsmB,EAAA,EAAA9jB,EAAA,EAAAA,CAEA,IAAAgkB,GAAA,CAEA,KAAA7tB,EAAA,EAAAmT,EAAA,EAAoBnT,EAAAqH,EAAOrH,GAAA,EAAAmT,GAAA,EAC3Bua,EAAAI,EAAAL,EAAAjX,WAAAxW,KAAA,GAAA8tB,EAAAL,EAAAjX,WAAAxW,EAAA,QAAA8tB,EAAAL,EAAAjX,WAAAxW,EAAA,OAAA8tB,EAAAL,EAAAjX,WAAAxW,EAAA,IACA2P,EAAAke,KAAAH,GAAA,OACA/d,EAAAke,KAAAH,GAAA,MACA/d,EAAAke,KAAA,IAAAH,CAYA,OATA,KAAAC,GACAD,EAAAI,EAAAL,EAAAjX,WAAAxW,KAAA,EAAA8tB,EAAAL,EAAAjX,WAAAxW,EAAA,OACA2P,EAAAke,KAAA,IAAAH,GACG,IAAAC,IACHD,EAAAI,EAAAL,EAAAjX,WAAAxW,KAAA,GAAA8tB,EAAAL,EAAAjX,WAAAxW,EAAA,OAAA8tB,EAAAL,EAAAjX,WAAAxW,EAAA,OACA2P,EAAAke,KAAAH,GAAA,MACA/d,EAAAke,KAAA,IAAAH,GAGA/d,EAGA,QAAAoe,GAAAC,GACA,MAAAC,GAAAD,GAAA,OAAAC,EAAAD,GAAA,OAAAC,EAAAD,GAAA,MAAAC,EAAA,GAAAD,GAGA,QAAAE,GAAAC,EAAArc,EAAAC,GAGA,OAFA2b,GACAjnB,KACAzG,EAAA8R,EAAqB9R,EAAA+R,EAAS/R,GAAA,EAC9B0tB,GAAAS,EAAAnuB,IAAA,KAAAmuB,EAAAnuB,EAAA,OAAAmuB,EAAAnuB,EAAA,GACAyG,EAAAD,KAAAunB,EAAAL,GAEA,OAAAjnB,GAAAqB,KAAA,IAGA,QAAAqM,GAAAga,GASA,OARAT,GACA7jB,EAAAskB,EAAAtqB,OACAuqB,EAAAvkB,EAAA,EACApD,EAAA,GACA4nB,KACAC,EAAA,MAGAtuB,EAAA,EAAAuuB,EAAA1kB,EAAAukB,EAA0CpuB,EAAAuuB,EAAUvuB,GAAAsuB,EACpDD,EAAA7nB,KAAA0nB,EAAAC,EAAAnuB,IAAAsuB,EAAAC,IAAAvuB,EAAAsuB,GAmBA,OAfA,KAAAF,GACAV,EAAAS,EAAAtkB,EAAA,GACApD,GAAAwnB,EAAAP,GAAA,GACAjnB,GAAAwnB,EAAAP,GAAA,MACAjnB,GAAA,MACG,IAAA2nB,IACHV,GAAAS,EAAAtkB,EAAA,OAAAskB,EAAAtkB,EAAA,GACApD,GAAAwnB,EAAAP,GAAA,IACAjnB,GAAAwnB,EAAAP,GAAA,MACAjnB,GAAAwnB,EAAAP,GAAA,MACAjnB,GAAA,KAGA4nB,EAAA7nB,KAAAC,GAEA4nB,EAAAvmB,KAAA,IA9GAtI,EAAAwQ,aACAxQ,EAAAoX,cACApX,EAAA2U,eAOA,QALA8Z,MACAH,KACAF,EAAA,mBAAAhe,uBAAA/N,MAEA0M,EAAA,mEACAvO,EAAA,EAAA6J,EAAA0E,EAAA1K,OAAkC7D,EAAA6J,IAAS7J,EAC3CiuB,EAAAjuB,GAAAuO,EAAAvO,GACA8tB,EAAAvf,EAAAiI,WAAAxW,KAGA8tB,GAAA,IAAAtX,WAAA,OACAsX,EAAA,IAAAtX,WAAA,QnB8tKM,SAAS/W,EAAQD,GoB/uKvBA,EAAAmT,KAAA,SAAA1P,EAAAoQ,EAAAmb,EAAAC,EAAAC,GACA,GAAA9lB,GAAA/I,EACA8uB,EAAA,EAAAD,EAAAD,EAAA,EACAG,GAAA,GAAAD,GAAA,EACAE,EAAAD,GAAA,EACAE,GAAA,EACA9uB,EAAAwuB,EAAAE,EAAA,IACA/lB,EAAA6lB,GAAA,IACAO,EAAA9rB,EAAAoQ,EAAArT,EAOA,KALAA,GAAA2I,EAEAC,EAAAmmB,GAAA,IAAAD,GAAA,EACAC,KAAAD,EACAA,GAAAH,EACQG,EAAA,EAAWlmB,EAAA,IAAAA,EAAA3F,EAAAoQ,EAAArT,MAAA2I,EAAAmmB,GAAA,GAKnB,IAHAjvB,EAAA+I,GAAA,IAAAkmB,GAAA,EACAlmB,KAAAkmB,EACAA,GAAAL,EACQK,EAAA,EAAWjvB,EAAA,IAAAA,EAAAoD,EAAAoQ,EAAArT,MAAA2I,EAAAmmB,GAAA,GAEnB,OAAAlmB,EACAA,EAAA,EAAAimB,MACG,IAAAjmB,IAAAgmB,EACH,MAAA/uB,GAAAmvB,KAAAD,GAAA,MAAAzY,IAEAzW,IAAAuU,KAAA6E,IAAA,EAAAwV,GACA7lB,GAAAimB,EAEA,OAAAE,GAAA,KAAAlvB,EAAAuU,KAAA6E,IAAA,EAAArQ,EAAA6lB,IAGAjvB,EAAAyR,MAAA,SAAAhO,EAAAzB,EAAA6R,EAAAmb,EAAAC,EAAAC,GACA,GAAA9lB,GAAA/I,EAAAC,EACA6uB,EAAA,EAAAD,EAAAD,EAAA,EACAG,GAAA,GAAAD,GAAA,EACAE,EAAAD,GAAA,EACAK,EAAA,KAAAR,EAAAra,KAAA6E,IAAA,OAAA7E,KAAA6E,IAAA,SACAjZ,EAAAwuB,EAAA,EAAAE,EAAA,EACA/lB,EAAA6lB,EAAA,KACAO,EAAAvtB,EAAA,OAAAA,GAAA,EAAAA,EAAA,KAmCA,KAjCAA,EAAA4S,KAAA8a,IAAA1tB,GAEAyL,MAAAzL,QAAA8U,KACAzW,EAAAoN,MAAAzL,GAAA,IACAoH,EAAAgmB,IAEAhmB,EAAAwL,KAAA4F,MAAA5F,KAAA5H,IAAAhL,GAAA4S,KAAA+a,KACA3tB,GAAA1B,EAAAsU,KAAA6E,IAAA,GAAArQ,IAAA,IACAA,IACA9I,GAAA,GAGA0B,GADAoH,EAAAimB,GAAA,EACAI,EAAAnvB,EAEAmvB,EAAA7a,KAAA6E,IAAA,IAAA4V,GAEArtB,EAAA1B,GAAA,IACA8I,IACA9I,GAAA,GAGA8I,EAAAimB,GAAAD,GACA/uB,EAAA,EACA+I,EAAAgmB,GACKhmB,EAAAimB,GAAA,GACLhvB,GAAA2B,EAAA1B,EAAA,GAAAsU,KAAA6E,IAAA,EAAAwV,GACA7lB,GAAAimB,IAEAhvB,EAAA2B,EAAA4S,KAAA6E,IAAA,EAAA4V,EAAA,GAAAza,KAAA6E,IAAA,EAAAwV,GACA7lB,EAAA,IAIQ6lB,GAAA,EAAWxrB,EAAAoQ,EAAArT,GAAA,IAAAH,EAAAG,GAAA2I,EAAA9I,GAAA,IAAA4uB,GAAA,GAInB,IAFA7lB,KAAA6lB,EAAA5uB,EACA8uB,GAAAF,EACQE,EAAA,EAAU1rB,EAAAoQ,EAAArT,GAAA,IAAA4I,EAAA5I,GAAA2I,EAAAC,GAAA,IAAA+lB,GAAA,GAElB1rB,EAAAoQ,EAAArT,EAAA2I,IAAA,IAAAomB,IpBuvKM,SAAStvB,EAAQD,GqBx0KvB,GAAAmG,aAEAlG,GAAAD,QAAA,SAAAmQ,EAAApM,GACA,GAAAoC,EAAA,MAAAgK,GAAAhK,QAAApC,EACA,QAAAvD,GAAA,EAAiBA,EAAA2P,EAAA9L,SAAgB7D,EACjC,GAAA2P,EAAA3P,KAAAuD,EAAA,MAAAvD,EAEA,YrBg1KM,SAASP,EAAQD,GsBx1KvB,GAAAwG,MAAiBA,QAEjBvG,GAAAD,QAAAqC,MAAAwE,SAAA,SAAAsJ,GACA,wBAAA3J,EAAApG,KAAA+P,KtBg2KM,SAASlQ,EAAQD,GuBn2KvB,YAEA,IAAAsrB,KACArrB,GAAAD,QAAAsrB,EAWAA,EAAAsE,YAAA,SAAAC,EAAApL,EAAA3S,GACA,IAAA+d,EAAAxrB,OACAinB,EAAAwE,SAAAD,EAAA,GAAApL,EAAA3S,GAEAwZ,EAAAyE,WAAAF,EAAApL,EAAA3S,IAaAwZ,EAAAwE,SAAA,SAAAD,EAAApL,EAAA3S,GACA,GAAAke,GAAA,EACA3lB,EAAAwlB,EAAAxrB,OACA4rB,GAAA,CACAne,SAEAzH,EAAA,EACAoa,KAAA3S,GAEA+d,EAAAptB,QAAA,SAAA1B,GACA,GAAAmvB,GAAA,SAAA9Q,GACAre,EAAAsF,MAAA+Y,IAAAtN,EAAA/Q,EAAAsF,MAAA+Y,GACAA,YAAAxX,QACAqoB,GACAxL,KAAArF,GAEA6Q,GAAA,KAEAD,GAAA3lB,GACAoa,KAAA3S,GAIAzP,OAAAwE,QAAA9F,GAAAuqB,EAAAsE,YAAA7uB,EAAAmvB,EAAApe,GAEA,IAAA/Q,EAAAsD,OAAAtD,EAAA+Q,EAAAoe,GACAnvB,EAAAmvB,MAeA5E,EAAAyE,WAAA,SAAAF,EAAApL,EAAA3S,GAKA,QAAAqe,KACA,GAAApvB,GACAmvB,EAAA,SAAA9Q,GACAre,EAAAsF,MAAA+Y,IAAAtN,EAAA/Q,EAAAsF,MAAA+Y,GACAA,YAAAxX,OACA6c,KAAArF,GACO+Q,OAEP3vB,GAAA6J,EACAoa,KAAA3S,IAEA/Q,EAAA8uB,EAAArvB,GACA6B,MAAAwE,QAAA9F,GAAAuqB,EAAAsE,YAAA7uB,EAAAmvB,EAAApe,GAEA,IAAA/Q,EAAAsD,OAAAtD,EAAA+Q,EAAAoe,GACAnvB,EAAAmvB,IAnBA,GAAA1vB,IAAA,EACA6J,EAAAwlB,EAAAxrB,MACAyN,SAsBAzH,EAAA,EAAA8lB,IACA1L,KAAA3S,IAOAwZ,EAAAC,cAAA,SAAA6E,EAAA3L,GACAtjB,KAAAivB,WACAjvB,KAAA2Q,QACA3Q,KAAA4lB,MAAA,EACA5lB,KAAAsjB,QAOA6G,EAAAC,cAAA7qB,UAAA+qB,QAAA,SAAA/oB,EAAAoP,GACA3Q,KAAA4lB,QACA5lB,KAAA2Q,KAAApP,GAAAoP,EACA3Q,KAAAivB,WAAAjvB,KAAA4lB,OAAA5lB,KAAAsjB,KAAAtjB,KAAA2Q,OAeAwZ,EAAA/oB,OAAA,SAAA8tB,EAAAtvB,EAAA0jB,GAIA,QAAAyL,KAIA9Q,EAAAkR,KAAA,SAAAhmB,EAAA2N,GAAgC,MAAA3N,GAAAkW,MAAAvI,EAAAuI,QAGhCpB,IAAAjY,IAAA,SAAAmD,GAAqC,MAAAA,GAAAtI,QAGrCyiB,KAAArF,GAbA,GAAAA,MACA4Q,EAAA,CAeAK,GAAA5tB,QAAA,SAAAT,EAAAwe,GACAzf,EAAAiB,EAAA,SAAAuuB,GACAA,GAAAnR,EAAApY,MAAiCwZ,QAAAxe,YACjCguB,IAAAK,EAAAhsB,QAAA6rB,SAiBA5E,EAAAkF,KAAA,SAAAH,EAAAtvB,EAAA0jB,GAIA,QAAA0L,KACA3vB,IAAA6J,EACAoa,OAEA1jB,EAAAsvB,EAAA7vB,GAAA,SAAA+vB,GACAA,EACA9L,KAAA4L,EAAA7vB,KAEAA,IACA2vB,OAZA,GAAA3vB,GAAA,EACA6J,EAAAgmB,EAAAhsB,MAiBAgG,GAAA,EAAA8lB,IACA1L,QAYA6G,EAAAmF,OAAA,SAAAJ,EAAAtvB,EAAA0jB,GAIA,QAAA0L,KACA3vB,IACAA,GAAA6J,EACAoa,OACK1jB,EAAAsvB,EAAA7vB,GAAA,SAAA4e,GACLA,YAAAxX,OACA6c,KAAArF,GACO+Q,MAVP,GAAA3vB,IAAA,EACA6J,EAAAgmB,EAAAhsB,MAaA8rB,MAYA7E,EAAAoF,KAAA,SAAAL,EAAAtvB,EAAA0jB,GACA,GAAAuL,GAAA,EACA3lB,EAAAgmB,EAAAhsB,OACA4rB,GAAA,CAEA5lB,GAAA,EACAoa,OAEA4L,EAAA5tB,QAAA,SAAAsa,GACAhc,EAAAgc,EAAA,SAAAqC,GACAA,YAAAxX,QACAqoB,GACAxL,KAAArF,GAEA6Q,GAAA,IAEAD,IACAA,GAAA3lB,GACAoa,cvBg3KM,SAASxkB,EAAQD,GwBxmLvB,kBAAAS,QAAAkwB,OAEA1wB,EAAAD,QAAA,SAAA4wB,EAAAC,GACAD,EAAAE,OAAAD,EACAD,EAAAlwB,UAAAD,OAAAkwB,OAAAE,EAAAnwB,WACAgF,aACA1D,MAAA4uB,EACAG,YAAA,EACAC,UAAA,EACAnZ,cAAA,MAMA5X,EAAAD,QAAA,SAAA4wB,EAAAC,GACAD,EAAAE,OAAAD,CACA,IAAAI,GAAA,YACAA,GAAAvwB,UAAAmwB,EAAAnwB,UACAkwB,EAAAlwB,UAAA,GAAAuwB,GACAL,EAAAlwB,UAAAgF,YAAAkrB,IxBinLM,SAAS3wB,EAAQD,GyBroLvBC,EAAAD,QAAA,SAAA6I,GACA,MAAAA,IAAA,gBAAAA,IACA,kBAAAA,GAAA+I,MACA,kBAAA/I,GAAAnF,MACA,kBAAAmF,GAAAuQ,YzB4oLM,SAASnZ,OAAQD,QAASH,qB0BtmLhC,QAAAqxB,YA1CA,GAAA/qB,SAAAtG,oBAAA,IAEAsxB,YAAA,SAAAptB,GACA,GAAAtD,OAAAsF,KAAA,MAAAtF,QAAAsF,KAAAhC,EAEA,IAAA+Q,KACA,QAAApS,KAAAqB,GAAA+Q,EAAA9N,KAAAtE,EACA,OAAAoS,IAIArS,QAAA,SAAA2uB,EAAArwB,GACA,GAAAqwB,EAAA3uB,QAAA,MAAA2uB,GAAA3uB,QAAA1B,EACA,QAAAP,GAAA,EAAwBA,EAAA4wB,EAAA/sB,OAAe7D,IACvCO,EAAAqwB,EAAA5wB,KAAA4wB,IAIAC,WAAA,WACA,IAEA,MADA5wB,QAAAmX,kBAAgC,QAChC,SAAA7T,EAAAsC,EAAArE,GACAvB,OAAAmX,eAAA7T,EAAAsC,GACA2qB,UAAA,EACAD,YAAA,EACAlZ,cAAA,EACA7V,WAGK,MAAAoH,GACL,gBAAArF,EAAAsC,EAAArE,GACA+B,EAAAsC,GAAArE,OAKAsvB,SAAA,wDACA,8DACA,wEACA,2EACA,yEAGAJ,SAAAxwB,YAEA,IAAA6wB,QAAAvxB,QAAAuxB,OAAA,SAAAxiB,GACA,MAAA5N,gBAAAowB,aACApwB,KAAA4N,QADA,GAAAwiB,QAAAxiB,GAIAwiB,QAAA7wB,UAAA8wB,aAAA,SAAAzjB,GACA,KAAAA,YAAAmjB,UACA,SAAA/uB,WAAA,8BAGA,IAAAsvB,GAAAC,SAAAC,cAAA,SACAF,GAAAxsB,QAAAwsB,EAAAxsB,UACAwsB,EAAAxsB,MAAA2sB,QAAA,OAEAF,SAAAG,KAAAC,YAAAL,EAEA,IAAAM,GAAAN,EAAAO,cACAC,EAAAF,EAAAG,KAAAC,EAAAJ,EAAAK,YAEAH,GAAAE,IAEAA,EAAA/xB,KAAA2xB,EAAA,QACAE,EAAAF,EAAAG,MAGAzvB,QAAA0uB,YAAApjB,GAAA,SAAArL,GACAqvB,EAAArvB,GAAAqL,EAAArL,KAEAD,QAAA6uB,QAAA,SAAA5uB,GACAqL,EAAArL,KACAqvB,EAAArvB,GAAAqL,EAAArL,KAIA,IAAA2vB,GAAAlB,YAAAY,GAEAjd,EAAAmd,EAAA7xB,KAAA2xB,EAAA5wB,KAAA4N,KAmBA,OAjBAtM,SAAA0uB,YAAAY,GAAA,SAAArvB,IAIAA,IAAAqL,IAAA5H,QAAAksB,EAAA3vB,MAAA,KACAqL,EAAArL,GAAAqvB,EAAArvB,MAIAD,QAAA6uB,QAAA,SAAA5uB,GACAA,IAAAqL,IACAsjB,WAAAtjB,EAAArL,EAAAqvB,EAAArvB,MAIAgvB,SAAAG,KAAAS,YAAAb,GAEA3c,GAGAyc,OAAA7wB,UAAA6xB,iBAAA,WACA,MAAAL,MAAA/wB,KAAA4N,OAGAwiB,OAAA7wB,UAAA+rB,gBAAA,SAAA1e,GACA,GAAA9J,GAAAstB,OAAAlF,cAAAte,GACA+G,EAAA3T,KAAAqwB,aAAAvtB,EAMA,OAJAxB,SAAA0uB,YAAAltB,GAAA,SAAAvB,GACAqL,EAAArL,GAAAuB,EAAAvB,KAGAoS,GAGArS,QAAA0uB,YAAAI,OAAA7wB,WAAA,SAAA2F,GACArG,QAAAqG,GAAAkrB,OAAAlrB,GAAA,SAAA0I,GACA,GAAAwgB,GAAAgC,OAAAxiB,EACA,OAAAwgB,GAAAlpB,GAAAnF,MAAAquB,KAAAzuB,MAAAV,KAAAkC,UAAA,OAIAtC,QAAAusB,aAAA,SAAAxd,GACA,MAAA/O,SAAAuxB,OAAAxiB,IAGA/O,QAAAqsB,cAAAkF,OAAAlF,cAAA,SAAAte,GACA,GAAA6D,GAAA,GAAAsf,QAMA,OALA,gBAAAnjB,IACAtL,QAAA0uB,YAAApjB,GAAA,SAAArL,GACAkP,EAAAlP,GAAAqL,EAAArL,KAGAkP,I1BwpLM,SAAS3R,EAAQD,KAMvB,GAEA","file":"jstp.min.js","sourcesContent":["api = typeof api === \"object\" ? api : {}; api[\"jstp\"] =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ((function(modules) {\n\t// Check all modules for deduplicated modules\n\tfor(var i in modules) {\n\t\tif(Object.prototype.hasOwnProperty.call(modules, i)) {\n\t\t\tswitch(typeof modules[i]) {\n\t\t\tcase \"function\": break;\n\t\t\tcase \"object\":\n\t\t\t\t// Module can be created from a template\n\t\t\t\tmodules[i] = (function(_m) {\n\t\t\t\t\tvar args = _m.slice(1), fn = modules[_m[0]];\n\t\t\t\t\treturn function (a,b,c) {\n\t\t\t\t\t\tfn.apply(this, [a,b,c].concat(args));\n\t\t\t\t\t};\n\t\t\t\t}(modules[i]));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Module is a copy of another module\n\t\t\t\tmodules[i] = modules[modules[i]];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn modules;\n}([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar common = __webpack_require__(1);\n\t\n\tvar jstp = {};\n\tmodule.exports = jstp;\n\t\n\tcommon.extend(jstp,\n\t  __webpack_require__(8),\n\t  __webpack_require__(15),\n\t  __webpack_require__(4),\n\t  __webpack_require__(12)\n\t);\n\t\n\tjstp.RemoteProxy = __webpack_require__(9);\n\tjstp.Connection = __webpack_require__(7);\n\tjstp.Server = __webpack_require__(26);\n\t\n\tjstp.tcp = __webpack_require__(27);\n\tjstp.ws = __webpack_require__(16);\n\t\n\tjstp.simpleAuthProvider = __webpack_require__(25);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';\n\t\n\tvar common = {};\n\tmodule.exports = common;\n\t\n\t// Tests if a value is null or undefined\n\t//   value - a value to test\n\t//\n\tfunction isNull(value) {\n\t  return value === null || value === undefined;\n\t}\n\t\n\t// Populate a target object with all the properties\n\t// of arbitrary number of other objects\n\t// Signature:\n\t//   common.extend(target, ...sources);\n\t// Parameters:\n\t//   target - object to copy properties into\n\t//   ...sources - source objects\n\t//\n\tcommon.extend = function(target) {\n\t  if (isNull(target)) {\n\t    throw new TypeError('Cannot convert undefined or null to object');\n\t  }\n\t\n\t  if (typeof(target) !== 'object') {\n\t    target = new Object(target);\n\t  }\n\t\n\t  var sources = Array.prototype.slice\n\t    .call(arguments, 1)\n\t    .filter(function(source) {\n\t      return !isNull(source);\n\t    });\n\t\n\t  sources.forEach(function(source) {\n\t    for (var key in source) {\n\t      if (!source.hasOwnProperty(key)) {\n\t        continue;\n\t      }\n\t      target[key] = source[key];\n\t    }\n\t  });\n\t\n\t  return target;\n\t};\n\t\n\tif (Object.assign) {\n\t  common.extend = Object.assign;\n\t}\n\t\n\t// Forward an event from one EventEmitter to another\n\t//   from - EventEmitter to listen for event\n\t//   to - EventEmitter to emit event on\n\t//   eventName - name of the event\n\t//   newEventName - name of the forwarded event (optional)\n\t//\n\tcommon.forwardEvent = function(from, to, eventName, newEventName) {\n\t  from.on(eventName, function(eventArgs) {\n\t    to.emit(newEventName || eventName, eventArgs, to);\n\t  });\n\t};\n\t\n\t// Forward events from one EventEmitter to another\n\t//   from - EventEmitter to listen for event\n\t//   to - EventEmitter to emit event on\n\t//   eventNames - array of names of events\n\t//\n\tcommon.forwardMultipleEvents = function(from, to, eventNames) {\n\t  eventNames.forEach(function(event) {\n\t    common.forwardEvent(from, to, event);\n\t  });\n\t};\n\t\n\t// Create a zero-filled buffer of specified size\n\t//   size - desired buffer size\n\t//\n\tcommon.createZeroFilledBuffer = function(size) {\n\t  var buffer = new Buffer(size);\n\t  buffer.fill(0);\n\t\n\t  return buffer;\n\t};\n\t\n\tif (Buffer.alloc) {\n\t  common.createZeroFilledBuffer = Buffer.alloc;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tvar formatRegExp = /%[sdj%]/g;\n\texports.format = function(f) {\n\t  if (!isString(f)) {\n\t    var objects = [];\n\t    for (var i = 0; i < arguments.length; i++) {\n\t      objects.push(inspect(arguments[i]));\n\t    }\n\t    return objects.join(' ');\n\t  }\n\t\n\t  var i = 1;\n\t  var args = arguments;\n\t  var len = args.length;\n\t  var str = String(f).replace(formatRegExp, function(x) {\n\t    if (x === '%%') return '%';\n\t    if (i >= len) return x;\n\t    switch (x) {\n\t      case '%s': return String(args[i++]);\n\t      case '%d': return Number(args[i++]);\n\t      case '%j':\n\t        try {\n\t          return JSON.stringify(args[i++]);\n\t        } catch (_) {\n\t          return '[Circular]';\n\t        }\n\t      default:\n\t        return x;\n\t    }\n\t  });\n\t  for (var x = args[i]; i < len; x = args[++i]) {\n\t    if (isNull(x) || !isObject(x)) {\n\t      str += ' ' + x;\n\t    } else {\n\t      str += ' ' + inspect(x);\n\t    }\n\t  }\n\t  return str;\n\t};\n\t\n\t\n\t// Mark that a method should not be used.\n\t// Returns a modified function which warns once by default.\n\t// If --no-deprecation is set, then it is a no-op.\n\texports.deprecate = function(fn, msg) {\n\t  // Allow for deprecating things in the process of starting up.\n\t  if (isUndefined(global.process)) {\n\t    return function() {\n\t      return exports.deprecate(fn, msg).apply(this, arguments);\n\t    };\n\t  }\n\t\n\t  if (process.noDeprecation === true) {\n\t    return fn;\n\t  }\n\t\n\t  var warned = false;\n\t  function deprecated() {\n\t    if (!warned) {\n\t      if (process.throwDeprecation) {\n\t        throw new Error(msg);\n\t      } else if (process.traceDeprecation) {\n\t        console.trace(msg);\n\t      } else {\n\t        console.error(msg);\n\t      }\n\t      warned = true;\n\t    }\n\t    return fn.apply(this, arguments);\n\t  }\n\t\n\t  return deprecated;\n\t};\n\t\n\t\n\tvar debugs = {};\n\tvar debugEnviron;\n\texports.debuglog = function(set) {\n\t  if (isUndefined(debugEnviron))\n\t    debugEnviron = process.env.NODE_DEBUG || '';\n\t  set = set.toUpperCase();\n\t  if (!debugs[set]) {\n\t    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n\t      var pid = process.pid;\n\t      debugs[set] = function() {\n\t        var msg = exports.format.apply(exports, arguments);\n\t        console.error('%s %d: %s', set, pid, msg);\n\t      };\n\t    } else {\n\t      debugs[set] = function() {};\n\t    }\n\t  }\n\t  return debugs[set];\n\t};\n\t\n\t\n\t/**\n\t * Echos the value of a value. Trys to print the value out\n\t * in the best way possible given the different types.\n\t *\n\t * @param {Object} obj The object to print out.\n\t * @param {Object} opts Optional options object that alters the output.\n\t */\n\t/* legacy: obj, showHidden, depth, colors*/\n\tfunction inspect(obj, opts) {\n\t  // default options\n\t  var ctx = {\n\t    seen: [],\n\t    stylize: stylizeNoColor\n\t  };\n\t  // legacy...\n\t  if (arguments.length >= 3) ctx.depth = arguments[2];\n\t  if (arguments.length >= 4) ctx.colors = arguments[3];\n\t  if (isBoolean(opts)) {\n\t    // legacy...\n\t    ctx.showHidden = opts;\n\t  } else if (opts) {\n\t    // got an \"options\" object\n\t    exports._extend(ctx, opts);\n\t  }\n\t  // set default options\n\t  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n\t  if (isUndefined(ctx.depth)) ctx.depth = 2;\n\t  if (isUndefined(ctx.colors)) ctx.colors = false;\n\t  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n\t  if (ctx.colors) ctx.stylize = stylizeWithColor;\n\t  return formatValue(ctx, obj, ctx.depth);\n\t}\n\texports.inspect = inspect;\n\t\n\t\n\t// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n\tinspect.colors = {\n\t  'bold' : [1, 22],\n\t  'italic' : [3, 23],\n\t  'underline' : [4, 24],\n\t  'inverse' : [7, 27],\n\t  'white' : [37, 39],\n\t  'grey' : [90, 39],\n\t  'black' : [30, 39],\n\t  'blue' : [34, 39],\n\t  'cyan' : [36, 39],\n\t  'green' : [32, 39],\n\t  'magenta' : [35, 39],\n\t  'red' : [31, 39],\n\t  'yellow' : [33, 39]\n\t};\n\t\n\t// Don't use 'blue' not visible on cmd.exe\n\tinspect.styles = {\n\t  'special': 'cyan',\n\t  'number': 'yellow',\n\t  'boolean': 'yellow',\n\t  'undefined': 'grey',\n\t  'null': 'bold',\n\t  'string': 'green',\n\t  'date': 'magenta',\n\t  // \"name\": intentionally not styling\n\t  'regexp': 'red'\n\t};\n\t\n\t\n\tfunction stylizeWithColor(str, styleType) {\n\t  var style = inspect.styles[styleType];\n\t\n\t  if (style) {\n\t    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n\t           '\\u001b[' + inspect.colors[style][1] + 'm';\n\t  } else {\n\t    return str;\n\t  }\n\t}\n\t\n\t\n\tfunction stylizeNoColor(str, styleType) {\n\t  return str;\n\t}\n\t\n\t\n\tfunction arrayToHash(array) {\n\t  var hash = {};\n\t\n\t  array.forEach(function(val, idx) {\n\t    hash[val] = true;\n\t  });\n\t\n\t  return hash;\n\t}\n\t\n\t\n\tfunction formatValue(ctx, value, recurseTimes) {\n\t  // Provide a hook for user-specified inspect functions.\n\t  // Check that value is an object with an inspect function on it\n\t  if (ctx.customInspect &&\n\t      value &&\n\t      isFunction(value.inspect) &&\n\t      // Filter out the util module, it's inspect function is special\n\t      value.inspect !== exports.inspect &&\n\t      // Also filter out any prototype objects using the circular check.\n\t      !(value.constructor && value.constructor.prototype === value)) {\n\t    var ret = value.inspect(recurseTimes, ctx);\n\t    if (!isString(ret)) {\n\t      ret = formatValue(ctx, ret, recurseTimes);\n\t    }\n\t    return ret;\n\t  }\n\t\n\t  // Primitive types cannot have properties\n\t  var primitive = formatPrimitive(ctx, value);\n\t  if (primitive) {\n\t    return primitive;\n\t  }\n\t\n\t  // Look up the keys of the object.\n\t  var keys = Object.keys(value);\n\t  var visibleKeys = arrayToHash(keys);\n\t\n\t  if (ctx.showHidden) {\n\t    keys = Object.getOwnPropertyNames(value);\n\t  }\n\t\n\t  // IE doesn't make error fields non-enumerable\n\t  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n\t  if (isError(value)\n\t      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n\t    return formatError(value);\n\t  }\n\t\n\t  // Some type of object without properties can be shortcutted.\n\t  if (keys.length === 0) {\n\t    if (isFunction(value)) {\n\t      var name = value.name ? ': ' + value.name : '';\n\t      return ctx.stylize('[Function' + name + ']', 'special');\n\t    }\n\t    if (isRegExp(value)) {\n\t      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n\t    }\n\t    if (isDate(value)) {\n\t      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n\t    }\n\t    if (isError(value)) {\n\t      return formatError(value);\n\t    }\n\t  }\n\t\n\t  var base = '', array = false, braces = ['{', '}'];\n\t\n\t  // Make Array say that they are Array\n\t  if (isArray(value)) {\n\t    array = true;\n\t    braces = ['[', ']'];\n\t  }\n\t\n\t  // Make functions say that they are functions\n\t  if (isFunction(value)) {\n\t    var n = value.name ? ': ' + value.name : '';\n\t    base = ' [Function' + n + ']';\n\t  }\n\t\n\t  // Make RegExps say that they are RegExps\n\t  if (isRegExp(value)) {\n\t    base = ' ' + RegExp.prototype.toString.call(value);\n\t  }\n\t\n\t  // Make dates with properties first say the date\n\t  if (isDate(value)) {\n\t    base = ' ' + Date.prototype.toUTCString.call(value);\n\t  }\n\t\n\t  // Make error with message first say the error\n\t  if (isError(value)) {\n\t    base = ' ' + formatError(value);\n\t  }\n\t\n\t  if (keys.length === 0 && (!array || value.length == 0)) {\n\t    return braces[0] + base + braces[1];\n\t  }\n\t\n\t  if (recurseTimes < 0) {\n\t    if (isRegExp(value)) {\n\t      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n\t    } else {\n\t      return ctx.stylize('[Object]', 'special');\n\t    }\n\t  }\n\t\n\t  ctx.seen.push(value);\n\t\n\t  var output;\n\t  if (array) {\n\t    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n\t  } else {\n\t    output = keys.map(function(key) {\n\t      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n\t    });\n\t  }\n\t\n\t  ctx.seen.pop();\n\t\n\t  return reduceToSingleString(output, base, braces);\n\t}\n\t\n\t\n\tfunction formatPrimitive(ctx, value) {\n\t  if (isUndefined(value))\n\t    return ctx.stylize('undefined', 'undefined');\n\t  if (isString(value)) {\n\t    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n\t                                             .replace(/'/g, \"\\\\'\")\n\t                                             .replace(/\\\\\"/g, '\"') + '\\'';\n\t    return ctx.stylize(simple, 'string');\n\t  }\n\t  if (isNumber(value))\n\t    return ctx.stylize('' + value, 'number');\n\t  if (isBoolean(value))\n\t    return ctx.stylize('' + value, 'boolean');\n\t  // For some reason typeof null is \"object\", so special case here.\n\t  if (isNull(value))\n\t    return ctx.stylize('null', 'null');\n\t}\n\t\n\t\n\tfunction formatError(value) {\n\t  return '[' + Error.prototype.toString.call(value) + ']';\n\t}\n\t\n\t\n\tfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n\t  var output = [];\n\t  for (var i = 0, l = value.length; i < l; ++i) {\n\t    if (hasOwnProperty(value, String(i))) {\n\t      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n\t          String(i), true));\n\t    } else {\n\t      output.push('');\n\t    }\n\t  }\n\t  keys.forEach(function(key) {\n\t    if (!key.match(/^\\d+$/)) {\n\t      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n\t          key, true));\n\t    }\n\t  });\n\t  return output;\n\t}\n\t\n\t\n\tfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n\t  var name, str, desc;\n\t  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n\t  if (desc.get) {\n\t    if (desc.set) {\n\t      str = ctx.stylize('[Getter/Setter]', 'special');\n\t    } else {\n\t      str = ctx.stylize('[Getter]', 'special');\n\t    }\n\t  } else {\n\t    if (desc.set) {\n\t      str = ctx.stylize('[Setter]', 'special');\n\t    }\n\t  }\n\t  if (!hasOwnProperty(visibleKeys, key)) {\n\t    name = '[' + key + ']';\n\t  }\n\t  if (!str) {\n\t    if (ctx.seen.indexOf(desc.value) < 0) {\n\t      if (isNull(recurseTimes)) {\n\t        str = formatValue(ctx, desc.value, null);\n\t      } else {\n\t        str = formatValue(ctx, desc.value, recurseTimes - 1);\n\t      }\n\t      if (str.indexOf('\\n') > -1) {\n\t        if (array) {\n\t          str = str.split('\\n').map(function(line) {\n\t            return '  ' + line;\n\t          }).join('\\n').substr(2);\n\t        } else {\n\t          str = '\\n' + str.split('\\n').map(function(line) {\n\t            return '   ' + line;\n\t          }).join('\\n');\n\t        }\n\t      }\n\t    } else {\n\t      str = ctx.stylize('[Circular]', 'special');\n\t    }\n\t  }\n\t  if (isUndefined(name)) {\n\t    if (array && key.match(/^\\d+$/)) {\n\t      return str;\n\t    }\n\t    name = JSON.stringify('' + key);\n\t    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n\t      name = name.substr(1, name.length - 2);\n\t      name = ctx.stylize(name, 'name');\n\t    } else {\n\t      name = name.replace(/'/g, \"\\\\'\")\n\t                 .replace(/\\\\\"/g, '\"')\n\t                 .replace(/(^\"|\"$)/g, \"'\");\n\t      name = ctx.stylize(name, 'string');\n\t    }\n\t  }\n\t\n\t  return name + ': ' + str;\n\t}\n\t\n\t\n\tfunction reduceToSingleString(output, base, braces) {\n\t  var numLinesEst = 0;\n\t  var length = output.reduce(function(prev, cur) {\n\t    numLinesEst++;\n\t    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n\t    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n\t  }, 0);\n\t\n\t  if (length > 60) {\n\t    return braces[0] +\n\t           (base === '' ? '' : base + '\\n ') +\n\t           ' ' +\n\t           output.join(',\\n  ') +\n\t           ' ' +\n\t           braces[1];\n\t  }\n\t\n\t  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n\t}\n\t\n\t\n\t// NOTE: These type checking functions intentionally don't use `instanceof`\n\t// because it is fragile and can be easily faked with `Object.create()`.\n\tfunction isArray(ar) {\n\t  return Array.isArray(ar);\n\t}\n\texports.isArray = isArray;\n\t\n\tfunction isBoolean(arg) {\n\t  return typeof arg === 'boolean';\n\t}\n\texports.isBoolean = isBoolean;\n\t\n\tfunction isNull(arg) {\n\t  return arg === null;\n\t}\n\texports.isNull = isNull;\n\t\n\tfunction isNullOrUndefined(arg) {\n\t  return arg == null;\n\t}\n\texports.isNullOrUndefined = isNullOrUndefined;\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\texports.isNumber = isNumber;\n\t\n\tfunction isString(arg) {\n\t  return typeof arg === 'string';\n\t}\n\texports.isString = isString;\n\t\n\tfunction isSymbol(arg) {\n\t  return typeof arg === 'symbol';\n\t}\n\texports.isSymbol = isSymbol;\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\texports.isUndefined = isUndefined;\n\t\n\tfunction isRegExp(re) {\n\t  return isObject(re) && objectToString(re) === '[object RegExp]';\n\t}\n\texports.isRegExp = isRegExp;\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\texports.isObject = isObject;\n\t\n\tfunction isDate(d) {\n\t  return isObject(d) && objectToString(d) === '[object Date]';\n\t}\n\texports.isDate = isDate;\n\t\n\tfunction isError(e) {\n\t  return isObject(e) &&\n\t      (objectToString(e) === '[object Error]' || e instanceof Error);\n\t}\n\texports.isError = isError;\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\texports.isFunction = isFunction;\n\t\n\tfunction isPrimitive(arg) {\n\t  return arg === null ||\n\t         typeof arg === 'boolean' ||\n\t         typeof arg === 'number' ||\n\t         typeof arg === 'string' ||\n\t         typeof arg === 'symbol' ||  // ES6 symbol\n\t         typeof arg === 'undefined';\n\t}\n\texports.isPrimitive = isPrimitive;\n\t\n\texports.isBuffer = __webpack_require__(23);\n\t\n\tfunction objectToString(o) {\n\t  return Object.prototype.toString.call(o);\n\t}\n\t\n\t\n\tfunction pad(n) {\n\t  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n\t}\n\t\n\t\n\tvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n\t              'Oct', 'Nov', 'Dec'];\n\t\n\t// 26 Feb 16:19:34\n\tfunction timestamp() {\n\t  var d = new Date();\n\t  var time = [pad(d.getHours()),\n\t              pad(d.getMinutes()),\n\t              pad(d.getSeconds())].join(':');\n\t  return [d.getDate(), months[d.getMonth()], time].join(' ');\n\t}\n\t\n\t\n\t// log is just a thin wrapper to console.log that prepends a timestamp\n\texports.log = function() {\n\t  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n\t};\n\t\n\t\n\t/**\n\t * Inherit the prototype methods from one constructor into another.\n\t *\n\t * The Function.prototype.inherits from lang.js rewritten as a standalone\n\t * function (not on Function.prototype). NOTE: If this file is to be loaded\n\t * during bootstrapping this function needs to be rewritten using some native\n\t * functions as prototype setup using normal JavaScript does not work as\n\t * expected during bootstrapping (see mirror.js in r114903).\n\t *\n\t * @param {function} ctor Constructor function which needs to inherit the\n\t *     prototype.\n\t * @param {function} superCtor Constructor function to inherit prototype from.\n\t */\n\texports.inherits = __webpack_require__(22);\n\t\n\texports._extend = function(origin, add) {\n\t  // Don't do anything if add isn't an object\n\t  if (!add || !isObject(add)) return origin;\n\t\n\t  var keys = Object.keys(add);\n\t  var i = keys.length;\n\t  while (i--) {\n\t    origin[keys[i]] = add[keys[i]];\n\t  }\n\t  return origin;\n\t};\n\t\n\tfunction hasOwnProperty(obj, prop) {\n\t  return Object.prototype.hasOwnProperty.call(obj, prop);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(11)))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      } else {\n\t        // At least give some kind of context to the user\n\t        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t        err.context = er;\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar util = __webpack_require__(2);\n\t\n\tvar errors = {};\n\tmodule.exports = errors;\n\t\n\t// Standard protocol errors\n\t\n\terrors.ERR_APP_NOT_FOUND = 10;\n\terrors.ERR_AUTH_FAILED = 11;\n\terrors.ERR_INTERFACE_NOT_FOUND = 12;\n\terrors.ERR_INTERFACE_INCOMPATIBLE = 13;\n\terrors.ERR_METHOD_NOT_FOUND = 14;\n\terrors.ERR_NOT_A_SERVER = 15;\n\terrors.ERR_INTERNAL_API_ERROR = 16;\n\t\n\t// JSTP remote error class\n\t// TODO: implement RPC stacktrace\n\t//   code - error code\n\t//   message - optional error message\n\t//\n\tfunction RemoteError(code, message) {\n\t  if (Error.captureStackTrace) {\n\t    Error.captureStackTrace(this, RemoteError);\n\t  } else {\n\t    this.stack = new Error(message).stack;\n\t  }\n\t\n\t  this.message = message ||\n\t    RemoteError.defaultMessages[code] ||\n\t    code.toString();\n\t\n\t  this.code = code;\n\t}\n\t\n\tutil.inherits(RemoteError, Error);\n\terrors.RemoteError = RemoteError;\n\t\n\tRemoteError.prototype.name = 'RemoteError';\n\t\n\t// Convert a RemoteError instance to array representing an error in JSTP\n\t// packets\n\t//\n\tRemoteError.prototype.toJstpArray = function() {\n\t  var isMessagePresent = this.message && this.message !== this.code.toString();\n\t  var isMessageStandard = RemoteError.defaultMessages.hasOwnProperty(this.code);\n\t\n\t  if (isMessagePresent && !isMessageStandard) {\n\t    return [this.code, this.message];\n\t  } else {\n\t    return [this.code];\n\t  }\n\t};\n\t\n\t// Factory method that creates a RemoteError instance from a JSTP array\n\t//   array - array in the form of [code, description]\n\t//\n\tRemoteError.fromJstpArray = function(array) {\n\t  return new RemoteError(array[0], array[1]);\n\t};\n\t\n\t// Prepare an error to be sent in a JSTP packet\n\t//   error - an error to prepare (instance of Error, RemoteError, a string or\n\t//           a regular JavaScript array of error code and error description)\n\t//\n\tRemoteError.getJstpArrayFor = function(error) {\n\t  if (error instanceof RemoteError) {\n\t    return error.toJstpArray();\n\t  } else if (Array.isArray(error)) {\n\t    return error;\n\t  } else if (typeof(error) === 'number') {\n\t    return [error];\n\t  } else if (typeof(error) === 'string') {\n\t    return [0, error];\n\t  } else {\n\t    return [0, error.toString()];\n\t  }\n\t};\n\t\n\t// Default messages for predefined error codes\n\t//\n\tRemoteError.defaultMessages = { };\n\t\n\tRemoteError.defaultMessages[errors.ERR_APP_NOT_FOUND] =\n\t  'Application not found';\n\t\n\tRemoteError.defaultMessages[errors.ERR_AUTH_FAILED] =\n\t  'Authentication failed';\n\t\n\tRemoteError.defaultMessages[errors.ERR_INTERFACE_NOT_FOUND] =\n\t  'Interface not found';\n\t\n\tRemoteError.defaultMessages[errors.ERR_INTERFACE_INCOMPATIBLE] =\n\t  'Incompatible interface';\n\t\n\tRemoteError.defaultMessages[errors.ERR_METHOD_NOT_FOUND] =\n\t  'Method not found';\n\t\n\tRemoteError.defaultMessages[errors.ERR_NOT_A_SERVER] =\n\t  'Not a server';\n\t\n\tRemoteError.defaultMessages[errors.ERR_INTERNAL_API_ERROR] =\n\t  'Internal API error';\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\t\n\t'use strict'\n\t\n\tvar base64 = __webpack_require__(17)\n\tvar ieee754 = __webpack_require__(18)\n\tvar isArray = __webpack_require__(20)\n\t\n\texports.Buffer = Buffer\n\texports.SlowBuffer = SlowBuffer\n\texports.INSPECT_MAX_BYTES = 50\n\t\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\t\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global.TYPED_ARRAY_SUPPORT\n\t  : typedArraySupport()\n\t\n\t/*\n\t * Export kMaxLength after typed array support is determined.\n\t */\n\texports.kMaxLength = kMaxLength()\n\t\n\tfunction typedArraySupport () {\n\t  try {\n\t    var arr = new Uint8Array(1)\n\t    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\t\n\tfunction createBuffer (that, length) {\n\t  if (kMaxLength() < length) {\n\t    throw new RangeError('Invalid typed array length')\n\t  }\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = new Uint8Array(length)\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    if (that === null) {\n\t      that = new Buffer(length)\n\t    }\n\t    that.length = length\n\t  }\n\t\n\t  return that\n\t}\n\t\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\t\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n\t    return new Buffer(arg, encodingOrOffset, length)\n\t  }\n\t\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new Error(\n\t        'If encoding is specified then the first argument must be a string'\n\t      )\n\t    }\n\t    return allocUnsafe(this, arg)\n\t  }\n\t  return from(this, arg, encodingOrOffset, length)\n\t}\n\t\n\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\t// TODO: Legacy, not needed anymore. Remove in next major version.\n\tBuffer._augment = function (arr) {\n\t  arr.__proto__ = Buffer.prototype\n\t  return arr\n\t}\n\t\n\tfunction from (that, value, encodingOrOffset, length) {\n\t  if (typeof value === 'number') {\n\t    throw new TypeError('\"value\" argument must not be a number')\n\t  }\n\t\n\t  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n\t    return fromArrayBuffer(that, value, encodingOrOffset, length)\n\t  }\n\t\n\t  if (typeof value === 'string') {\n\t    return fromString(that, value, encodingOrOffset)\n\t  }\n\t\n\t  return fromObject(that, value)\n\t}\n\t\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(null, value, encodingOrOffset, length)\n\t}\n\t\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t  Buffer.__proto__ = Uint8Array\n\t  if (typeof Symbol !== 'undefined' && Symbol.species &&\n\t      Buffer[Symbol.species] === Buffer) {\n\t    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n\t    Object.defineProperty(Buffer, Symbol.species, {\n\t      value: null,\n\t      configurable: true\n\t    })\n\t  }\n\t}\n\t\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be a number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('\"size\" argument must not be negative')\n\t  }\n\t}\n\t\n\tfunction alloc (that, size, fill, encoding) {\n\t  assertSize(size)\n\t  if (size <= 0) {\n\t    return createBuffer(that, size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpretted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(that, size).fill(fill, encoding)\n\t      : createBuffer(that, size).fill(fill)\n\t  }\n\t  return createBuffer(that, size)\n\t}\n\t\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(null, size, fill, encoding)\n\t}\n\t\n\tfunction allocUnsafe (that, size) {\n\t  assertSize(size)\n\t  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < size; ++i) {\n\t      that[i] = 0\n\t    }\n\t  }\n\t  return that\n\t}\n\t\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8'\n\t  }\n\t\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('\"encoding\" must be a valid string encoding')\n\t  }\n\t\n\t  var length = byteLength(string, encoding) | 0\n\t  that = createBuffer(that, length)\n\t\n\t  var actual = that.write(string, encoding)\n\t\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    that = that.slice(0, actual)\n\t  }\n\t\n\t  return that\n\t}\n\t\n\tfunction fromArrayLike (that, array) {\n\t  var length = array.length < 0 ? 0 : checked(array.length) | 0\n\t  that = createBuffer(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayBuffer (that, array, byteOffset, length) {\n\t  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\t\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\\'offset\\' is out of bounds')\n\t  }\n\t\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\\'length\\' is out of bounds')\n\t  }\n\t\n\t  if (byteOffset === undefined && length === undefined) {\n\t    array = new Uint8Array(array)\n\t  } else if (length === undefined) {\n\t    array = new Uint8Array(array, byteOffset)\n\t  } else {\n\t    array = new Uint8Array(array, byteOffset, length)\n\t  }\n\t\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = array\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromArrayLike(that, array)\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromObject (that, obj) {\n\t  if (Buffer.isBuffer(obj)) {\n\t    var len = checked(obj.length) | 0\n\t    that = createBuffer(that, len)\n\t\n\t    if (that.length === 0) {\n\t      return that\n\t    }\n\t\n\t    obj.copy(that, 0, 0, len)\n\t    return that\n\t  }\n\t\n\t  if (obj) {\n\t    if ((typeof ArrayBuffer !== 'undefined' &&\n\t        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n\t      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n\t        return createBuffer(that, 0)\n\t      }\n\t      return fromArrayLike(that, obj)\n\t    }\n\t\n\t    if (obj.type === 'Buffer' && isArray(obj.data)) {\n\t      return fromArrayLike(that, obj.data)\n\t    }\n\t  }\n\t\n\t  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n\t}\n\t\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength()` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\t\n\tfunction SlowBuffer (length) {\n\t  if (+length != length) { // eslint-disable-line eqeqeq\n\t    length = 0\n\t  }\n\t  return Buffer.alloc(+length)\n\t}\n\t\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\t\n\tBuffer.compare = function compare (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\t\n\t  if (a === b) return 0\n\t\n\t  var x = a.length\n\t  var y = b.length\n\t\n\t  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i]\n\t      y = b[i]\n\t      break\n\t    }\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\t\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\t\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\t\n\t  var i\n\t  if (length === undefined) {\n\t    length = 0\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length\n\t    }\n\t  }\n\t\n\t  var buffer = Buffer.allocUnsafe(length)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; ++i) {\n\t    var buf = list[i]\n\t    if (!Buffer.isBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    }\n\t    buf.copy(buffer, pos)\n\t    pos += buf.length\n\t  }\n\t  return buffer\n\t}\n\t\n\tfunction byteLength (string, encoding) {\n\t  if (Buffer.isBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n\t      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    string = '' + string\n\t  }\n\t\n\t  var len = string.length\n\t  if (len === 0) return 0\n\t\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t      case undefined:\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength\n\t\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false\n\t\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\t\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\t\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length\n\t  }\n\t\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\t\n\t  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0\n\t  start >>>= 0\n\t\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\t\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\t\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\t\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\t// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n\t// Buffer instances.\n\tBuffer.prototype._isBuffer = true\n\t\n\tfunction swap (b, n, m) {\n\t  var i = b[n]\n\t  b[n] = b[m]\n\t  b[m] = i\n\t}\n\t\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  var len = this.length\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  var len = this.length\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3)\n\t    swap(this, i + 1, i + 2)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  var len = this.length\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7)\n\t    swap(this, i + 1, i + 6)\n\t    swap(this, i + 2, i + 5)\n\t    swap(this, i + 3, i + 4)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t}\n\t\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t}\n\t\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max) str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\t\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (!Buffer.isBuffer(target)) {\n\t    throw new TypeError('Argument must be a Buffer')\n\t  }\n\t\n\t  if (start === undefined) {\n\t    start = 0\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length\n\t  }\n\t\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\t\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\t\n\t  start >>>= 0\n\t  end >>>= 0\n\t  thisStart >>>= 0\n\t  thisEnd >>>= 0\n\t\n\t  if (this === target) return 0\n\t\n\t  var x = thisEnd - thisStart\n\t  var y = end - start\n\t  var len = Math.min(x, y)\n\t\n\t  var thisCopy = this.slice(thisStart, thisEnd)\n\t  var targetCopy = target.slice(start, end)\n\t\n\t  for (var i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i]\n\t      y = targetCopy[i]\n\t      break\n\t    }\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\t\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset\n\t    byteOffset = 0\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000\n\t  }\n\t  byteOffset = +byteOffset  // Coerce to Number.\n\t  if (isNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1)\n\t  }\n\t\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0\n\t    else return -1\n\t  }\n\t\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding)\n\t  }\n\t\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (Buffer.isBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF // Search for a byte value [0-255]\n\t    if (Buffer.TYPED_ARRAY_SUPPORT &&\n\t        typeof Uint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n\t  }\n\t\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\t\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  var indexSize = 1\n\t  var arrLength = arr.length\n\t  var valLength = val.length\n\t\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase()\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2\n\t      arrLength /= 2\n\t      valLength /= 2\n\t      byteOffset /= 2\n\t    }\n\t  }\n\t\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\t\n\t  var i\n\t  if (dir) {\n\t    var foundIndex = -1\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex\n\t        foundIndex = -1\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      var found = true\n\t      for (var j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\t\n\t  return -1\n\t}\n\t\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t}\n\t\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t}\n\t\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t}\n\t\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\t\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; ++i) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(parsed)) return i\n\t    buf[offset + i] = parsed\n\t  }\n\t  return i\n\t}\n\t\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction latin1Write (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\t\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0\n\t    if (isFinite(length)) {\n\t      length = length | 0\n\t      if (encoding === undefined) encoding = 'utf8'\n\t    } else {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\t\n\t  var remaining = this.length - offset\n\t  if (length === undefined || length > remaining) length = remaining\n\t\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\t\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\t\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Write(this, string, offset, length)\n\t\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\t\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\t\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end)\n\t  var res = []\n\t\n\t  var i = start\n\t  while (i < end) {\n\t    var firstByte = buf[i]\n\t    var codePoint = null\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1\n\t\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\t\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1]\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          fourthByte = buf[i + 3]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t      }\n\t    }\n\t\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD\n\t      bytesPerSequence = 1\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t    }\n\t\n\t    res.push(codePoint)\n\t    i += bytesPerSequence\n\t  }\n\t\n\t  return decodeCodePointsArray(res)\n\t}\n\t\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\t\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\t\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = ''\n\t  var i = 0\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    )\n\t  }\n\t  return res\n\t}\n\t\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction latin1Slice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\t\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\t\n\t  var out = ''\n\t  for (var i = start; i < end; ++i) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\t\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\t\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\t\n\t  if (start < 0) {\n\t    start += len\n\t    if (start < 0) start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\t\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0) end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\t\n\t  if (end < start) end = start\n\t\n\t  var newBuf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = this.subarray(start, end)\n\t    newBuf.__proto__ = Buffer.prototype\n\t  } else {\n\t    var sliceLen = end - start\n\t    newBuf = new Buffer(sliceLen, undefined)\n\t    for (var i = 0; i < sliceLen; ++i) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t  }\n\t\n\t  return newBuf\n\t}\n\t\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\t\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length)\n\t  }\n\t\n\t  var val = this[offset + --byteLength]\n\t  var mul = 1\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\t\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\t\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\t\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\t\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var i = byteLength\n\t  var mul = 1\n\t  var val = this[offset + --i]\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\t\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t}\n\t\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\t\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\t\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\t\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\t\n\t  var mul = 1\n\t  var i = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = 0\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\t\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\t\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\t\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\t\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (targetStart >= target.length) targetStart = target.length\n\t  if (!targetStart) targetStart = 0\n\t  if (end > 0 && end < start) end = start\n\t\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\t\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\t\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\t\n\t  var len = end - start\n\t  var i\n\t\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; --i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; ++i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else {\n\t    Uint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, start + len),\n\t      targetStart\n\t    )\n\t  }\n\t\n\t  return len\n\t}\n\t\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start\n\t      start = 0\n\t      end = this.length\n\t    } else if (typeof end === 'string') {\n\t      encoding = end\n\t      end = this.length\n\t    }\n\t    if (val.length === 1) {\n\t      var code = val.charCodeAt(0)\n\t      if (code < 256) {\n\t        val = code\n\t      }\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255\n\t  }\n\t\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\t\n\t  if (end <= start) {\n\t    return this\n\t  }\n\t\n\t  start = start >>> 0\n\t  end = end === undefined ? this.length : end >>> 0\n\t\n\t  if (!val) val = 0\n\t\n\t  var i\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val\n\t    }\n\t  } else {\n\t    var bytes = Buffer.isBuffer(val)\n\t      ? val\n\t      : utf8ToBytes(new Buffer(val, encoding).toString())\n\t    var len = bytes.length\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len]\n\t    }\n\t  }\n\t\n\t  return this\n\t}\n\t\n\t// HELPER FUNCTIONS\n\t// ================\n\t\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\t\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\t\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\t\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\t\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity\n\t  var codePoint\n\t  var length = string.length\n\t  var leadSurrogate = null\n\t  var bytes = []\n\t\n\t  for (var i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i)\n\t\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        }\n\t\n\t        // valid lead\n\t        leadSurrogate = codePoint\n\t\n\t        continue\n\t      }\n\t\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t        leadSurrogate = codePoint\n\t        continue\n\t      }\n\t\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t    }\n\t\n\t    leadSurrogate = null\n\t\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint)\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\t\n\t  return bytes\n\t}\n\t\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\t\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\t\n\t  return byteArray\n\t}\n\t\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\t\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\t\n\tfunction isnan (val) {\n\t  return val !== val // eslint-disable-line no-self-compare\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer, (function() { return this; }())))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(11).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\t\n\t  immediateIds[id] = true;\n\t\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\t\n\t  return id;\n\t};\n\t\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).setImmediate, __webpack_require__(6).clearImmediate))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar events = __webpack_require__(3);\n\tvar timers = __webpack_require__(6);\n\tvar util = __webpack_require__(2);\n\t\n\tvar jsrs = __webpack_require__(8);\n\tvar common = __webpack_require__(1);\n\tvar errors = __webpack_require__(4);\n\tvar RemoteProxy = __webpack_require__(9);\n\t\n\tmodule.exports = Connection;\n\t\n\tvar nextConnectionId = 0;\n\t\n\t// JSTP connection class\n\t//   transport - an abstract socket\n\t//   server - JSTP server instance, used only for server-side parts\n\t//            of connections (optional, but either server or client\n\t//            is required)\n\t//   client - JSTP client instance, used only for client-side parts\n\t//            of connections (optional, but either server or client\n\t//            is required)\n\t//\n\tfunction Connection(transport, server, client) {\n\t  events.EventEmitter.call(this);\n\t\n\t  this.transport = transport;\n\t  this.server = server;\n\t  this.client = client;\n\t\n\t  this.id = nextConnectionId++;\n\t  this._nextPacketId = 0;\n\t\n\t  if (server && !client) {\n\t    this._packetIdDelta = -1;\n\t  } else if (client && !server) {\n\t    this._packetIdDelta = 1;\n\t  } else {\n\t    throw new Error('Either server or client is required');\n\t  }\n\t\n\t  this.remoteAddress = transport.getRemoteAddress();\n\t\n\t  this._callbacks = {};\n\t\n\t  this.handshakeDone = false;\n\t  this.authenticated = false;\n\t  this.sessionId = null;\n\t\n\t  this.application = null;\n\t  this.remoteProxies = {};\n\t\n\t  transport.on('data', this._onSocketData.bind(this));\n\t  transport.on('close', this._onSocketClose.bind(this));\n\t  transport.on('error', this._onSocketError.bind(this));\n\t}\n\t\n\tutil.inherits(Connection, events.EventEmitter);\n\t\n\t// Send a call packet over the connection\n\t//   interfaceName - name of an interface\n\t//   methodName - name of a method\n\t//   args - method arguments\n\t//   callback - callback function that is invoked after a callback packet\n\t//              has been received\n\t//\n\tConnection.prototype.callMethod =\n\t  function(interfaceName, methodName, args, callback) {\n\t    var packet = this.createPacket('call', interfaceName, methodName, args);\n\t\n\t    if (callback) {\n\t      var packetId = packet.call[0];\n\t      this._callbacks[packetId] = callback;\n\t    }\n\t\n\t    this._send(packet);\n\t  };\n\t\n\t// Send a callback packet over the connection\n\t//   packetId - id of a call packet to send callback packet for\n\t//   error - error that has occured or null\n\t//   result - result of a remote method if there was no error\n\t//\n\tConnection.prototype.callback = function(packetId, error, result) {\n\t  var packet;\n\t\n\t  if (error) {\n\t    error = errors.RemoteError.getJstpArrayFor(error);\n\t    packet = this.createPacket('callback', null, 'error', error);\n\t  } else {\n\t    packet = this.createPacket('callback', null, 'ok', result);\n\t  }\n\t\n\t  packet.callback[0] = packetId;\n\t\n\t  this._send(packet);\n\t};\n\t\n\t// Send an event packet over the connection\n\t//   interfaceName - name of an interface\n\t//   eventName - name of an event\n\t//   args - event arguments as an object\n\t//\n\tConnection.prototype.emitRemoteEvent =\n\t  function(interfaceName, eventName, args) {\n\t    var packet = this.createPacket('event', interfaceName, eventName, args);\n\t    this._send(packet);\n\t  };\n\t\n\t// Send a state synchronization packet over the connection\n\t//   path - path to a value in the application state\n\t//   verb - operation with this value (inc, dec, let, delete, push, pop, shift,\n\t//          unshift)\n\t//   value - a value to modify the current value with\n\t//\n\tConnection.prototype.notifyStateChange = function(path, verb, value) {\n\t  var packet = this.createPacket('state', path, verb, value);\n\t  this._send(packet);\n\t};\n\t\n\t// Send a handshake packet over the connection\n\t//   appName - name of an application to connect to\n\t//   login - user name (optional)\n\t//   password - user password (optional)\n\t//   callback - callback function to invoke after the handshake is completed\n\t//\n\tConnection.prototype.handshake = function(appName, login, password, callback) {\n\t  var packet = this.createPacket('handshake', appName, login, password);\n\t\n\t  if (callback) {\n\t    var packetId = packet.handshake[0];\n\t    var self = this;\n\t\n\t    this._callbacks[packetId] = function(error, sessionId) {\n\t      if (login && password && !error) {\n\t        self.authenticated = true;\n\t      }\n\t\n\t      callback(error, sessionId);\n\t    };\n\t  }\n\t\n\t  this._send(packet);\n\t};\n\t\n\t// Send an inspect packet over the connection\n\t//   interfaceName - name of an interface to inspect\n\t//   callback - callback function to invoke after another side responds\n\t//              with interface introspection\n\t//\n\tConnection.prototype.inspectInterface = function(interfaceName, callback) {\n\t  var packet = this.createPacket('inspect', interfaceName, null, null);\n\t  var packetId = packet.inspect[0];\n\t  var self = this;\n\t\n\t  this._callbacks[packetId] = function(error) {\n\t    if (error) {\n\t      return callback(error);\n\t    }\n\t\n\t    var methods = Array.prototype.slice.call(arguments, 1);\n\t    var proxy = new RemoteProxy(this, interfaceName, methods);\n\t\n\t    self.remoteProxies[interfaceName] = proxy;\n\t\n\t    if (callback) {\n\t      callback(null, proxy);\n\t    }\n\t  };\n\t\n\t  this._send(packet);\n\t};\n\t\n\t// Create a JSTP packet\n\t//   kind - packet kind\n\t//   target - name of an interface or an application (optional)\n\t//   verb - action specific for different packet kinds\n\t//   args - action arguments\n\t//\n\tConnection.prototype.createPacket = function(kind, target, verb, args) {\n\t  var packet = {};\n\t\n\t  packet[kind] = target ?\n\t    [this._nextPacketId, target] :\n\t    [this._nextPacketId];\n\t\n\t  if (verb) {\n\t    packet[verb] = args;\n\t  }\n\t\n\t  this._nextPacketId += this._packetIdDelta;\n\t\n\t  return packet;\n\t};\n\t\n\t// Close the connection\n\t//\n\tConnection.prototype.close = function() {\n\t  this.transport.end();\n\t};\n\t\n\t// Set a timeout using timers.enroll()\n\t//   milliseconds - amount of milliseconds\n\t//   callback - callback function\n\t//\n\tConnection.prototype.setTimeout = function(milliseconds, callback) {\n\t  timers.enroll(this, milliseconds);\n\t  timers._unrefActive(this);\n\t\n\t  this.once('_timeout', callback);\n\t};\n\t\n\t// timers.enroll() timeout handler\n\t//\n\tConnection.prototype._onTimeout = function() {\n\t  this.emit('_timeout');\n\t};\n\t\n\t// Send a JSTP packet over this connection\n\t//   packet - a packet to send\n\t//\n\tConnection.prototype._send = function(packet) {\n\t  var data = jsrs.stringify(packet);\n\t  this.transport.send(data);\n\t};\n\t\n\t// Close the connection, optionally sending a final packet\n\t//   packet - a packet to send (optional)\n\t//\n\tConnection.prototype._end = function(packet) {\n\t  if (packet) {\n\t    var data = jsrs.stringify(packet);\n\t    this.transport.end(data);\n\t  } else {\n\t    this.transport.end();\n\t  }\n\t};\n\t\n\t// Incoming data event handler\n\t//   data - data to process\n\t//\n\tConnection.prototype._onSocketData = function(data) {\n\t  this.emit('data', data);\n\t\n\t  var packets = jsrs.parse(data);\n\t  this._processPackets(packets);\n\t};\n\t\n\t// Closed socket event handler\n\t//\n\tConnection.prototype._onSocketClose = function() {\n\t  this.emit('close', this);\n\t\n\t  if (this.server) {\n\t    this.server.emit('disconnect', this);\n\t  }\n\t};\n\t\n\t// Socket error event handler\n\t//   error - error that has occured\n\t//\n\tConnection.prototype._onSocketError = function(error) {\n\t  this.emit('error', error, this);\n\t};\n\t\n\t// Process parsed incoming packets\n\t//   packets - array of packets\n\t//\n\tConnection.prototype._processPackets = function(packets) {\n\t  for (var index = 0; index < packets.length; index++) {\n\t    var packet = packets[index];\n\t    this.emit('packet', packet, this);\n\t\n\t    var keys = Object.keys(packet);\n\t    var kind = keys[0];\n\t\n\t    if (!this.handshakeDone && kind !== 'handshake') {\n\t      this._rejectPacket(packet, true);\n\t      return;\n\t    }\n\t\n\t    var handler = Connection.PACKET_HANDLER_NAMES[kind];\n\t    if (handler) {\n\t      this[handler](packet, keys);\n\t    } else {\n\t      this._rejectPacket(packet);\n\t    }\n\t  }\n\t};\n\t\n\t// Reject incoming packet\n\t//   packet - rejected packet\n\t//   fatal - if true, close the connection\n\t//\n\tConnection.prototype._rejectPacket = function(packet, fatal) {\n\t  this.emit('packetRejected', packet, this);\n\t\n\t  if (fatal) {\n\t    this._end();\n\t  }\n\t};\n\t\n\t// Process incoming handshake packet\n\t//   packet - parsed packet\n\t//   keys - array of packet keys\n\t//\n\tConnection.prototype._processHandshakePacket = function(packet, keys) {\n\t  if (this.handshakeDone) {\n\t    this.emit('abundantHandshake', packet, this);\n\t    return;\n\t  }\n\t\n\t  if (packet.handshake[1]) {  // if there is an application name\n\t    this._processHandshakeRequest(packet, keys);\n\t  } else {\n\t    this._processHandshakeResponse(packet, keys);\n\t  }\n\t};\n\t\n\t// Process incoming handshake packet which is a handshake request\n\t//   packet - parsed packet\n\t//   keys - array of packet keys\n\t//\n\tConnection.prototype._processHandshakeRequest = function(packet, keys) {\n\t  if (!this.server) {\n\t    this._handshakeError(errors.ERR_NOT_A_SERVER);\n\t    return;\n\t  }\n\t\n\t  var applicationName = packet.handshake[1];\n\t  var application = this.server.getApplication(applicationName);\n\t\n\t  if (!application) {\n\t    this._handshakeError(errors.ERR_APP_NOT_FOUND);\n\t    return;\n\t  }\n\t\n\t  this.application = application;\n\t\n\t  var username = keys[1];\n\t  var password = packet[username];\n\t\n\t  this._emitPacketEvent('handshakeRequest', packet, packet.handshake[0], {\n\t    packetType: 'handshake',\n\t    handshakeRequest: true,\n\t    username: username,\n\t    password: password\n\t  });\n\t\n\t  if (username) {\n\t    this.server.startAuthenticatedSession(this, application,\n\t      username, password, this._onAuthenticatedSessionCreated.bind(this));\n\t  } else {\n\t    this.server.startAnonymousSession(this, application,\n\t      this._onSessionCreated.bind(this));\n\t  }\n\t};\n\t\n\t// Callback of authentication operation. This function is passed to\n\t// startAuthenticatedSession and startAnonymousSession functions (wrapped into\n\t// onAuthenticatedSessionCreated or directly respectively) of the\n\t// authentication service injected into JSTP server as a dependency as a\n\t// callback function since these operations may be (and most probably will be)\n\t// asynchronous.\n\t//   error - error that has occured or null\n\t//   sessionId - session id or hash\n\t//\n\tConnection.prototype._onSessionCreated = function(error, sessionId) {\n\t  if (error) {\n\t    this._handshakeError(errors.ERR_AUTH_FAILED);\n\t    return;\n\t  }\n\t\n\t  this.handshakeDone = true;\n\t\n\t  this.emit('client', sessionId, this);\n\t  this.server.emit('connect', this);\n\t\n\t  var packet = this.createPacket('handshake', null, 'ok', sessionId);\n\t  this._send(packet);\n\t};\n\t\n\t// onSessionCreated wrapper for authenticated connections\n\t//   error - error that has occured or null\n\t//   sessionId - session id or hash\n\t//\n\tConnection.prototype._onAuthenticatedSessionCreated =\n\t  function(error, sessionId) {\n\t    if (!error) {\n\t      this.authenticated = true;\n\t    }\n\t\n\t    this._onSessionCreated(error, sessionId);\n\t  };\n\t\n\t// Process incoming handshake packet which is a handshake response\n\t//   packet - parsed packet\n\t//\n\tConnection.prototype._processHandshakeResponse = function(packet) {\n\t  var packetId = packet.handshake[0];\n\t  var callback = this._callbacks[packetId];\n\t\n\t  if (!callback) {\n\t    this._rejectPacket(packet);\n\t  }\n\t\n\t  if (packet.ok) {\n\t    delete this._callbacks[packetId];\n\t\n\t    this.handshakeDone = true;\n\t    this.application = this.client.getApplication();\n\t    this._emitPacketEvent('handshake', packet, packetId, {\n\t      sessionId: packet.ok\n\t    });\n\t\n\t    callback(null, packet.ok);\n\t  } else if (packet.error) {\n\t    delete this._callbacks[packetId];\n\t    callback(errors.RemoteError.fromJstpArray(packet.error));\n\t  } else {\n\t    this._rejectPacket(packet, true);\n\t  }\n\t};\n\t\n\t// End the connection with handshake error\n\t//   error - error that has occured\n\t//\n\tConnection.prototype._handshakeError = function(error) {\n\t  var normalizedError = errors.RemoteError.getJstpArrayFor(error);\n\t  var packet = this.createPacket('handshake', null, 'error', normalizedError);\n\t\n\t  this._end(packet);\n\t};\n\t\n\t// Process incoming call packet\n\t//   packet - parsed packet\n\t//   keys - array of packet keys\n\t//\n\tConnection.prototype._processCallPacket = function(packet, keys) {\n\t  var packetId = packet.call[0];\n\t  var interfaceName = packet.call[1];\n\t  var methodName = keys[1];\n\t  var args = packet[methodName];\n\t\n\t  this._emitPacketEvent('call', packet, packetId, {\n\t    interfaceName: interfaceName,\n\t    methodName: methodName\n\t  });\n\t\n\t  var callback = this._remoteCallbackWrapper.bind(this, packetId);\n\t  args.push(callback);\n\t\n\t  try {\n\t    this.application.callMethod(this, interfaceName, methodName, args);\n\t  } catch (error) {\n\t    if (error instanceof errors.RemoteError) {\n\t      callback(error);\n\t    } else {\n\t      callback(errors.ERR_INTERNAL_API_ERROR);\n\t      throw error;\n\t    }\n\t  }\n\t};\n\t\n\t// Process incoming callback packet\n\t//   packet - parsed packet\n\t//\n\tConnection.prototype._processCallbackPacket = function(packet) {\n\t  var packetId = packet.callback[0];\n\t  var callback = this._callbacks[packetId];\n\t\n\t  if (callback) {\n\t    delete this._callbacks[packetId];\n\t\n\t    if (packet.ok) {\n\t      callback.apply(this, [null].concat(packet.ok));\n\t    } else if (packet.error) {\n\t      callback(errors.RemoteError.fromJstpArray(packet.error));\n\t    } else {\n\t      this._rejectPacket(packet);\n\t    }\n\t  }\n\t\n\t  var eventArgs = callback ?\n\t    null :\n\t    { sourcePacketUnknown: true };\n\t\n\t  this._emitPacketEvent('callback', packet, packetId, eventArgs);\n\t\n\t  if (!callback) {\n\t    this.emit('callbackForUnknownPacket', packetId, packet, this);\n\t  }\n\t};\n\t\n\t// Process incoming event packet\n\t//   packet - parsed packet\n\t//   keys - array of packet keys\n\t//\n\tConnection.prototype._processEventPacket = function(packet, keys) {\n\t  var interfaceName = packet.event[1];\n\t  var eventName = keys[1];\n\t  var eventArgs = packet[eventName];\n\t\n\t  this._emitPacketEvent('event', packet, packet.event[0], {\n\t    interfaceName: interfaceName,\n\t    remoteEventName: eventName,\n\t    remoteEventArgs: eventArgs\n\t  });\n\t\n\t  var remoteProxy = this.remoteProxies[interfaceName];\n\t  if (remoteProxy) {\n\t    remoteProxy.emit(eventName, eventArgs, true);\n\t  }\n\t};\n\t\n\t// Process incoming inspect packet\n\t//   packet - parsed packet\n\t//\n\tConnection.prototype._processInspectPacket = function(packet) {\n\t  var packetId = packet.inspect[0];\n\t  var interfaceName = packet.inspect[1];\n\t\n\t  this._emitPacketEvent('inspect', packet, packetId, {\n\t    interfaceName: interfaceName\n\t  });\n\t\n\t  var methods = this.application.getMethods(interfaceName);\n\t  if (methods) {\n\t    this.callback(packetId, null, methods);\n\t  } else {\n\t    this.callback(packetId, errors.ERR_INTERFACE_NOT_FOUND);\n\t  }\n\t};\n\t\n\t// Process incoming state packet\n\t//   packet - parsed packet\n\t//\n\tConnection.prototype._processStatePacket = function(packet, keys) {\n\t  var path = packet.state[1];\n\t  var verb = keys[1];\n\t  var value = packet[verb];\n\t\n\t  this._emitPacketEvent('state', packet, packet.state[0], {\n\t    path: path,\n\t    verb: verb,\n\t    value: value\n\t  });\n\t};\n\t\n\t// Callback of functions invoked via call packets\n\t// Signature: Connection#_remoteCallbackWrapper(packetId, error, ...result)\n\t//   packetId - id of a packet to send callback for\n\t//   error - error that has occured, if any\n\t//   result - data to send back as a result\n\t//\n\tConnection.prototype._remoteCallbackWrapper = function(packetId, error) {\n\t  var result = Array.prototype.slice.call(arguments, 2);\n\t  this.callback(packetId, error, result);\n\t};\n\t\n\t// Emit an event notifying about incoming packet. The event payload is an\n\t// object that contains information about the connection, application, packet,\n\t// packet type, packet ID and any additional data that you pass to this\n\t// function.\n\t//   kind - packet type and event name\n\t//   packet - parsed packet\n\t//   packetId - packet ID\n\t//   args - additional event arguments (optional)\n\t//\n\tConnection.prototype._emitPacketEvent = function(kind, packet, packetId, args) {\n\t  var eventArgs = {\n\t    connection: this,\n\t    packetType: kind,\n\t    packet: packet,\n\t    packetId: packetId,\n\t    application: this.application\n\t  };\n\t\n\t  if (args) {\n\t    common.extend(eventArgs, args);\n\t  }\n\t\n\t  this.emit(kind, eventArgs);\n\t};\n\t\n\t// Mapping of packet types to handler function names\n\t//\n\tConnection.PACKET_HANDLER_NAMES = {\n\t  handshake: '_processHandshakePacket',\n\t  call: '_processCallPacket',\n\t  callback: '_processCallbackPacket',\n\t  event: '_processEventPacket',\n\t  inspect: '_processInspectPacket',\n\t  state: '_processStatePacket'\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* eslint-env shared-node-browser, commonjs */\n\t'use strict';\n\t\n\tvar serializerFactory = __webpack_require__(10);\n\t\n\tvar jsrs = {};\n\tmodule.exports = jsrs;\n\t\n\t// Serialize a JavaScript value using the JSTP Record Serialization format\n\t// and return a string representing it.\n\t//\n\tjsrs.stringify = serializerFactory.createSerializer();\n\t\n\t// Deserialize a string in the JSTP Record Serialization format into\n\t// a JavaScript value and return it.\n\t//   string - a string to parse\n\t//\n\tjsrs.parse = function parse(string) {\n\t  var parser = new JsrsParser(string);\n\t  return parser.parse();\n\t};\n\t\n\t// Internal JSRS parser class\n\t//   string - a string to parse\n\t//\n\tfunction JsrsParser(string) {\n\t  this.string = string;\n\t  this.lookaheadIndex = 0;\n\t}\n\t\n\t// Start parsing\n\t//\n\tJsrsParser.prototype.parse = function() {\n\t  var value = this.parseValue();\n\t\n\t  this.skipClutter();\n\t  if (this.lookaheadIndex < this.string.length) {\n\t    this.throwUnexpected();\n\t  }\n\t\n\t  return value;\n\t};\n\t\n\t// Return the current lookahead character\n\t//\n\tJsrsParser.prototype.lookahead = function() {\n\t  return this.string[this.lookaheadIndex];\n\t};\n\t\n\t// Advance to the next character and return the character\n\t// that used to be lookahead\n\t//\n\tJsrsParser.prototype.advance = function() {\n\t  var character = this.string[this.lookaheadIndex++];\n\t  if (this.lookaheadIndex > this.string.length) {\n\t    throw new SyntaxError('Unexpected end of data');\n\t  }\n\t  return character;\n\t};\n\t\n\t// Step back to the previous character\n\t//\n\tJsrsParser.prototype.retreat = function() {\n\t  this.lookaheadIndex--;\n\t  if (this.lookaheadIndex < 0) {\n\t    throw new SyntaxError('Parse error');\n\t  }\n\t};\n\t\n\t// Advances one character ensuring the equality of the passed\n\t// one to the given one\n\t//   token - a character to match\n\t//\n\tJsrsParser.prototype.match = function(token) {\n\t  if (this.advance() !== token) {\n\t    this.throwExpected(token);\n\t  }\n\t};\n\t\n\t// Throw a generic parsing error\n\t//   message - error message\n\t//\n\tJsrsParser.prototype.throwError = function(message) {\n\t  throw new SyntaxError(message + ' at position ' + this.lookaheadIndex);\n\t};\n\t\n\t// Throw a 'smth expected' error\n\t//   token - what has been expected\n\t//\n\tJsrsParser.prototype.throwExpected = function(token) {\n\t  this.throwError(token + ' expected');\n\t};\n\t\n\t// Throw a 'smth unexpected' error\n\t//   token - what has been unexpected\n\t//\n\tJsrsParser.prototype.throwUnexpected = function(token) {\n\t  token = token || this.lookahead();\n\t  if (token === undefined) {\n\t    token = 'end of data';\n\t  }\n\t\n\t  this.throwError('Unexpected ' + token);\n\t};\n\t\n\t// Check if a given character is a whitespace character\n\t//   character - a character to check\n\t//\n\tJsrsParser.prototype.isWhitespace = function(character) {\n\t  return ' \\f\\n\\r\\t\\v'.indexOf(character) !== -1;\n\t};\n\t\n\t// Check if a given character is a newline character\n\t//   character - a character to check\n\t//\n\tJsrsParser.prototype.isNewline = function(character) {\n\t  return character === '\\n' || character === '\\r';\n\t};\n\t\n\t// Check if a given character is a lowercase letter character\n\t//   character - a character to check\n\t//\n\tJsrsParser.prototype.isLetter = function(character) {\n\t  return character >= 'a' && character <= 'z';\n\t};\n\t\n\t// Check if a given character can be the first character in a number\n\t//   character - a character to check\n\t//\n\tJsrsParser.prototype.isInitialDigit = function(character) {\n\t  return this.isDecimalDigit(character) ||\n\t    character === '+' || character === '-' ||\n\t    character === '.';\n\t};\n\t\n\t// Check if a given character is one of that are allowed in numbers\n\t//   character - a character to check\n\t//\n\tJsrsParser.prototype.isDigit = function(character) {\n\t  return this.isInitialDigit(character) ||\n\t    character === 'e' || character === 'E';\n\t};\n\t\n\t// Check if a given character is a binary digit\n\t//   character - a character to check\n\t//\n\tJsrsParser.prototype.isBinaryDigit = function(character) {\n\t  return character === '0' || character === '1';\n\t};\n\t\n\t// Check if a given character is an octal digit\n\t//   character - a character to check\n\t//\n\tJsrsParser.prototype.isOctalDigit = function(character) {\n\t  return character >= '0' && character <= '7';\n\t};\n\t\n\t// Check if a given character is a decimal digit\n\t//   character - a character to check\n\t//\n\tJsrsParser.prototype.isDecimalDigit = function(character) {\n\t  return character >= '0' && character <= '9';\n\t};\n\t\n\t// Check if a given character is a hexadecimal digit\n\t//   character - a character to check\n\t//\n\tJsrsParser.prototype.isHexadecimalDigit = function(character) {\n\t  return (character >= '0' && character <= '9') ||\n\t    (character >= 'a' && character <= 'f') ||\n\t    (character >= 'A' && character <= 'F');\n\t};\n\t\n\t// Check if a given character is a quote character\n\t//   character - a character to check\n\t//\n\tJsrsParser.prototype.isQuoteCharacter = function(character) {\n\t  return character === '\\'' || character === '\"';\n\t};\n\t\n\t// Check if a given character can be the first character of an identifier\n\t//   character - a character to check\n\t//\n\tJsrsParser.prototype.isInititalIdentifierCharacter = function(character) {\n\t  return (character >= 'a' && character <= 'z') ||\n\t    (character >= 'A' && character <= 'Z') ||\n\t    (character === '_' || character === '$');\n\t};\n\t\n\t// Check if a given character can be a part of an identifier\n\t//   character - a character to check\n\t//\n\tJsrsParser.prototype.isIdentifierCharacter = function(character) {\n\t  return this.isInititalIdentifierCharacter(character) ||\n\t    this.isDecimalDigit(character);\n\t};\n\t\n\t// Skip whitespace and comments\n\t//\n\tJsrsParser.prototype.skipClutter = function() {\n\t  this.skipWhitespace();\n\t  this.skipComments();\n\t  this.skipWhitespace();\n\t};\n\t\n\t// Skip whitespace\n\t//\n\tJsrsParser.prototype.skipWhitespace = function() {\n\t  while (this.isWhitespace(this.lookahead())) {\n\t    this.advance();\n\t  }\n\t};\n\t\n\t// Skip comments\n\t//\n\tJsrsParser.prototype.skipComments = function() {\n\t  if (this.lookahead() !== '/') {\n\t    return;\n\t  }\n\t\n\t  this.advance();\n\t\n\t  if (this.lookahead() === '/') {\n\t    this.advance();\n\t    this.skipLineCommentBody();\n\t  } else if (this.lookahead() === '*') {\n\t    this.advance();\n\t    this.skipMultilineCommentBody();\n\t  } else {\n\t    this.retreat();\n\t  }\n\t};\n\t\n\t// Skip the body of a single-line comment (i.e. the part after //)\n\t//\n\tJsrsParser.prototype.skipLineCommentBody = function() {\n\t  while (!this.isNewline(this.lookahead()) &&\n\t          this.lookahead() !== undefined) {\n\t    this.advance();\n\t  }\n\t};\n\t\n\t// Skip the body of a multiline comment (i.e. the part after /*)\n\t//\n\tJsrsParser.prototype.skipMultilineCommentBody = function() {\n\t  var done = false;\n\t\n\t  while (!done) {\n\t    while (this.lookahead() !== '*') {\n\t      this.advance();\n\t    }\n\t    this.advance();\n\t\n\t    if (this.lookahead() === '/') {\n\t      this.advance();\n\t      done = true;\n\t    }\n\t  }\n\t};\n\t\n\t// Parse a JavaScript value\n\t//\n\tJsrsParser.prototype.parseValue = function() {\n\t  this.skipClutter();\n\t\n\t  var look = this.lookahead();\n\t  if (this.isInitialDigit(look)) {\n\t    return this.parseNumber();\n\t  } else if (this.isLetter(look)) {\n\t    return this.parseIdentifier();\n\t  } else if (this.isQuoteCharacter(look)) {\n\t    return this.parseString();\n\t  } else if (look === '[') {\n\t    return this.parseArray();\n\t  } else if (look === '{') {\n\t    return this.parseObject();\n\t  } else {\n\t    this.throwUnexpected();\n\t  }\n\t};\n\t\n\t// Parse a number\n\t//\n\tJsrsParser.prototype.parseNumber = function() {\n\t  this.skipClutter();\n\t\n\t  var negateResult = false;\n\t  var look = this.lookahead();\n\t\n\t  if (look === '+' || look === '-') {\n\t    negateResult = look === '-';\n\t    this.advance();\n\t  }\n\t\n\t  var base = 10;\n\t\n\t  if (this.lookahead() === '0') {\n\t    this.advance();\n\t    look = this.lookahead();\n\t\n\t    if (this.isDecimalDigit(look)) {\n\t      this.throwError('Use new octal literals syntax');\n\t    } else if (look === 'b') {\n\t      base = 2;\n\t      this.advance();\n\t    } else if (look === 'o') {\n\t      base = 8;\n\t      this.advance();\n\t    } else if (look === 'x') {\n\t      base = 16;\n\t      this.advance();\n\t    } else {\n\t      this.retreat();\n\t    }\n\t  }\n\t\n\t  var value = base === 10 ?\n\t    this.parseDecimal() :\n\t    this.parseMachineInteger(base);\n\t\n\t  if (isNaN(value)) {\n\t    this.throwError('Invalid number format');\n\t  }\n\t\n\t  return negateResult ?\n\t    -value :\n\t     value;\n\t};\n\t\n\t// Parse a decimal number, either integer or float.\n\t// May return NaN when the number is incorrect.\n\t//\n\tJsrsParser.prototype.parseDecimal = function() {\n\t  var number = '';\n\t\n\t  var encountered = {  // parseFloat ignores unparsed part of\n\t    dot: false,        // the string so we must handle it manually\n\t    sign: false,\n\t    exponent: false\n\t  };\n\t\n\t  while (this.isDigit(this.lookahead())) {\n\t    this.checkNumberPartEncountered(encountered, 'dot', '.');\n\t    this.checkNumberPartEncountered(encountered, 'sign', '+', '-');\n\t    this.checkNumberPartEncountered(encountered, 'exponent', 'e', 'E');\n\t\n\t    number += this.advance();\n\t  }\n\t\n\t  return parseFloat(number);\n\t};\n\t\n\t// Check whether a part of a decimal number that can be used only once\n\t// has been encountered before and throw SyntaxError if it indeed has.\n\t//   encounterContext - an object with boolean flags\n\t//   name - name of the key of the object which value represents the\n\t//          entitity being checked\n\t//   character - a character to match against the lookahead character\n\t//   altCharacter - optional alternative character related to the\n\t//                  same enitity\n\t//\n\tJsrsParser.prototype.checkNumberPartEncountered =\n\t  function(encounterContext, name, character, altCharacter) {\n\t    var look = this.lookahead();\n\t    if (look === character || (altCharacter && look === altCharacter)) {\n\t      if (encounterContext[name]) {\n\t        this.throwUnexpected();\n\t      }\n\t      encounterContext[name] = true;\n\t    }\n\t  };\n\t\n\t// Parse an integer number in binary, octal or hexadecimal representation.\n\t// The prefix is not included and must be parsed before invocation.\n\t// The function may return NaN when the number is incorrect.\n\t//   base - 2, 8 or 16\n\t//\n\tJsrsParser.prototype.parseMachineInteger = function(base) {\n\t  var self = this;\n\t  var checkers = {\n\t    2:  self.isBinaryDigit,\n\t    8:  self.isOctalDigit,\n\t    16: self.isHexadecimalDigit\n\t  };\n\t  var checkDigit = checkers[base];\n\t\n\t  var number = '';\n\t  while (checkDigit(this.lookahead())) {\n\t    number += this.advance();\n\t  }\n\t\n\t  return parseInt(number, base);\n\t};\n\t\n\t// Parse null, undefined, true or false\n\t//\n\tJsrsParser.prototype.parseIdentifier = function() {\n\t  this.skipClutter();\n\t\n\t  var identifier = '';\n\t  while (this.isLetter(this.lookahead())) {\n\t    identifier += this.advance();\n\t  }\n\t\n\t  var matching = {\n\t    undefined: undefined,\n\t    null: null,\n\t    true: true,\n\t    false: false\n\t  };\n\t\n\t  if (matching.hasOwnProperty(identifier)) {\n\t    return matching[identifier];\n\t  } else {\n\t    this.throwUnexpected();\n\t  }\n\t};\n\t\n\t// Parse a single-quoted or double-quoted string\n\t//\n\tJsrsParser.prototype.parseString = function() {\n\t  this.skipClutter();\n\t\n\t  var quoteStyle = this.lookahead();\n\t  if (!this.isQuoteCharacter(quoteStyle)) {\n\t    this.throwExpected('String');\n\t  }\n\t\n\t  var string = '';\n\t  var escapeMode = false;\n\t\n\t  this.advance();\n\t\n\t  while (escapeMode || this.lookahead() !== quoteStyle) {\n\t    var look = this.advance();\n\t\n\t    if (escapeMode) {\n\t      var controlCharacters = {\n\t        b: '\\b', f: '\\f', n: '\\n',\n\t        r: '\\r', t: '\\t', v: '\\v'\n\t      };\n\t\n\t      var controlCharacter = controlCharacters[look];\n\t\n\t      if (controlCharacter) {\n\t        string += controlCharacter;\n\t      } else if (this.isOctalDigit(look)) {\n\t        this.retreat();\n\t        string += this.parseOctalEncodedStringCharacter();\n\t      } else if (look === 'x') {\n\t        this.retreat();\n\t        string += this.parseOneByteHexEncodedCharacter();\n\t      } else if (look === 'u') {\n\t        this.retreat();\n\t        string += this.parseUnicodeCharacter();\n\t      } else {\n\t        string += look;\n\t      }\n\t\n\t      escapeMode = false;\n\t    } else if (look === '\\\\') {\n\t      escapeMode = true;\n\t    } else {\n\t      string += look;\n\t    }\n\t  }\n\t\n\t  this.match(quoteStyle);\n\t\n\t  return string;\n\t};\n\t\n\t// Parse the part of an octal escape sequence after backslash and\n\t// return the corresponding character\n\t//\n\tJsrsParser.prototype.parseOctalEncodedStringCharacter = function() {\n\t  var digits = '';\n\t\n\t  for (var count = 0; count < 3; count++) {\n\t    var look = this.advance();\n\t    if (!this.isOctalDigit(look)) {\n\t      this.retreat();\n\t      break;\n\t    }\n\t\n\t    digits += look;\n\t  }\n\t\n\t  if (digits.length === 0) {\n\t    this.throwExpected('Octal number');\n\t  }\n\t\n\t  var code = parseInt(digits, 8);\n\t  return String.fromCharCode(code);\n\t};\n\t\n\t// Parse the part of a hexadecimal escape sequence after backslash and `x` or\n\t// `u` character and return the character corresponding to that code\n\t//   nibblesCount - count of half-bytes in the escape sequence\n\t//\n\tJsrsParser.prototype.parseHexEncodedStringCharacter = function(nibblesCount) {\n\t  var digits = '';\n\t\n\t  for (var i = 0; i < nibblesCount; i++) {\n\t    var look = this.advance();\n\t    if (!this.isHexadecimalDigit(look)) {\n\t      this.throwExpected('Hexadecimal digit');\n\t    }\n\t\n\t    digits += look;\n\t  }\n\t\n\t  var code = parseInt(digits, 16);\n\t  return String.fromCharCode(code);\n\t};\n\t\n\t// Parse the part of a one-byte hexadecimal escape sequence after backslash\n\t// and return the corresponding character\n\t//\n\tJsrsParser.prototype.parseOneByteHexEncodedCharacter = function() {\n\t  this.match('x');\n\t  return this.parseHexEncodedStringCharacter(2);\n\t};\n\t\n\t// Parse the part of a two-byte hexadecimal escape sequence after backslash\n\t// and return the corresponding character\n\t//\n\tJsrsParser.prototype.parseTwoByteHexEncodedCharacter = function() {\n\t  this.match('u');\n\t  return this.parseHexEncodedStringCharacter(4);\n\t};\n\t\n\t// Parse a Unicode escape sequence after backslash and return the\n\t// corresponding character\n\t//\n\tJsrsParser.prototype.parseUnicodeCharacter = function() {\n\t  this.match('u');\n\t\n\t  if (this.lookahead() === '{') {\n\t    return this.parseEs6UnicodeLiteral();\n\t  } else {\n\t    this.retreat();\n\t    return this.parseTwoByteHexEncodedCharacter();\n\t  }\n\t};\n\t\n\t// Parse an ES2015 multibyte Unicode escape sequence after backslash and `u`\n\t// character\n\t//\n\tJsrsParser.prototype.parseEs6UnicodeLiteral = function() {\n\t  this.match('{');\n\t\n\t  var hexDigits = '';\n\t\n\t  while (this.lookahead() !== '}') {\n\t    var digit = this.advance();\n\t    if (!this.isHexadecimalDigit(digit)) {\n\t      this.throwExpected('Hexadecimal digit');\n\t    }\n\t\n\t    hexDigits += digit;\n\t  }\n\t\n\t  if (hexDigits.length === 0 || hexDigits.length > 8) {\n\t    this.throwError('Invalid code point');\n\t  }\n\t\n\t  this.match('}');\n\t\n\t  var code = parseInt(hexDigits, 16);\n\t  return String.fromCodePoint(code);\n\t};\n\t\n\t// Parse an array\n\t//\n\tJsrsParser.prototype.parseArray = function() {\n\t  this.skipClutter();\n\t  this.match('[');\n\t\n\t  var array = [];\n\t\n\t  while (this.lookahead() !== ']') {\n\t    this.skipClutter();\n\t\n\t    if (this.lookahead() === ',') {\n\t      array.push(undefined);\n\t    } else if (this.lookahead() === ']') {\n\t      break;\n\t    } else {\n\t      var value = this.parseValue();\n\t      array.push(value);\n\t    }\n\t\n\t    this.skipClutter();\n\t    if (this.lookahead() !== ']') {\n\t      this.match(',');\n\t    }\n\t  }\n\t\n\t  this.match(']');\n\t\n\t  return array;\n\t};\n\t\n\t// Parse an object\n\t//\n\tJsrsParser.prototype.parseObject = function() {\n\t  this.skipClutter();\n\t\n\t  var object = {};\n\t\n\t  this.match('{');\n\t\n\t  while (this.lookahead() !== '}') {\n\t    var key = this.parseObjectKey();\n\t    this.match(':');\n\t    var value = this.parseValue();\n\t\n\t    if (value !== undefined) {\n\t      object[key] = value;\n\t    }\n\t\n\t    this.skipClutter();\n\t    if (this.lookahead() !== '}') {\n\t      this.match(',');\n\t      this.skipClutter();\n\t    }\n\t  }\n\t\n\t  this.skipClutter();\n\t  this.match('}');\n\t\n\t  return object;\n\t};\n\t\n\t// Parse a key of an object\n\t//\n\tJsrsParser.prototype.parseObjectKey = function() {\n\t  this.skipClutter();\n\t\n\t  if (this.isQuoteCharacter(this.lookahead())) {\n\t    return this.parseString();\n\t  }\n\t\n\t  if (!this.isInititalIdentifierCharacter(this.lookahead())) {\n\t    this.throwExpected('String or identifier');\n\t  }\n\t\n\t  var key = '';\n\t  while (this.isIdentifierCharacter(this.lookahead())) {\n\t    key += this.advance();\n\t  }\n\t\n\t  return key;\n\t};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar events = __webpack_require__(3);\n\tvar util = __webpack_require__(2);\n\t\n\tmodule.exports = RemoteProxy;\n\t\n\t// Remote API proxy object class. It wraps remote methods so that they look\n\t// like regular local methods and acts like a remote event emitter.\n\t//   connection - JSTP connection to use\n\t//   interfaceName - name of an interface that is proxied\n\t//   methods - array of method names (optional)\n\t//\n\tfunction RemoteProxy(connection, interfaceName, methods) {\n\t  events.EventEmitter.call(this);\n\t\n\t  this._connection = connection;\n\t  this._interfaceName = interfaceName;\n\t\n\t  if (methods) {\n\t    for (var i = 0; i < methods.length; i++) {\n\t      RemoteProxy.wrapRemoteMethod(this, methods[i]);\n\t    }\n\t  }\n\t}\n\t\n\tutil.inherits(RemoteProxy, events.EventEmitter);\n\t\n\t// Emit an event. By default, when the dontRetranslate parameter is false or\n\t// undefined, the event is also emmited on the other part of the JSTP\n\t// connection so all the 'on' handlers will work on both sides regardless of\n\t// where event has been emitted. However, you can turn it off by setting\n\t// dontRetranslate to true.\n\t//   eventName - name of an event\n\t//   eventArgs - object of event arguments\n\t//   dontRetranslate - turn off sending the corresponding event packet over the\n\t//                     JSTP connection\n\t//\n\tRemoteProxy.prototype.emit = function(eventName, eventArgs, dontRetranslate) {\n\t  if (!dontRetranslate) {\n\t    this._connection.emitRemoteEvent(this._interfaceName, eventName, eventArgs);\n\t  }\n\t\n\t  events.EventEmitter.prototype.emit.call(this, eventName, eventArgs);\n\t};\n\t\n\t// Create a method in a remote proxy that will call the corresponding remote\n\t// method. This is implemented as a static method rather than an instance\n\t// method so that it will not be rewritten by a remote API method with the same\n\t// name.\n\t//   instance - remote proxy object\n\t//   method - name of a method\n\t//\n\tRemoteProxy.wrapRemoteMethod = function(instance, methodName) {\n\t  instance[methodName] = remoteMethodWrapper.bind(instance, methodName);\n\t};\n\t\n\t// Remote method wrapper\n\t//   this - remote proxy instance\n\t//   methodName - name of a remote method\n\t//\n\tfunction remoteMethodWrapper(methodName) {\n\t  var callback = arguments[arguments.length - 1];\n\t  var args = Array.prototype.slice.call(arguments, 1, -1);\n\t\n\t  if (typeof(callback) !== 'function') {\n\t    args.push(callback);\n\t    callback = null;\n\t  }\n\t\n\t  this._connection.callMethod(this._interfaceName, methodName, args, callback);\n\t}\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar common = __webpack_require__(1);\n\t\n\tvar factory = {};\n\tmodule.exports = factory;\n\t\n\t// Create a serializer function that takes a JavaScript object and returns its\n\t// string representation. By default the behaviour of this function will be\n\t// compliant with the JSTP Record Serialization format but you can override it\n\t// or supply additional types support using the optional argument of this\n\t// factory function.\n\t//   additionalTypes - an object with keys which names specify data types and\n\t//                     values that are functions that serialize values of\n\t//                     the corresponding types\n\t//\n\tfactory.createSerializer = function(additionalTypes) {\n\t  function serialize(object) {\n\t    var type;\n\t    if (Array.isArray(object)) {\n\t      type = 'array';\n\t    } else if (object instanceof Date) {\n\t      type = 'date';\n\t    } else if (object === null) {\n\t      type = 'null';\n\t    } else {\n\t      type = typeof(object);\n\t    }\n\t\n\t    var serializer = serialize.types[type];\n\t    if (serializer) {\n\t      return serializer(object);\n\t    }\n\t\n\t    return '';\n\t  }\n\t\n\t  serialize.types = {\n\t    number: function(number) {\n\t      return number + '';\n\t    },\n\t\n\t    boolean: function(bool) {\n\t      return bool ? 'true' : 'false';\n\t    },\n\t\n\t    undefined: function() {\n\t      return 'undefined';\n\t    },\n\t\n\t    null: function() {\n\t      return 'null';\n\t    },\n\t\n\t    string: function(string) {\n\t      var content = JSON.stringify(string).slice(1, -1);\n\t      return '\\'' + content.replace(/'/g, '\\\\\\'') + '\\'';\n\t    },\n\t\n\t    date: function(date) {\n\t      return '\\'' + date.toISOString() + '\\'';\n\t    },\n\t\n\t    array: function(array) {\n\t      var result = '[';\n\t\n\t      for (var index = 0; index < array.length; index++) {\n\t        var value = array[index];\n\t        if (value !== undefined) {\n\t          result += serialize(value);\n\t        }\n\t\n\t        if (index !== array.length - 1) {\n\t          result += ',';\n\t        }\n\t      }\n\t\n\t      return result + ']';\n\t    },\n\t\n\t    object: function(object) {\n\t      var result = '{';\n\t      var firstKey = true;\n\t\n\t      var objectKeys = Object.keys(object);\n\t      var objectKeysCount = objectKeys.length;\n\t\n\t      for (var i = 0; i < objectKeysCount; i++) {\n\t        var key = objectKeys[i];\n\t        var value = serialize(object[key]);\n\t\n\t        if (value === '' || value === 'undefined') {\n\t          continue;\n\t        }\n\t\n\t        if (!/^[a-zA-Z_]\\w*$/.test(key)) {\n\t          key = serialize.types.string(key);\n\t        }\n\t\n\t        if (firstKey) {\n\t          firstKey = false;\n\t        } else {\n\t          result += ',';\n\t        }\n\t\n\t        result += key + ':' + value;\n\t      }\n\t\n\t      return result + '}';\n\t    }\n\t  };\n\t\n\t  common.extend(serialize.types, additionalTypes);\n\t  return serialize;\n\t};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar errors = __webpack_require__(4);\n\t\n\tvar apps = {};\n\tmodule.exports = apps;\n\t\n\t// Generic application class. You are free to substitute it with whatever suits\n\t// your needs.\n\t//   name - application name\n\t//   api - application API\n\t//\n\tfunction Application(name, api) {\n\t  this.name = name;\n\t  this.api = api;\n\t}\n\t\n\tapps.Application = Application;\n\t\n\t// Call application method\n\t//   connection - JSTP connection\n\t//   interfaceName - name of the interface\n\t//   methodName - name of the method\n\t//   args - method arguments (including callback)\n\t//\n\tApplication.prototype.callMethod =\n\t  function(connection, interfaceName, methodName, args) {\n\t    var appInterface = this.api[interfaceName];\n\t    if (!appInterface) {\n\t      throw new errors.RemoteError(errors.ERR_INTERFACE_NOT_FOUND);\n\t    }\n\t\n\t    var method = appInterface[methodName];\n\t    if (!method) {\n\t      throw new errors.RemoteError(errors.ERR_METHOD_NOT_FOUND);\n\t    }\n\t\n\t    var context = { connection: connection };\n\t    method.apply(context, args);\n\t  };\n\t\n\t// Get an array of methods of an interface\n\t//   interfaceName - name of the interface to inspect\n\t//\n\tApplication.prototype.getMethods = function(interfaceName) {\n\t  var appInterface = this.api[interfaceName];\n\t\n\t  if (appInterface) {\n\t    return Object.keys(appInterface);\n\t  } else {\n\t    return null;\n\t  }\n\t};\n\t\n\t// Generic server applications provider class. Your are free to substitute it\n\t// with whatever suits your needs.\n\t//\n\tfunction ServerApplicationsProvider() {\n\t  this._applications = {};\n\t}\n\t\n\tapps.ServerApplicationsProvider = ServerApplicationsProvider;\n\t\n\t// Get an application\n\t//   applicationName - name of the application to get\n\t//\n\tServerApplicationsProvider.prototype.getApplication =\n\t  function(applicationName) {\n\t    return this._applications[applicationName];\n\t  };\n\t\n\t// Register a new application\n\t//   application - application instance or application name\n\t//   api - second argument for the Application constructor (only needed if you\n\t//     have passed a string as the first argument)\n\t//\n\tServerApplicationsProvider.prototype.registerApplication =\n\t  function(application, api) {\n\t    if (typeof(application) === 'string') {\n\t      application = new Application(application, api);\n\t    }\n\t\n\t    this._applications[application.name] = application;\n\t  };\n\t\n\t// Generic client application provider class. Your are free to substitute it\n\t// with whatever suits your needs.\n\t//   application - application instance or application name\n\t//   api - second argument for the Application constructor (only needed if you\n\t//     have passed a string as the first argument)\n\t//\n\tfunction ClientApplicationProvider(application, api) {\n\t  if (application instanceof Application) {\n\t    this._application = application;\n\t  } else {\n\t    this._application = new Application(application, api);\n\t  }\n\t}\n\t\n\tapps.ClientApplicationProvider = ClientApplicationProvider;\n\t\n\t// Get the application\n\t//\n\tClientApplicationProvider.prototype.getApplication = function() {\n\t  return this._application;\n\t};\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar events = __webpack_require__(3);\n\tvar util = __webpack_require__(2);\n\t\n\tvar metasync = __webpack_require__(21);\n\t\n\tvar common = __webpack_require__(1);\n\tvar Connection = __webpack_require__(7);\n\t\n\tmodule.exports = Client;\n\t\n\t// JSTP client\n\t//   rawClient - underlying network client\n\t//   applicationProvider - application provider\n\t//\n\tfunction Client(rawClient, applicationProvider) {\n\t  events.EventEmitter.call(this);\n\t\n\t  this.rawClient = rawClient;\n\t  this.applicationProvider = applicationProvider;\n\t\n\t  common.forwardMultipleEvents(rawClient, this, [\n\t    'connect',\n\t    'error',\n\t    'close'\n\t  ]);\n\t}\n\t\n\tutil.inherits(Client, events.EventEmitter);\n\t\n\t// Connect to a server\n\t//   callback - callback function\n\t//\n\tClient.prototype.connect = function(callback) {\n\t  this.rawClient.connect(function(error) {\n\t    if (error) {\n\t      return callback(error);\n\t    }\n\t\n\t    var transport = this.rawClient.createTransport();\n\t    var connection = new Connection(transport, null, this);\n\t\n\t    callback(null, connection);\n\t  }.bind(this));\n\t};\n\t\n\t// Connect from the server\n\t//   callback - callback function\n\t//\n\tClient.prototype.disconnect = function(callback) {\n\t  this.rawClient.disconnect(callback);\n\t};\n\t\n\t// Get the application\n\t//\n\tClient.prototype.getApplication = function() {\n\t  return this.applicationProvider.getApplication();\n\t};\n\t\n\t// Helper methods that calls 'connect' and then performs handshake\n\t//   appName - name of the application to connect to\n\t//     (see Connection#handshake(appName, username, password, callback))\n\t//   username - user login (or null for anonymous session)\n\t//   password - user password (or null for anonymous session)\n\t//   callback - callback function with signature (error, connection, sessionId)\n\t//\n\tClient.prototype.connectAndHandshake =\n\t  function(appName, username, password, callback) {\n\t    this.connect(function(error, connection) {\n\t      if (error) {\n\t        return callback(error);\n\t      }\n\t\n\t      connection.handshake(appName, username, password, function(error, sid) {\n\t        if (error) {\n\t          return callback(error);\n\t        }\n\t\n\t        callback(null, connection, sid);\n\t      });\n\t    });\n\t  };\n\t\n\t// Helper methods that calls 'connect', performs handshake and loads\n\t// introspection of specified interfaces\n\t//   appName - name of the application to connect to\n\t//     (see Connection#handshake(appName, username, password, callback))\n\t//   username - user login (or null for anonymous session)\n\t//   password - user password (or null for anonymous session)\n\t//   interfaces - array of names of interfaces to inspect\n\t//   callback - callback function with signature\n\t//     (error, connection, sessionId, api)\n\t//\n\tClient.prototype.connectAndInspect =\n\t  function(appName, username, password, interfaces, callback) {\n\t    this.connectAndHandshake(appName, username, password,\n\t      handshakeCallback.bind(this, interfaces, callback));\n\t  };\n\t\n\t// Internal function, part of Client#connectAndInspect method\n\t//\n\tfunction handshakeCallback(interfaces, callback, error, connection, sid) {\n\t  if (error) {\n\t    return callback(error);\n\t  }\n\t\n\t  var errors = {};\n\t  var hasErrors = false;\n\t\n\t  var collector = new metasync.DataCollector(interfaces.length, function(api) {\n\t    if (hasErrors) {\n\t      api._errors = errors;\n\t    }\n\t\n\t    callback(null, connection, sid, api);\n\t  });\n\t\n\t  interfaces.forEach(function(interfaceName) {\n\t    connection.inspectInterface(interfaceName, function(error, appInterface) {\n\t      if (error) {\n\t        appInterface = null;\n\t        errors[interfaceName] = error;\n\t        hasErrors = true;\n\t      }\n\t\n\t      collector.collect(interfaceName, appInterface);\n\t    });\n\t  });\n\t}\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar constants = {};\n\tmodule.exports = constants;\n\t\n\tconstants.WEBSOCKET_PROTOCOL_NAME = 'metarhia-jstp';\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar vm = __webpack_require__(24);\n\tvar serializerFactory = __webpack_require__(10);\n\t\n\tvar PARSE_TIMEOUT = 30;\n\t\n\tvar serializer = {};\n\tmodule.exports = serializer;\n\t\n\t// Parse a string representing an object in JSTP Object Serialization format\n\t//   string - a string to parse\n\t//\n\tserializer.interprete = function interprete(string) {\n\t  var sandbox = vm.createContext({});\n\t  var script = vm.createScript('\"use strict\";(' + string + ')');\n\t  var exported = script.runInNewContext(sandbox, {\n\t    timeout: PARSE_TIMEOUT\n\t  });\n\t\n\t  if (typeof(exported) === 'object' && !Array.isArray(exported)) {\n\t    for (var key in exported) {\n\t      if (exported.hasOwnProperty(key)) {\n\t        sandbox[key] = exported[key];\n\t      }\n\t    }\n\t  }\n\t\n\t  return exported;\n\t};\n\t\n\t// Serialize a JavaScript object into a string in JSTP Object Serialization\n\t// format\n\t//\n\tserializer.dump = serializerFactory.createSerializer({\n\t  date: function(date) {\n\t    var string = date.toISOString();\n\t    return 'new Date(\\'' + string + '\\')';\n\t  },\n\t\n\t  function: function(fn) {\n\t    return fn.toString();\n\t  }\n\t});\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {/* eslint-env browser, commonjs */\n\t'use strict';\n\t\n\tvar events = __webpack_require__(3);\n\tvar util = __webpack_require__(2);\n\t\n\tvar Client = __webpack_require__(13);\n\tvar common = __webpack_require__(1);\n\tvar constants = __webpack_require__(14);\n\t\n\tvar ws = {};\n\tmodule.exports = ws;\n\t\n\t// Create a JSTP client that will transfer data over a WebSocket connection\n\t//   url - WebSocket endpoint URL\n\t//   appProvider - client application provider\n\t//\n\tws.createClient = function(url, appProvider) {\n\t  var wsClient = new W3CWebSocketClient(url);\n\t  var jstpClient = new Client(wsClient, appProvider);\n\t\n\t  return jstpClient;\n\t};\n\t\n\t// Client WebSocket connection for JSTP\n\t//   url - WebSocket endpoint URL\n\t//\n\tfunction W3CWebSocketClient(url) {\n\t  events.EventEmitter.call(this);\n\t\n\t  this.url = url;\n\t  this.socket = null;\n\t  this.socketEventEmitter = null;\n\t  this.socketDidOpen = false;\n\t}\n\t\n\tutil.inherits(W3CWebSocketClient, events.EventEmitter);\n\tws.W3CWebSocketClient = W3CWebSocketClient;\n\t\n\t// Connect to the server\n\t//  callback - callback function\n\t//\n\tW3CWebSocketClient.prototype.connect = function(callback) {\n\t  if (this.socketDidOpen) {\n\t    if (callback) {\n\t      callback(new Error('Already connected'));\n\t    }\n\t    return;\n\t  }\n\t\n\t  try {\n\t    this.socket = new WebSocket(this.url, constants.WEBSOCKET_PROTOCOL_NAME);\n\t  } catch (error) {\n\t    if (callback) {\n\t      callback(error);\n\t    }\n\t    return;\n\t  }\n\t\n\t  this.socketEventEmitter = new events.EventEmitter();\n\t\n\t  this.socket.onopen = this._onOpen.bind(this);\n\t  this.socket.onclose = this._onClose.bind(this);\n\t  this.socket.onerror = this._onError.bind(this);\n\t  this.socket.onmessage = this._onMessage.bind(this);\n\t\n\t  this.socketEventEmitter.once('connectFailed', function(error) {\n\t    if (callback) {\n\t      callback(error);\n\t    }\n\t  });\n\t\n\t  this.socketEventEmitter.once('open', function() {\n\t    if (callback) {\n\t      callback();\n\t    }\n\t  });\n\t};\n\t\n\t// Disconnect from the server\n\t//\n\tW3CWebSocketClient.prototype.disconnect = function(callback) {\n\t  this._ensureConnected();\n\t\n\t  if (callback) {\n\t    this.connection.once('close', callback);\n\t  }\n\t\n\t  this.socket.close();\n\t};\n\t\n\t// Create a JSTP transport from the underlying WebSocket connection\n\t//\n\tW3CWebSocketClient.prototype.createTransport = function() {\n\t  this._ensureConnected();\n\t  return new W3CWebSocketTransport(this.socket, this.socketEventEmitter);\n\t};\n\t\n\t// Check if the client is in the connected state and throw an error otherwise\n\t//\n\tW3CWebSocketClient.prototype._ensureConnected = function() {\n\t  if (!this.socketDidOpen) {\n\t    throw new Error('Not connected yet');\n\t  }\n\t};\n\t\n\t// W3C WebSocket open event handler\n\t//\n\tW3CWebSocketClient.prototype._onOpen = function() {\n\t  this.socketDidOpen = true;\n\t  this.socketEventEmitter.emit('open');\n\t};\n\t\n\t// W3C WebSocket close event handler\n\t//\n\tW3CWebSocketClient.prototype._onClose = function() {\n\t  this.socketDidOpen = false;\n\t  this.socketEventEmitter.emit('close');\n\t};\n\t\n\t// W3C WebSocket error event handler\n\t//\n\tW3CWebSocketClient.prototype._onError = function(error) {\n\t  if (this.socketDidOpen) {\n\t    this.socketEventEmitter.emit('error', error);\n\t  } else {\n\t    this.socketEventEmitter.emit('connectFailed', error);\n\t  }\n\t};\n\t\n\t// W3C WebSocket error event handler\n\t//\n\tW3CWebSocketClient.prototype._onMessage = function(message) {\n\t  this.socketEventEmitter.emit('message', message);\n\t};\n\t\n\t// W3C WebSocket transport for JSTP\n\t//   socket - WebSocket instance\n\t//   socketEventEmitter - an EventEmitter that proxies socket events\n\t//\n\tfunction W3CWebSocketTransport(socket, socketEventEmitter) {\n\t  events.EventEmitter.call(this);\n\t\n\t  this.socket = socket;\n\t  this.socketEventEmitter = socketEventEmitter;\n\t\n\t  common.forwardMultipleEvents(socketEventEmitter, this, [\n\t    'close',\n\t    'error'\n\t  ]);\n\t\n\t  this.socketEventEmitter.on('message', this._onMessage.bind(this));\n\t}\n\t\n\tutil.inherits(W3CWebSocketTransport, events.EventEmitter);\n\tws.W3CWebSocketTransport = W3CWebSocketTransport;\n\t\n\t// Get the address of a remote host\n\t//\n\tW3CWebSocketTransport.prototype.getRemoteAddress = function() {\n\t  return this.socket.url;\n\t};\n\t\n\t// Send data over the connection\n\t//   data - Buffer or string\n\t//\n\tW3CWebSocketTransport.prototype.send = function(data) {\n\t  if (Buffer.isBuffer(data)) {\n\t    data = data.toString();\n\t  }\n\t\n\t  this.socket.send(data);\n\t};\n\t\n\t// End the connection optionally sending the last chunk of data\n\t//   data - Buffer or string (optional)\n\t//\n\tW3CWebSocketTransport.prototype.end = function(data) {\n\t  if (data) {\n\t    this.send(data);\n\t  }\n\t\n\t  this.socket.close();\n\t};\n\t\n\t// WebSocket message handler\n\t//   message - WebSocket message\n\t//\n\tW3CWebSocketTransport.prototype._onMessage = function(message) {\n\t  var data = typeof(message.data) === 'string' ?\n\t    message.data :\n\t    new Buffer(message.data).toString();\n\t\n\t  this.emit('data', '[' + data + ']');\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict'\n\t\n\texports.byteLength = byteLength\n\texports.toByteArray = toByteArray\n\texports.fromByteArray = fromByteArray\n\t\n\tvar lookup = []\n\tvar revLookup = []\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\t\n\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\tfor (var i = 0, len = code.length; i < len; ++i) {\n\t  lookup[i] = code[i]\n\t  revLookup[code.charCodeAt(i)] = i\n\t}\n\t\n\trevLookup['-'.charCodeAt(0)] = 62\n\trevLookup['_'.charCodeAt(0)] = 63\n\t\n\tfunction placeHoldersCount (b64) {\n\t  var len = b64.length\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\t\n\t  // the number of equal signs (place holders)\n\t  // if there are two placeholders, than the two characters before it\n\t  // represent one byte\n\t  // if there is only one, then the three characters before it represent 2 bytes\n\t  // this is just a cheap hack to not do indexOf twice\n\t  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\t}\n\t\n\tfunction byteLength (b64) {\n\t  // base64 is 4/3 + up to two characters of the original data\n\t  return b64.length * 3 / 4 - placeHoldersCount(b64)\n\t}\n\t\n\tfunction toByteArray (b64) {\n\t  var i, j, l, tmp, placeHolders, arr\n\t  var len = b64.length\n\t  placeHolders = placeHoldersCount(b64)\n\t\n\t  arr = new Arr(len * 3 / 4 - placeHolders)\n\t\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  l = placeHolders > 0 ? len - 4 : len\n\t\n\t  var L = 0\n\t\n\t  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n\t    arr[L++] = (tmp >> 16) & 0xFF\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  if (placeHolders === 2) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n\t    arr[L++] = tmp & 0xFF\n\t  } else if (placeHolders === 1) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  return arr\n\t}\n\t\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\t}\n\t\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp\n\t  var output = []\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t    output.push(tripletToBase64(tmp))\n\t  }\n\t  return output.join('')\n\t}\n\t\n\tfunction fromByteArray (uint8) {\n\t  var tmp\n\t  var len = uint8.length\n\t  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n\t  var output = ''\n\t  var parts = []\n\t  var maxChunkLength = 16383 // must be multiple of 3\n\t\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n\t  }\n\t\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1]\n\t    output += lookup[tmp >> 2]\n\t    output += lookup[(tmp << 4) & 0x3F]\n\t    output += '=='\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n\t    output += lookup[tmp >> 10]\n\t    output += lookup[(tmp >> 4) & 0x3F]\n\t    output += lookup[(tmp << 2) & 0x3F]\n\t    output += '='\n\t  }\n\t\n\t  parts.push(output)\n\t\n\t  return parts.join('')\n\t}\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var nBits = -7\n\t  var i = isLE ? (nBytes - 1) : 0\n\t  var d = isLE ? -1 : 1\n\t  var s = buffer[offset + i]\n\t\n\t  i += d\n\t\n\t  e = s & ((1 << (-nBits)) - 1)\n\t  s >>= (-nBits)\n\t  nBits += eLen\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  m = e & ((1 << (-nBits)) - 1)\n\t  e >>= (-nBits)\n\t  nBits += mLen\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  if (e === 0) {\n\t    e = 1 - eBias\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen)\n\t    e = e - eBias\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\t\n\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t  var i = isLE ? 0 : (nBytes - 1)\n\t  var d = isLE ? 1 : -1\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\t\n\t  value = Math.abs(value)\n\t\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0\n\t    e = eMax\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--\n\t      c *= 2\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias)\n\t    }\n\t    if (value * c >= 2) {\n\t      e++\n\t      c /= 2\n\t    }\n\t\n\t    if (e + eBias >= eMax) {\n\t      m = 0\n\t      e = eMax\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t      e = e + eBias\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t      e = 0\n\t    }\n\t  }\n\t\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\t\n\t  e = (e << mLen) | m\n\t  eLen += mLen\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\t\n\t  buffer[offset + i - d] |= s * 128\n\t}\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t\n\tvar indexOf = [].indexOf;\n\t\n\tmodule.exports = function(arr, obj){\n\t  if (indexOf) return arr.indexOf(obj);\n\t  for (var i = 0; i < arr.length; ++i) {\n\t    if (arr[i] === obj) return i;\n\t  }\n\t  return -1;\n\t};\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar metasync = {};\n\tmodule.exports = metasync;\n\t\n\t// Functional Asyncronous Composition\n\t//   fns - array of function([data,] callback)\n\t//     data - incoming data\n\t//     callback - function(data)\n\t//       data - outgoing data\n\t//   done - on `done` callback(data)\n\t//     data - hash with of functions results\n\t//   data - incoming data\n\t//\n\tmetasync.composition = function(fns, done, data) {\n\t  if (fns.length === 1) {\n\t    metasync.parallel(fns[0], done, data);\n\t  } else {\n\t    metasync.sequential(fns, done, data);\n\t  }\n\t};\n\t\n\t// Parallel execution\n\t//   fns - array of function([data,] callback)\n\t//     data - incoming data\n\t//     callback - function(data)\n\t//       data - outgoing data\n\t//   done - on `done` callback(data)\n\t//     data - hash with of functions results\n\t//   data - incoming data\n\t//\n\tmetasync.parallel = function(fns, done, data) {\n\t  var counter = 0,\n\t      len = fns.length,\n\t      finished = false;\n\t  data = data || {};\n\t\n\t  if (len < 1) {\n\t    if (done) done(data);\n\t  } else {\n\t    fns.forEach(function(fn) {\n\t      var finish = function(result) {\n\t        if (fn.name && result) data[fn.name] = result;\n\t        if (result instanceof Error) {\n\t          if (!finished) {\n\t            if (done) done(result);\n\t          }\n\t          finished = true;\n\t        } else {\n\t          if (++counter >= len) {\n\t            if (done) done(data);\n\t          }\n\t        }\n\t      };\n\t      if (Array.isArray(fn)) metasync.composition(fn, finish, data);\n\t      else {\n\t        if (fn.length === 2) fn(data, finish);\n\t        else fn(finish);\n\t      }\n\t    });\n\t  }\n\t};\n\t\n\t// Sequential execution\n\t//   fns - array of function([data,] callback)\n\t//     data - incoming data\n\t//     callback - function(data)\n\t//       data - outgoing data\n\t//   done - on `done` callback(data)\n\t//     data - hash with of functions results\n\t//   data - incoming data\n\t//\n\tmetasync.sequential = function(fns, done, data) {\n\t  var i = -1,\n\t      len = fns.length;\n\t  data = data || {};\n\t\n\t  function next() {\n\t    var fn;\n\t    var finish = function finish(result) {\n\t      if (fn.name && result) data[fn.name] = result;\n\t      if (result instanceof Error) {\n\t        if (done) done(result);\n\t      } else next();\n\t    };\n\t    if (++i >= len) {\n\t      if (done) done(data);\n\t    } else {\n\t      fn = fns[i];\n\t      if (Array.isArray(fn)) metasync.composition(fn, finish, data);\n\t      else {\n\t        if (fn.length === 2) fn(data, finish);\n\t        else fn(finish);\n\t      }\n\t    }\n\t  }\n\t\n\t  if (len > 0) next();\n\t  else if (done) done(data);\n\t};\n\t\n\t// Data Collector\n\t//   expected - number of `collect()` calls expected\n\t//   done - on `done` callback(data)\n\t//\n\tmetasync.DataCollector = function(expected, done) {\n\t  this.expected = expected;\n\t  this.data = {};\n\t  this.count = 0;\n\t  this.done = done;\n\t};\n\t\n\t// Push data to collector\n\t//   key - key in result data\n\t//   data - value in result data\n\t//\n\tmetasync.DataCollector.prototype.collect = function(key, data) {\n\t  this.count++;\n\t  this.data[key] = data;\n\t  if (this.expected === this.count) this.done(this.data);\n\t};\n\t\n\t// Asynchrous filter\n\t// filter :: [a] -> (a -> (Boolean -> Void) -> Void) -> ([a] -> Void)\n\t//\n\t// Arguments:\n\t//   items - incoming array\n\t//   fn - function(value, callback)\n\t//     value - item from items array\n\t//     callback - callback function(accepted)\n\t//       accepted - true/false returned from fn\n\t//   done - on `done` function(result)\n\t//     result - filtered array\n\t//\n\tmetasync.filter = function(items, fn, done) {\n\t  var result = [],\n\t      counter = 0;\n\t\n\t  function finish() {\n\t    // Callbacks might be called in any possible order,\n\t    // hence sort the filtered array\n\t    // by element's index in the original itemsection\n\t    result.sort(function(x, y) { return x.index - y.index; });\n\t\n\t    // Only value is needed in resulting array\n\t    result = result.map(function(x) { return x.value; });\n\t\n\t    // Return a result using callback;\n\t    if (done) done(result);\n\t  }\n\t\n\t  items.forEach(function(value, index) {\n\t    fn(value, function(accepted) {\n\t      if (accepted) result.push({ index: index, value: value });\n\t      if (++counter === items.length) finish();\n\t    });\n\t  });\n\t};\n\t\n\t// Asynchronous find\n\t// find :: [a] -> (a -> (Boolean -> Void) -> Void) -> (a -> Void)\n\t//\n\t// Arguments:\n\t//   items - incoming array\n\t//   fn - function(value, callback)\n\t//     value - item from items array\n\t//     callback - callback function(accepted)\n\t//       accepted - true/false returned from fn\n\t//   done - on `done` function(result)\n\t//     result - filtered array\n\t//\n\tmetasync.find = function(items, fn, done) {\n\t  var i = 0,\n\t      len = items.length;\n\t\n\t  function next() {\n\t    if (i === len) {\n\t      if (done) done();\n\t    } else {\n\t      fn(items[i], function(accepted) {\n\t        if (accepted) {\n\t          if (done) done(items[i]);\n\t        } else {\n\t          i++;\n\t          next();\n\t        }\n\t      });\n\t    }\n\t  }\n\t\n\t  if (len > 0) next();\n\t  else if (done) done();\n\t};\n\t\n\t// Asynchronous series\n\t//   items - incoming array\n\t//   fn - function(value, callback)\n\t//     value - item from items array\n\t//     callback - callback function(accepted)\n\t//       accepted - true/false returned from fn\n\t//   done - on `done` function(result)\n\t//     result - filtered array\n\t//\n\tmetasync.series = function(items, fn, done) {\n\t  var i = -1,\n\t      len = items.length;\n\t\n\t  function next() {\n\t    i++;\n\t    if (i >= len) {\n\t      if (done) done();\n\t    } else fn(items[i], function(result) {\n\t      if (result instanceof Error) {\n\t        if (done) done(result);\n\t      } else next();\n\t    });\n\t  }\n\t\n\t  next();\n\t};\n\t\n\t// Asynchronous each\n\t//   items - incoming array\n\t//   fn - function(value, callback)\n\t//     value - item from items array\n\t//     callback - callback function(accepted)\n\t//       accepted - true/false returned from fn\n\t//   done - on `done` function(result)\n\t//     result - filtered array\n\t//\n\tmetasync.each = function(items, fn, done) {\n\t  var counter = 0,\n\t      len = items.length,\n\t      finished = false;\n\t\n\t  if (len < 1) {\n\t    if (done) done();\n\t  } else {\n\t    items.forEach(function(item) {\n\t      fn(item, function(result) {\n\t        if (result instanceof Error) {\n\t          if (!finished) {\n\t            if (done) done(result);\n\t          }\n\t          finished = true;\n\t        } else {\n\t          counter++;\n\t          if (counter >= len) {\n\t            if (done) done();\n\t          }\n\t        }\n\t      });\n\t    });\n\t  }\n\t};\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function isBuffer(arg) {\n\t  return arg && typeof arg === 'object'\n\t    && typeof arg.copy === 'function'\n\t    && typeof arg.fill === 'function'\n\t    && typeof arg.readUInt8 === 'function';\n\t}\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar indexOf = __webpack_require__(19);\n\t\n\tvar Object_keys = function (obj) {\n\t    if (Object.keys) return Object.keys(obj)\n\t    else {\n\t        var res = [];\n\t        for (var key in obj) res.push(key)\n\t        return res;\n\t    }\n\t};\n\t\n\tvar forEach = function (xs, fn) {\n\t    if (xs.forEach) return xs.forEach(fn)\n\t    else for (var i = 0; i < xs.length; i++) {\n\t        fn(xs[i], i, xs);\n\t    }\n\t};\n\t\n\tvar defineProp = (function() {\n\t    try {\n\t        Object.defineProperty({}, '_', {});\n\t        return function(obj, name, value) {\n\t            Object.defineProperty(obj, name, {\n\t                writable: true,\n\t                enumerable: false,\n\t                configurable: true,\n\t                value: value\n\t            })\n\t        };\n\t    } catch(e) {\n\t        return function(obj, name, value) {\n\t            obj[name] = value;\n\t        };\n\t    }\n\t}());\n\t\n\tvar globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',\n\t'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',\n\t'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',\n\t'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',\n\t'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];\n\t\n\tfunction Context() {}\n\tContext.prototype = {};\n\t\n\tvar Script = exports.Script = function NodeScript (code) {\n\t    if (!(this instanceof Script)) return new Script(code);\n\t    this.code = code;\n\t};\n\t\n\tScript.prototype.runInContext = function (context) {\n\t    if (!(context instanceof Context)) {\n\t        throw new TypeError(\"needs a 'context' argument.\");\n\t    }\n\t    \n\t    var iframe = document.createElement('iframe');\n\t    if (!iframe.style) iframe.style = {};\n\t    iframe.style.display = 'none';\n\t    \n\t    document.body.appendChild(iframe);\n\t    \n\t    var win = iframe.contentWindow;\n\t    var wEval = win.eval, wExecScript = win.execScript;\n\t\n\t    if (!wEval && wExecScript) {\n\t        // win.eval() magically appears when this is called in IE:\n\t        wExecScript.call(win, 'null');\n\t        wEval = win.eval;\n\t    }\n\t    \n\t    forEach(Object_keys(context), function (key) {\n\t        win[key] = context[key];\n\t    });\n\t    forEach(globals, function (key) {\n\t        if (context[key]) {\n\t            win[key] = context[key];\n\t        }\n\t    });\n\t    \n\t    var winKeys = Object_keys(win);\n\t\n\t    var res = wEval.call(win, this.code);\n\t    \n\t    forEach(Object_keys(win), function (key) {\n\t        // Avoid copying circular objects like `top` and `window` by only\n\t        // updating existing context properties or new properties in the `win`\n\t        // that was only introduced after the eval.\n\t        if (key in context || indexOf(winKeys, key) === -1) {\n\t            context[key] = win[key];\n\t        }\n\t    });\n\t\n\t    forEach(globals, function (key) {\n\t        if (!(key in context)) {\n\t            defineProp(context, key, win[key]);\n\t        }\n\t    });\n\t    \n\t    document.body.removeChild(iframe);\n\t    \n\t    return res;\n\t};\n\t\n\tScript.prototype.runInThisContext = function () {\n\t    return eval(this.code); // maybe...\n\t};\n\t\n\tScript.prototype.runInNewContext = function (context) {\n\t    var ctx = Script.createContext(context);\n\t    var res = this.runInContext(ctx);\n\t\n\t    forEach(Object_keys(ctx), function (key) {\n\t        context[key] = ctx[key];\n\t    });\n\t\n\t    return res;\n\t};\n\t\n\tforEach(Object_keys(Script.prototype), function (name) {\n\t    exports[name] = Script[name] = function (code) {\n\t        var s = Script(code);\n\t        return s[name].apply(s, [].slice.call(arguments, 1));\n\t    };\n\t});\n\t\n\texports.createScript = function (code) {\n\t    return exports.Script(code);\n\t};\n\t\n\texports.createContext = Script.createContext = function (context) {\n\t    var copy = new Context();\n\t    if(typeof context === 'object') {\n\t        forEach(Object_keys(context), function (key) {\n\t            copy[key] = context[key];\n\t        });\n\t    }\n\t    return copy;\n\t};\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ },\n/* 26 */\n25,\n/* 27 */\n25\n/******/ ])));\n\n\n// WEBPACK FOOTER //\n// jstp.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f1354b8ed810e0271012","'use strict';\n\nvar common = require('./lib/common');\n\nvar jstp = {};\nmodule.exports = jstp;\n\ncommon.extend(jstp,\n  require('./lib/record-serialization'),\n  require('./lib/object-serialization'),\n  require('./lib/errors'),\n  require('./lib/apps-provider')\n);\n\njstp.RemoteProxy = require('./lib/remote-proxy');\njstp.Connection = require('./lib/connection');\njstp.Server = require('./lib/server');\n\njstp.tcp = require('./lib/transport.tcp');\njstp.ws = require('./lib/transport.ws');\n\njstp.simpleAuthProvider = require('./lib/auth-provider');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./jstp.js\n// module id = 0\n// module chunks = 0","'use strict';\n\nvar common = {};\nmodule.exports = common;\n\n// Tests if a value is null or undefined\n//   value - a value to test\n//\nfunction isNull(value) {\n  return value === null || value === undefined;\n}\n\n// Populate a target object with all the properties\n// of arbitrary number of other objects\n// Signature:\n//   common.extend(target, ...sources);\n// Parameters:\n//   target - object to copy properties into\n//   ...sources - source objects\n//\ncommon.extend = function(target) {\n  if (isNull(target)) {\n    throw new TypeError('Cannot convert undefined or null to object');\n  }\n\n  if (typeof(target) !== 'object') {\n    target = new Object(target);\n  }\n\n  var sources = Array.prototype.slice\n    .call(arguments, 1)\n    .filter(function(source) {\n      return !isNull(source);\n    });\n\n  sources.forEach(function(source) {\n    for (var key in source) {\n      if (!source.hasOwnProperty(key)) {\n        continue;\n      }\n      target[key] = source[key];\n    }\n  });\n\n  return target;\n};\n\nif (Object.assign) {\n  common.extend = Object.assign;\n}\n\n// Forward an event from one EventEmitter to another\n//   from - EventEmitter to listen for event\n//   to - EventEmitter to emit event on\n//   eventName - name of the event\n//   newEventName - name of the forwarded event (optional)\n//\ncommon.forwardEvent = function(from, to, eventName, newEventName) {\n  from.on(eventName, function(eventArgs) {\n    to.emit(newEventName || eventName, eventArgs, to);\n  });\n};\n\n// Forward events from one EventEmitter to another\n//   from - EventEmitter to listen for event\n//   to - EventEmitter to emit event on\n//   eventNames - array of names of events\n//\ncommon.forwardMultipleEvents = function(from, to, eventNames) {\n  eventNames.forEach(function(event) {\n    common.forwardEvent(from, to, event);\n  });\n};\n\n// Create a zero-filled buffer of specified size\n//   size - desired buffer size\n//\ncommon.createZeroFilledBuffer = function(size) {\n  var buffer = new Buffer(size);\n  buffer.fill(0);\n\n  return buffer;\n};\n\nif (Buffer.alloc) {\n  common.createZeroFilledBuffer = Buffer.alloc;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/common.js\n// module id = 1\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/util/util.js\n// module id = 2\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/events/events.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nvar util = require('util');\n\nvar errors = {};\nmodule.exports = errors;\n\n// Standard protocol errors\n\nerrors.ERR_APP_NOT_FOUND = 10;\nerrors.ERR_AUTH_FAILED = 11;\nerrors.ERR_INTERFACE_NOT_FOUND = 12;\nerrors.ERR_INTERFACE_INCOMPATIBLE = 13;\nerrors.ERR_METHOD_NOT_FOUND = 14;\nerrors.ERR_NOT_A_SERVER = 15;\nerrors.ERR_INTERNAL_API_ERROR = 16;\n\n// JSTP remote error class\n// TODO: implement RPC stacktrace\n//   code - error code\n//   message - optional error message\n//\nfunction RemoteError(code, message) {\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, RemoteError);\n  } else {\n    this.stack = new Error(message).stack;\n  }\n\n  this.message = message ||\n    RemoteError.defaultMessages[code] ||\n    code.toString();\n\n  this.code = code;\n}\n\nutil.inherits(RemoteError, Error);\nerrors.RemoteError = RemoteError;\n\nRemoteError.prototype.name = 'RemoteError';\n\n// Convert a RemoteError instance to array representing an error in JSTP\n// packets\n//\nRemoteError.prototype.toJstpArray = function() {\n  var isMessagePresent = this.message && this.message !== this.code.toString();\n  var isMessageStandard = RemoteError.defaultMessages.hasOwnProperty(this.code);\n\n  if (isMessagePresent && !isMessageStandard) {\n    return [this.code, this.message];\n  } else {\n    return [this.code];\n  }\n};\n\n// Factory method that creates a RemoteError instance from a JSTP array\n//   array - array in the form of [code, description]\n//\nRemoteError.fromJstpArray = function(array) {\n  return new RemoteError(array[0], array[1]);\n};\n\n// Prepare an error to be sent in a JSTP packet\n//   error - an error to prepare (instance of Error, RemoteError, a string or\n//           a regular JavaScript array of error code and error description)\n//\nRemoteError.getJstpArrayFor = function(error) {\n  if (error instanceof RemoteError) {\n    return error.toJstpArray();\n  } else if (Array.isArray(error)) {\n    return error;\n  } else if (typeof(error) === 'number') {\n    return [error];\n  } else if (typeof(error) === 'string') {\n    return [0, error];\n  } else {\n    return [0, error.toString()];\n  }\n};\n\n// Default messages for predefined error codes\n//\nRemoteError.defaultMessages = { };\n\nRemoteError.defaultMessages[errors.ERR_APP_NOT_FOUND] =\n  'Application not found';\n\nRemoteError.defaultMessages[errors.ERR_AUTH_FAILED] =\n  'Authentication failed';\n\nRemoteError.defaultMessages[errors.ERR_INTERFACE_NOT_FOUND] =\n  'Interface not found';\n\nRemoteError.defaultMessages[errors.ERR_INTERFACE_INCOMPATIBLE] =\n  'Incompatible interface';\n\nRemoteError.defaultMessages[errors.ERR_METHOD_NOT_FOUND] =\n  'Method not found';\n\nRemoteError.defaultMessages[errors.ERR_NOT_A_SERVER] =\n  'Not a server';\n\nRemoteError.defaultMessages[errors.ERR_INTERNAL_API_ERROR] =\n  'Internal API error';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/errors.js\n// module id = 4\n// module chunks = 0","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer/index.js\n// module id = 5\n// module chunks = 0","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 6\n// module chunks = 0","'use strict';\n\nvar events = require('events');\nvar timers = require('timers');\nvar util = require('util');\n\nvar jsrs = require('./record-serialization');\nvar common = require('./common');\nvar errors = require('./errors');\nvar RemoteProxy = require('./remote-proxy');\n\nmodule.exports = Connection;\n\nvar nextConnectionId = 0;\n\n// JSTP connection class\n//   transport - an abstract socket\n//   server - JSTP server instance, used only for server-side parts\n//            of connections (optional, but either server or client\n//            is required)\n//   client - JSTP client instance, used only for client-side parts\n//            of connections (optional, but either server or client\n//            is required)\n//\nfunction Connection(transport, server, client) {\n  events.EventEmitter.call(this);\n\n  this.transport = transport;\n  this.server = server;\n  this.client = client;\n\n  this.id = nextConnectionId++;\n  this._nextPacketId = 0;\n\n  if (server && !client) {\n    this._packetIdDelta = -1;\n  } else if (client && !server) {\n    this._packetIdDelta = 1;\n  } else {\n    throw new Error('Either server or client is required');\n  }\n\n  this.remoteAddress = transport.getRemoteAddress();\n\n  this._callbacks = {};\n\n  this.handshakeDone = false;\n  this.authenticated = false;\n  this.sessionId = null;\n\n  this.application = null;\n  this.remoteProxies = {};\n\n  transport.on('data', this._onSocketData.bind(this));\n  transport.on('close', this._onSocketClose.bind(this));\n  transport.on('error', this._onSocketError.bind(this));\n}\n\nutil.inherits(Connection, events.EventEmitter);\n\n// Send a call packet over the connection\n//   interfaceName - name of an interface\n//   methodName - name of a method\n//   args - method arguments\n//   callback - callback function that is invoked after a callback packet\n//              has been received\n//\nConnection.prototype.callMethod =\n  function(interfaceName, methodName, args, callback) {\n    var packet = this.createPacket('call', interfaceName, methodName, args);\n\n    if (callback) {\n      var packetId = packet.call[0];\n      this._callbacks[packetId] = callback;\n    }\n\n    this._send(packet);\n  };\n\n// Send a callback packet over the connection\n//   packetId - id of a call packet to send callback packet for\n//   error - error that has occured or null\n//   result - result of a remote method if there was no error\n//\nConnection.prototype.callback = function(packetId, error, result) {\n  var packet;\n\n  if (error) {\n    error = errors.RemoteError.getJstpArrayFor(error);\n    packet = this.createPacket('callback', null, 'error', error);\n  } else {\n    packet = this.createPacket('callback', null, 'ok', result);\n  }\n\n  packet.callback[0] = packetId;\n\n  this._send(packet);\n};\n\n// Send an event packet over the connection\n//   interfaceName - name of an interface\n//   eventName - name of an event\n//   args - event arguments as an object\n//\nConnection.prototype.emitRemoteEvent =\n  function(interfaceName, eventName, args) {\n    var packet = this.createPacket('event', interfaceName, eventName, args);\n    this._send(packet);\n  };\n\n// Send a state synchronization packet over the connection\n//   path - path to a value in the application state\n//   verb - operation with this value (inc, dec, let, delete, push, pop, shift,\n//          unshift)\n//   value - a value to modify the current value with\n//\nConnection.prototype.notifyStateChange = function(path, verb, value) {\n  var packet = this.createPacket('state', path, verb, value);\n  this._send(packet);\n};\n\n// Send a handshake packet over the connection\n//   appName - name of an application to connect to\n//   login - user name (optional)\n//   password - user password (optional)\n//   callback - callback function to invoke after the handshake is completed\n//\nConnection.prototype.handshake = function(appName, login, password, callback) {\n  var packet = this.createPacket('handshake', appName, login, password);\n\n  if (callback) {\n    var packetId = packet.handshake[0];\n    var self = this;\n\n    this._callbacks[packetId] = function(error, sessionId) {\n      if (login && password && !error) {\n        self.authenticated = true;\n      }\n\n      callback(error, sessionId);\n    };\n  }\n\n  this._send(packet);\n};\n\n// Send an inspect packet over the connection\n//   interfaceName - name of an interface to inspect\n//   callback - callback function to invoke after another side responds\n//              with interface introspection\n//\nConnection.prototype.inspectInterface = function(interfaceName, callback) {\n  var packet = this.createPacket('inspect', interfaceName, null, null);\n  var packetId = packet.inspect[0];\n  var self = this;\n\n  this._callbacks[packetId] = function(error) {\n    if (error) {\n      return callback(error);\n    }\n\n    var methods = Array.prototype.slice.call(arguments, 1);\n    var proxy = new RemoteProxy(this, interfaceName, methods);\n\n    self.remoteProxies[interfaceName] = proxy;\n\n    if (callback) {\n      callback(null, proxy);\n    }\n  };\n\n  this._send(packet);\n};\n\n// Create a JSTP packet\n//   kind - packet kind\n//   target - name of an interface or an application (optional)\n//   verb - action specific for different packet kinds\n//   args - action arguments\n//\nConnection.prototype.createPacket = function(kind, target, verb, args) {\n  var packet = {};\n\n  packet[kind] = target ?\n    [this._nextPacketId, target] :\n    [this._nextPacketId];\n\n  if (verb) {\n    packet[verb] = args;\n  }\n\n  this._nextPacketId += this._packetIdDelta;\n\n  return packet;\n};\n\n// Close the connection\n//\nConnection.prototype.close = function() {\n  this.transport.end();\n};\n\n// Set a timeout using timers.enroll()\n//   milliseconds - amount of milliseconds\n//   callback - callback function\n//\nConnection.prototype.setTimeout = function(milliseconds, callback) {\n  timers.enroll(this, milliseconds);\n  timers._unrefActive(this);\n\n  this.once('_timeout', callback);\n};\n\n// timers.enroll() timeout handler\n//\nConnection.prototype._onTimeout = function() {\n  this.emit('_timeout');\n};\n\n// Send a JSTP packet over this connection\n//   packet - a packet to send\n//\nConnection.prototype._send = function(packet) {\n  var data = jsrs.stringify(packet);\n  this.transport.send(data);\n};\n\n// Close the connection, optionally sending a final packet\n//   packet - a packet to send (optional)\n//\nConnection.prototype._end = function(packet) {\n  if (packet) {\n    var data = jsrs.stringify(packet);\n    this.transport.end(data);\n  } else {\n    this.transport.end();\n  }\n};\n\n// Incoming data event handler\n//   data - data to process\n//\nConnection.prototype._onSocketData = function(data) {\n  this.emit('data', data);\n\n  var packets = jsrs.parse(data);\n  this._processPackets(packets);\n};\n\n// Closed socket event handler\n//\nConnection.prototype._onSocketClose = function() {\n  this.emit('close', this);\n\n  if (this.server) {\n    this.server.emit('disconnect', this);\n  }\n};\n\n// Socket error event handler\n//   error - error that has occured\n//\nConnection.prototype._onSocketError = function(error) {\n  this.emit('error', error, this);\n};\n\n// Process parsed incoming packets\n//   packets - array of packets\n//\nConnection.prototype._processPackets = function(packets) {\n  for (var index = 0; index < packets.length; index++) {\n    var packet = packets[index];\n    this.emit('packet', packet, this);\n\n    var keys = Object.keys(packet);\n    var kind = keys[0];\n\n    if (!this.handshakeDone && kind !== 'handshake') {\n      this._rejectPacket(packet, true);\n      return;\n    }\n\n    var handler = Connection.PACKET_HANDLER_NAMES[kind];\n    if (handler) {\n      this[handler](packet, keys);\n    } else {\n      this._rejectPacket(packet);\n    }\n  }\n};\n\n// Reject incoming packet\n//   packet - rejected packet\n//   fatal - if true, close the connection\n//\nConnection.prototype._rejectPacket = function(packet, fatal) {\n  this.emit('packetRejected', packet, this);\n\n  if (fatal) {\n    this._end();\n  }\n};\n\n// Process incoming handshake packet\n//   packet - parsed packet\n//   keys - array of packet keys\n//\nConnection.prototype._processHandshakePacket = function(packet, keys) {\n  if (this.handshakeDone) {\n    this.emit('abundantHandshake', packet, this);\n    return;\n  }\n\n  if (packet.handshake[1]) {  // if there is an application name\n    this._processHandshakeRequest(packet, keys);\n  } else {\n    this._processHandshakeResponse(packet, keys);\n  }\n};\n\n// Process incoming handshake packet which is a handshake request\n//   packet - parsed packet\n//   keys - array of packet keys\n//\nConnection.prototype._processHandshakeRequest = function(packet, keys) {\n  if (!this.server) {\n    this._handshakeError(errors.ERR_NOT_A_SERVER);\n    return;\n  }\n\n  var applicationName = packet.handshake[1];\n  var application = this.server.getApplication(applicationName);\n\n  if (!application) {\n    this._handshakeError(errors.ERR_APP_NOT_FOUND);\n    return;\n  }\n\n  this.application = application;\n\n  var username = keys[1];\n  var password = packet[username];\n\n  this._emitPacketEvent('handshakeRequest', packet, packet.handshake[0], {\n    packetType: 'handshake',\n    handshakeRequest: true,\n    username: username,\n    password: password\n  });\n\n  if (username) {\n    this.server.startAuthenticatedSession(this, application,\n      username, password, this._onAuthenticatedSessionCreated.bind(this));\n  } else {\n    this.server.startAnonymousSession(this, application,\n      this._onSessionCreated.bind(this));\n  }\n};\n\n// Callback of authentication operation. This function is passed to\n// startAuthenticatedSession and startAnonymousSession functions (wrapped into\n// onAuthenticatedSessionCreated or directly respectively) of the\n// authentication service injected into JSTP server as a dependency as a\n// callback function since these operations may be (and most probably will be)\n// asynchronous.\n//   error - error that has occured or null\n//   sessionId - session id or hash\n//\nConnection.prototype._onSessionCreated = function(error, sessionId) {\n  if (error) {\n    this._handshakeError(errors.ERR_AUTH_FAILED);\n    return;\n  }\n\n  this.handshakeDone = true;\n\n  this.emit('client', sessionId, this);\n  this.server.emit('connect', this);\n\n  var packet = this.createPacket('handshake', null, 'ok', sessionId);\n  this._send(packet);\n};\n\n// onSessionCreated wrapper for authenticated connections\n//   error - error that has occured or null\n//   sessionId - session id or hash\n//\nConnection.prototype._onAuthenticatedSessionCreated =\n  function(error, sessionId) {\n    if (!error) {\n      this.authenticated = true;\n    }\n\n    this._onSessionCreated(error, sessionId);\n  };\n\n// Process incoming handshake packet which is a handshake response\n//   packet - parsed packet\n//\nConnection.prototype._processHandshakeResponse = function(packet) {\n  var packetId = packet.handshake[0];\n  var callback = this._callbacks[packetId];\n\n  if (!callback) {\n    this._rejectPacket(packet);\n  }\n\n  if (packet.ok) {\n    delete this._callbacks[packetId];\n\n    this.handshakeDone = true;\n    this.application = this.client.getApplication();\n    this._emitPacketEvent('handshake', packet, packetId, {\n      sessionId: packet.ok\n    });\n\n    callback(null, packet.ok);\n  } else if (packet.error) {\n    delete this._callbacks[packetId];\n    callback(errors.RemoteError.fromJstpArray(packet.error));\n  } else {\n    this._rejectPacket(packet, true);\n  }\n};\n\n// End the connection with handshake error\n//   error - error that has occured\n//\nConnection.prototype._handshakeError = function(error) {\n  var normalizedError = errors.RemoteError.getJstpArrayFor(error);\n  var packet = this.createPacket('handshake', null, 'error', normalizedError);\n\n  this._end(packet);\n};\n\n// Process incoming call packet\n//   packet - parsed packet\n//   keys - array of packet keys\n//\nConnection.prototype._processCallPacket = function(packet, keys) {\n  var packetId = packet.call[0];\n  var interfaceName = packet.call[1];\n  var methodName = keys[1];\n  var args = packet[methodName];\n\n  this._emitPacketEvent('call', packet, packetId, {\n    interfaceName: interfaceName,\n    methodName: methodName\n  });\n\n  var callback = this._remoteCallbackWrapper.bind(this, packetId);\n  args.push(callback);\n\n  try {\n    this.application.callMethod(this, interfaceName, methodName, args);\n  } catch (error) {\n    if (error instanceof errors.RemoteError) {\n      callback(error);\n    } else {\n      callback(errors.ERR_INTERNAL_API_ERROR);\n      throw error;\n    }\n  }\n};\n\n// Process incoming callback packet\n//   packet - parsed packet\n//\nConnection.prototype._processCallbackPacket = function(packet) {\n  var packetId = packet.callback[0];\n  var callback = this._callbacks[packetId];\n\n  if (callback) {\n    delete this._callbacks[packetId];\n\n    if (packet.ok) {\n      callback.apply(this, [null].concat(packet.ok));\n    } else if (packet.error) {\n      callback(errors.RemoteError.fromJstpArray(packet.error));\n    } else {\n      this._rejectPacket(packet);\n    }\n  }\n\n  var eventArgs = callback ?\n    null :\n    { sourcePacketUnknown: true };\n\n  this._emitPacketEvent('callback', packet, packetId, eventArgs);\n\n  if (!callback) {\n    this.emit('callbackForUnknownPacket', packetId, packet, this);\n  }\n};\n\n// Process incoming event packet\n//   packet - parsed packet\n//   keys - array of packet keys\n//\nConnection.prototype._processEventPacket = function(packet, keys) {\n  var interfaceName = packet.event[1];\n  var eventName = keys[1];\n  var eventArgs = packet[eventName];\n\n  this._emitPacketEvent('event', packet, packet.event[0], {\n    interfaceName: interfaceName,\n    remoteEventName: eventName,\n    remoteEventArgs: eventArgs\n  });\n\n  var remoteProxy = this.remoteProxies[interfaceName];\n  if (remoteProxy) {\n    remoteProxy.emit(eventName, eventArgs, true);\n  }\n};\n\n// Process incoming inspect packet\n//   packet - parsed packet\n//\nConnection.prototype._processInspectPacket = function(packet) {\n  var packetId = packet.inspect[0];\n  var interfaceName = packet.inspect[1];\n\n  this._emitPacketEvent('inspect', packet, packetId, {\n    interfaceName: interfaceName\n  });\n\n  var methods = this.application.getMethods(interfaceName);\n  if (methods) {\n    this.callback(packetId, null, methods);\n  } else {\n    this.callback(packetId, errors.ERR_INTERFACE_NOT_FOUND);\n  }\n};\n\n// Process incoming state packet\n//   packet - parsed packet\n//\nConnection.prototype._processStatePacket = function(packet, keys) {\n  var path = packet.state[1];\n  var verb = keys[1];\n  var value = packet[verb];\n\n  this._emitPacketEvent('state', packet, packet.state[0], {\n    path: path,\n    verb: verb,\n    value: value\n  });\n};\n\n// Callback of functions invoked via call packets\n// Signature: Connection#_remoteCallbackWrapper(packetId, error, ...result)\n//   packetId - id of a packet to send callback for\n//   error - error that has occured, if any\n//   result - data to send back as a result\n//\nConnection.prototype._remoteCallbackWrapper = function(packetId, error) {\n  var result = Array.prototype.slice.call(arguments, 2);\n  this.callback(packetId, error, result);\n};\n\n// Emit an event notifying about incoming packet. The event payload is an\n// object that contains information about the connection, application, packet,\n// packet type, packet ID and any additional data that you pass to this\n// function.\n//   kind - packet type and event name\n//   packet - parsed packet\n//   packetId - packet ID\n//   args - additional event arguments (optional)\n//\nConnection.prototype._emitPacketEvent = function(kind, packet, packetId, args) {\n  var eventArgs = {\n    connection: this,\n    packetType: kind,\n    packet: packet,\n    packetId: packetId,\n    application: this.application\n  };\n\n  if (args) {\n    common.extend(eventArgs, args);\n  }\n\n  this.emit(kind, eventArgs);\n};\n\n// Mapping of packet types to handler function names\n//\nConnection.PACKET_HANDLER_NAMES = {\n  handshake: '_processHandshakePacket',\n  call: '_processCallPacket',\n  callback: '_processCallbackPacket',\n  event: '_processEventPacket',\n  inspect: '_processInspectPacket',\n  state: '_processStatePacket'\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/connection.js\n// module id = 7\n// module chunks = 0","/* eslint-env shared-node-browser, commonjs */\n'use strict';\n\nvar serializerFactory = require('./serializer-factory');\n\nvar jsrs = {};\nmodule.exports = jsrs;\n\n// Serialize a JavaScript value using the JSTP Record Serialization format\n// and return a string representing it.\n//\njsrs.stringify = serializerFactory.createSerializer();\n\n// Deserialize a string in the JSTP Record Serialization format into\n// a JavaScript value and return it.\n//   string - a string to parse\n//\njsrs.parse = function parse(string) {\n  var parser = new JsrsParser(string);\n  return parser.parse();\n};\n\n// Internal JSRS parser class\n//   string - a string to parse\n//\nfunction JsrsParser(string) {\n  this.string = string;\n  this.lookaheadIndex = 0;\n}\n\n// Start parsing\n//\nJsrsParser.prototype.parse = function() {\n  var value = this.parseValue();\n\n  this.skipClutter();\n  if (this.lookaheadIndex < this.string.length) {\n    this.throwUnexpected();\n  }\n\n  return value;\n};\n\n// Return the current lookahead character\n//\nJsrsParser.prototype.lookahead = function() {\n  return this.string[this.lookaheadIndex];\n};\n\n// Advance to the next character and return the character\n// that used to be lookahead\n//\nJsrsParser.prototype.advance = function() {\n  var character = this.string[this.lookaheadIndex++];\n  if (this.lookaheadIndex > this.string.length) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return character;\n};\n\n// Step back to the previous character\n//\nJsrsParser.prototype.retreat = function() {\n  this.lookaheadIndex--;\n  if (this.lookaheadIndex < 0) {\n    throw new SyntaxError('Parse error');\n  }\n};\n\n// Advances one character ensuring the equality of the passed\n// one to the given one\n//   token - a character to match\n//\nJsrsParser.prototype.match = function(token) {\n  if (this.advance() !== token) {\n    this.throwExpected(token);\n  }\n};\n\n// Throw a generic parsing error\n//   message - error message\n//\nJsrsParser.prototype.throwError = function(message) {\n  throw new SyntaxError(message + ' at position ' + this.lookaheadIndex);\n};\n\n// Throw a 'smth expected' error\n//   token - what has been expected\n//\nJsrsParser.prototype.throwExpected = function(token) {\n  this.throwError(token + ' expected');\n};\n\n// Throw a 'smth unexpected' error\n//   token - what has been unexpected\n//\nJsrsParser.prototype.throwUnexpected = function(token) {\n  token = token || this.lookahead();\n  if (token === undefined) {\n    token = 'end of data';\n  }\n\n  this.throwError('Unexpected ' + token);\n};\n\n// Check if a given character is a whitespace character\n//   character - a character to check\n//\nJsrsParser.prototype.isWhitespace = function(character) {\n  return ' \\f\\n\\r\\t\\v'.indexOf(character) !== -1;\n};\n\n// Check if a given character is a newline character\n//   character - a character to check\n//\nJsrsParser.prototype.isNewline = function(character) {\n  return character === '\\n' || character === '\\r';\n};\n\n// Check if a given character is a lowercase letter character\n//   character - a character to check\n//\nJsrsParser.prototype.isLetter = function(character) {\n  return character >= 'a' && character <= 'z';\n};\n\n// Check if a given character can be the first character in a number\n//   character - a character to check\n//\nJsrsParser.prototype.isInitialDigit = function(character) {\n  return this.isDecimalDigit(character) ||\n    character === '+' || character === '-' ||\n    character === '.';\n};\n\n// Check if a given character is one of that are allowed in numbers\n//   character - a character to check\n//\nJsrsParser.prototype.isDigit = function(character) {\n  return this.isInitialDigit(character) ||\n    character === 'e' || character === 'E';\n};\n\n// Check if a given character is a binary digit\n//   character - a character to check\n//\nJsrsParser.prototype.isBinaryDigit = function(character) {\n  return character === '0' || character === '1';\n};\n\n// Check if a given character is an octal digit\n//   character - a character to check\n//\nJsrsParser.prototype.isOctalDigit = function(character) {\n  return character >= '0' && character <= '7';\n};\n\n// Check if a given character is a decimal digit\n//   character - a character to check\n//\nJsrsParser.prototype.isDecimalDigit = function(character) {\n  return character >= '0' && character <= '9';\n};\n\n// Check if a given character is a hexadecimal digit\n//   character - a character to check\n//\nJsrsParser.prototype.isHexadecimalDigit = function(character) {\n  return (character >= '0' && character <= '9') ||\n    (character >= 'a' && character <= 'f') ||\n    (character >= 'A' && character <= 'F');\n};\n\n// Check if a given character is a quote character\n//   character - a character to check\n//\nJsrsParser.prototype.isQuoteCharacter = function(character) {\n  return character === '\\'' || character === '\"';\n};\n\n// Check if a given character can be the first character of an identifier\n//   character - a character to check\n//\nJsrsParser.prototype.isInititalIdentifierCharacter = function(character) {\n  return (character >= 'a' && character <= 'z') ||\n    (character >= 'A' && character <= 'Z') ||\n    (character === '_' || character === '$');\n};\n\n// Check if a given character can be a part of an identifier\n//   character - a character to check\n//\nJsrsParser.prototype.isIdentifierCharacter = function(character) {\n  return this.isInititalIdentifierCharacter(character) ||\n    this.isDecimalDigit(character);\n};\n\n// Skip whitespace and comments\n//\nJsrsParser.prototype.skipClutter = function() {\n  this.skipWhitespace();\n  this.skipComments();\n  this.skipWhitespace();\n};\n\n// Skip whitespace\n//\nJsrsParser.prototype.skipWhitespace = function() {\n  while (this.isWhitespace(this.lookahead())) {\n    this.advance();\n  }\n};\n\n// Skip comments\n//\nJsrsParser.prototype.skipComments = function() {\n  if (this.lookahead() !== '/') {\n    return;\n  }\n\n  this.advance();\n\n  if (this.lookahead() === '/') {\n    this.advance();\n    this.skipLineCommentBody();\n  } else if (this.lookahead() === '*') {\n    this.advance();\n    this.skipMultilineCommentBody();\n  } else {\n    this.retreat();\n  }\n};\n\n// Skip the body of a single-line comment (i.e. the part after //)\n//\nJsrsParser.prototype.skipLineCommentBody = function() {\n  while (!this.isNewline(this.lookahead()) &&\n          this.lookahead() !== undefined) {\n    this.advance();\n  }\n};\n\n// Skip the body of a multiline comment (i.e. the part after /*)\n//\nJsrsParser.prototype.skipMultilineCommentBody = function() {\n  var done = false;\n\n  while (!done) {\n    while (this.lookahead() !== '*') {\n      this.advance();\n    }\n    this.advance();\n\n    if (this.lookahead() === '/') {\n      this.advance();\n      done = true;\n    }\n  }\n};\n\n// Parse a JavaScript value\n//\nJsrsParser.prototype.parseValue = function() {\n  this.skipClutter();\n\n  var look = this.lookahead();\n  if (this.isInitialDigit(look)) {\n    return this.parseNumber();\n  } else if (this.isLetter(look)) {\n    return this.parseIdentifier();\n  } else if (this.isQuoteCharacter(look)) {\n    return this.parseString();\n  } else if (look === '[') {\n    return this.parseArray();\n  } else if (look === '{') {\n    return this.parseObject();\n  } else {\n    this.throwUnexpected();\n  }\n};\n\n// Parse a number\n//\nJsrsParser.prototype.parseNumber = function() {\n  this.skipClutter();\n\n  var negateResult = false;\n  var look = this.lookahead();\n\n  if (look === '+' || look === '-') {\n    negateResult = look === '-';\n    this.advance();\n  }\n\n  var base = 10;\n\n  if (this.lookahead() === '0') {\n    this.advance();\n    look = this.lookahead();\n\n    if (this.isDecimalDigit(look)) {\n      this.throwError('Use new octal literals syntax');\n    } else if (look === 'b') {\n      base = 2;\n      this.advance();\n    } else if (look === 'o') {\n      base = 8;\n      this.advance();\n    } else if (look === 'x') {\n      base = 16;\n      this.advance();\n    } else {\n      this.retreat();\n    }\n  }\n\n  var value = base === 10 ?\n    this.parseDecimal() :\n    this.parseMachineInteger(base);\n\n  if (isNaN(value)) {\n    this.throwError('Invalid number format');\n  }\n\n  return negateResult ?\n    -value :\n     value;\n};\n\n// Parse a decimal number, either integer or float.\n// May return NaN when the number is incorrect.\n//\nJsrsParser.prototype.parseDecimal = function() {\n  var number = '';\n\n  var encountered = {  // parseFloat ignores unparsed part of\n    dot: false,        // the string so we must handle it manually\n    sign: false,\n    exponent: false\n  };\n\n  while (this.isDigit(this.lookahead())) {\n    this.checkNumberPartEncountered(encountered, 'dot', '.');\n    this.checkNumberPartEncountered(encountered, 'sign', '+', '-');\n    this.checkNumberPartEncountered(encountered, 'exponent', 'e', 'E');\n\n    number += this.advance();\n  }\n\n  return parseFloat(number);\n};\n\n// Check whether a part of a decimal number that can be used only once\n// has been encountered before and throw SyntaxError if it indeed has.\n//   encounterContext - an object with boolean flags\n//   name - name of the key of the object which value represents the\n//          entitity being checked\n//   character - a character to match against the lookahead character\n//   altCharacter - optional alternative character related to the\n//                  same enitity\n//\nJsrsParser.prototype.checkNumberPartEncountered =\n  function(encounterContext, name, character, altCharacter) {\n    var look = this.lookahead();\n    if (look === character || (altCharacter && look === altCharacter)) {\n      if (encounterContext[name]) {\n        this.throwUnexpected();\n      }\n      encounterContext[name] = true;\n    }\n  };\n\n// Parse an integer number in binary, octal or hexadecimal representation.\n// The prefix is not included and must be parsed before invocation.\n// The function may return NaN when the number is incorrect.\n//   base - 2, 8 or 16\n//\nJsrsParser.prototype.parseMachineInteger = function(base) {\n  var self = this;\n  var checkers = {\n    2:  self.isBinaryDigit,\n    8:  self.isOctalDigit,\n    16: self.isHexadecimalDigit\n  };\n  var checkDigit = checkers[base];\n\n  var number = '';\n  while (checkDigit(this.lookahead())) {\n    number += this.advance();\n  }\n\n  return parseInt(number, base);\n};\n\n// Parse null, undefined, true or false\n//\nJsrsParser.prototype.parseIdentifier = function() {\n  this.skipClutter();\n\n  var identifier = '';\n  while (this.isLetter(this.lookahead())) {\n    identifier += this.advance();\n  }\n\n  var matching = {\n    undefined: undefined,\n    null: null,\n    true: true,\n    false: false\n  };\n\n  if (matching.hasOwnProperty(identifier)) {\n    return matching[identifier];\n  } else {\n    this.throwUnexpected();\n  }\n};\n\n// Parse a single-quoted or double-quoted string\n//\nJsrsParser.prototype.parseString = function() {\n  this.skipClutter();\n\n  var quoteStyle = this.lookahead();\n  if (!this.isQuoteCharacter(quoteStyle)) {\n    this.throwExpected('String');\n  }\n\n  var string = '';\n  var escapeMode = false;\n\n  this.advance();\n\n  while (escapeMode || this.lookahead() !== quoteStyle) {\n    var look = this.advance();\n\n    if (escapeMode) {\n      var controlCharacters = {\n        b: '\\b', f: '\\f', n: '\\n',\n        r: '\\r', t: '\\t', v: '\\v'\n      };\n\n      var controlCharacter = controlCharacters[look];\n\n      if (controlCharacter) {\n        string += controlCharacter;\n      } else if (this.isOctalDigit(look)) {\n        this.retreat();\n        string += this.parseOctalEncodedStringCharacter();\n      } else if (look === 'x') {\n        this.retreat();\n        string += this.parseOneByteHexEncodedCharacter();\n      } else if (look === 'u') {\n        this.retreat();\n        string += this.parseUnicodeCharacter();\n      } else {\n        string += look;\n      }\n\n      escapeMode = false;\n    } else if (look === '\\\\') {\n      escapeMode = true;\n    } else {\n      string += look;\n    }\n  }\n\n  this.match(quoteStyle);\n\n  return string;\n};\n\n// Parse the part of an octal escape sequence after backslash and\n// return the corresponding character\n//\nJsrsParser.prototype.parseOctalEncodedStringCharacter = function() {\n  var digits = '';\n\n  for (var count = 0; count < 3; count++) {\n    var look = this.advance();\n    if (!this.isOctalDigit(look)) {\n      this.retreat();\n      break;\n    }\n\n    digits += look;\n  }\n\n  if (digits.length === 0) {\n    this.throwExpected('Octal number');\n  }\n\n  var code = parseInt(digits, 8);\n  return String.fromCharCode(code);\n};\n\n// Parse the part of a hexadecimal escape sequence after backslash and `x` or\n// `u` character and return the character corresponding to that code\n//   nibblesCount - count of half-bytes in the escape sequence\n//\nJsrsParser.prototype.parseHexEncodedStringCharacter = function(nibblesCount) {\n  var digits = '';\n\n  for (var i = 0; i < nibblesCount; i++) {\n    var look = this.advance();\n    if (!this.isHexadecimalDigit(look)) {\n      this.throwExpected('Hexadecimal digit');\n    }\n\n    digits += look;\n  }\n\n  var code = parseInt(digits, 16);\n  return String.fromCharCode(code);\n};\n\n// Parse the part of a one-byte hexadecimal escape sequence after backslash\n// and return the corresponding character\n//\nJsrsParser.prototype.parseOneByteHexEncodedCharacter = function() {\n  this.match('x');\n  return this.parseHexEncodedStringCharacter(2);\n};\n\n// Parse the part of a two-byte hexadecimal escape sequence after backslash\n// and return the corresponding character\n//\nJsrsParser.prototype.parseTwoByteHexEncodedCharacter = function() {\n  this.match('u');\n  return this.parseHexEncodedStringCharacter(4);\n};\n\n// Parse a Unicode escape sequence after backslash and return the\n// corresponding character\n//\nJsrsParser.prototype.parseUnicodeCharacter = function() {\n  this.match('u');\n\n  if (this.lookahead() === '{') {\n    return this.parseEs6UnicodeLiteral();\n  } else {\n    this.retreat();\n    return this.parseTwoByteHexEncodedCharacter();\n  }\n};\n\n// Parse an ES2015 multibyte Unicode escape sequence after backslash and `u`\n// character\n//\nJsrsParser.prototype.parseEs6UnicodeLiteral = function() {\n  this.match('{');\n\n  var hexDigits = '';\n\n  while (this.lookahead() !== '}') {\n    var digit = this.advance();\n    if (!this.isHexadecimalDigit(digit)) {\n      this.throwExpected('Hexadecimal digit');\n    }\n\n    hexDigits += digit;\n  }\n\n  if (hexDigits.length === 0 || hexDigits.length > 8) {\n    this.throwError('Invalid code point');\n  }\n\n  this.match('}');\n\n  var code = parseInt(hexDigits, 16);\n  return String.fromCodePoint(code);\n};\n\n// Parse an array\n//\nJsrsParser.prototype.parseArray = function() {\n  this.skipClutter();\n  this.match('[');\n\n  var array = [];\n\n  while (this.lookahead() !== ']') {\n    this.skipClutter();\n\n    if (this.lookahead() === ',') {\n      array.push(undefined);\n    } else if (this.lookahead() === ']') {\n      break;\n    } else {\n      var value = this.parseValue();\n      array.push(value);\n    }\n\n    this.skipClutter();\n    if (this.lookahead() !== ']') {\n      this.match(',');\n    }\n  }\n\n  this.match(']');\n\n  return array;\n};\n\n// Parse an object\n//\nJsrsParser.prototype.parseObject = function() {\n  this.skipClutter();\n\n  var object = {};\n\n  this.match('{');\n\n  while (this.lookahead() !== '}') {\n    var key = this.parseObjectKey();\n    this.match(':');\n    var value = this.parseValue();\n\n    if (value !== undefined) {\n      object[key] = value;\n    }\n\n    this.skipClutter();\n    if (this.lookahead() !== '}') {\n      this.match(',');\n      this.skipClutter();\n    }\n  }\n\n  this.skipClutter();\n  this.match('}');\n\n  return object;\n};\n\n// Parse a key of an object\n//\nJsrsParser.prototype.parseObjectKey = function() {\n  this.skipClutter();\n\n  if (this.isQuoteCharacter(this.lookahead())) {\n    return this.parseString();\n  }\n\n  if (!this.isInititalIdentifierCharacter(this.lookahead())) {\n    this.throwExpected('String or identifier');\n  }\n\n  var key = '';\n  while (this.isIdentifierCharacter(this.lookahead())) {\n    key += this.advance();\n  }\n\n  return key;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/record-serialization-nonnative.js\n// module id = 8\n// module chunks = 0","'use strict';\n\nvar events = require('events');\nvar util = require('util');\n\nmodule.exports = RemoteProxy;\n\n// Remote API proxy object class. It wraps remote methods so that they look\n// like regular local methods and acts like a remote event emitter.\n//   connection - JSTP connection to use\n//   interfaceName - name of an interface that is proxied\n//   methods - array of method names (optional)\n//\nfunction RemoteProxy(connection, interfaceName, methods) {\n  events.EventEmitter.call(this);\n\n  this._connection = connection;\n  this._interfaceName = interfaceName;\n\n  if (methods) {\n    for (var i = 0; i < methods.length; i++) {\n      RemoteProxy.wrapRemoteMethod(this, methods[i]);\n    }\n  }\n}\n\nutil.inherits(RemoteProxy, events.EventEmitter);\n\n// Emit an event. By default, when the dontRetranslate parameter is false or\n// undefined, the event is also emmited on the other part of the JSTP\n// connection so all the 'on' handlers will work on both sides regardless of\n// where event has been emitted. However, you can turn it off by setting\n// dontRetranslate to true.\n//   eventName - name of an event\n//   eventArgs - object of event arguments\n//   dontRetranslate - turn off sending the corresponding event packet over the\n//                     JSTP connection\n//\nRemoteProxy.prototype.emit = function(eventName, eventArgs, dontRetranslate) {\n  if (!dontRetranslate) {\n    this._connection.emitRemoteEvent(this._interfaceName, eventName, eventArgs);\n  }\n\n  events.EventEmitter.prototype.emit.call(this, eventName, eventArgs);\n};\n\n// Create a method in a remote proxy that will call the corresponding remote\n// method. This is implemented as a static method rather than an instance\n// method so that it will not be rewritten by a remote API method with the same\n// name.\n//   instance - remote proxy object\n//   method - name of a method\n//\nRemoteProxy.wrapRemoteMethod = function(instance, methodName) {\n  instance[methodName] = remoteMethodWrapper.bind(instance, methodName);\n};\n\n// Remote method wrapper\n//   this - remote proxy instance\n//   methodName - name of a remote method\n//\nfunction remoteMethodWrapper(methodName) {\n  var callback = arguments[arguments.length - 1];\n  var args = Array.prototype.slice.call(arguments, 1, -1);\n\n  if (typeof(callback) !== 'function') {\n    args.push(callback);\n    callback = null;\n  }\n\n  this._connection.callMethod(this._interfaceName, methodName, args, callback);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/remote-proxy.js\n// module id = 9\n// module chunks = 0","'use strict';\n\nvar common = require('./common');\n\nvar factory = {};\nmodule.exports = factory;\n\n// Create a serializer function that takes a JavaScript object and returns its\n// string representation. By default the behaviour of this function will be\n// compliant with the JSTP Record Serialization format but you can override it\n// or supply additional types support using the optional argument of this\n// factory function.\n//   additionalTypes - an object with keys which names specify data types and\n//                     values that are functions that serialize values of\n//                     the corresponding types\n//\nfactory.createSerializer = function(additionalTypes) {\n  function serialize(object) {\n    var type;\n    if (Array.isArray(object)) {\n      type = 'array';\n    } else if (object instanceof Date) {\n      type = 'date';\n    } else if (object === null) {\n      type = 'null';\n    } else {\n      type = typeof(object);\n    }\n\n    var serializer = serialize.types[type];\n    if (serializer) {\n      return serializer(object);\n    }\n\n    return '';\n  }\n\n  serialize.types = {\n    number: function(number) {\n      return number + '';\n    },\n\n    boolean: function(bool) {\n      return bool ? 'true' : 'false';\n    },\n\n    undefined: function() {\n      return 'undefined';\n    },\n\n    null: function() {\n      return 'null';\n    },\n\n    string: function(string) {\n      var content = JSON.stringify(string).slice(1, -1);\n      return '\\'' + content.replace(/'/g, '\\\\\\'') + '\\'';\n    },\n\n    date: function(date) {\n      return '\\'' + date.toISOString() + '\\'';\n    },\n\n    array: function(array) {\n      var result = '[';\n\n      for (var index = 0; index < array.length; index++) {\n        var value = array[index];\n        if (value !== undefined) {\n          result += serialize(value);\n        }\n\n        if (index !== array.length - 1) {\n          result += ',';\n        }\n      }\n\n      return result + ']';\n    },\n\n    object: function(object) {\n      var result = '{';\n      var firstKey = true;\n\n      var objectKeys = Object.keys(object);\n      var objectKeysCount = objectKeys.length;\n\n      for (var i = 0; i < objectKeysCount; i++) {\n        var key = objectKeys[i];\n        var value = serialize(object[key]);\n\n        if (value === '' || value === 'undefined') {\n          continue;\n        }\n\n        if (!/^[a-zA-Z_]\\w*$/.test(key)) {\n          key = serialize.types.string(key);\n        }\n\n        if (firstKey) {\n          firstKey = false;\n        } else {\n          result += ',';\n        }\n\n        result += key + ':' + value;\n      }\n\n      return result + '}';\n    }\n  };\n\n  common.extend(serialize.types, additionalTypes);\n  return serialize;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/serializer-factory.js\n// module id = 10\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 11\n// module chunks = 0","'use strict';\n\nvar errors = require('./errors');\n\nvar apps = {};\nmodule.exports = apps;\n\n// Generic application class. You are free to substitute it with whatever suits\n// your needs.\n//   name - application name\n//   api - application API\n//\nfunction Application(name, api) {\n  this.name = name;\n  this.api = api;\n}\n\napps.Application = Application;\n\n// Call application method\n//   connection - JSTP connection\n//   interfaceName - name of the interface\n//   methodName - name of the method\n//   args - method arguments (including callback)\n//\nApplication.prototype.callMethod =\n  function(connection, interfaceName, methodName, args) {\n    var appInterface = this.api[interfaceName];\n    if (!appInterface) {\n      throw new errors.RemoteError(errors.ERR_INTERFACE_NOT_FOUND);\n    }\n\n    var method = appInterface[methodName];\n    if (!method) {\n      throw new errors.RemoteError(errors.ERR_METHOD_NOT_FOUND);\n    }\n\n    var context = { connection: connection };\n    method.apply(context, args);\n  };\n\n// Get an array of methods of an interface\n//   interfaceName - name of the interface to inspect\n//\nApplication.prototype.getMethods = function(interfaceName) {\n  var appInterface = this.api[interfaceName];\n\n  if (appInterface) {\n    return Object.keys(appInterface);\n  } else {\n    return null;\n  }\n};\n\n// Generic server applications provider class. Your are free to substitute it\n// with whatever suits your needs.\n//\nfunction ServerApplicationsProvider() {\n  this._applications = {};\n}\n\napps.ServerApplicationsProvider = ServerApplicationsProvider;\n\n// Get an application\n//   applicationName - name of the application to get\n//\nServerApplicationsProvider.prototype.getApplication =\n  function(applicationName) {\n    return this._applications[applicationName];\n  };\n\n// Register a new application\n//   application - application instance or application name\n//   api - second argument for the Application constructor (only needed if you\n//     have passed a string as the first argument)\n//\nServerApplicationsProvider.prototype.registerApplication =\n  function(application, api) {\n    if (typeof(application) === 'string') {\n      application = new Application(application, api);\n    }\n\n    this._applications[application.name] = application;\n  };\n\n// Generic client application provider class. Your are free to substitute it\n// with whatever suits your needs.\n//   application - application instance or application name\n//   api - second argument for the Application constructor (only needed if you\n//     have passed a string as the first argument)\n//\nfunction ClientApplicationProvider(application, api) {\n  if (application instanceof Application) {\n    this._application = application;\n  } else {\n    this._application = new Application(application, api);\n  }\n}\n\napps.ClientApplicationProvider = ClientApplicationProvider;\n\n// Get the application\n//\nClientApplicationProvider.prototype.getApplication = function() {\n  return this._application;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/apps-provider.js\n// module id = 12\n// module chunks = 0","'use strict';\n\nvar events = require('events');\nvar util = require('util');\n\nvar metasync = require('metasync');\n\nvar common = require('./common');\nvar Connection = require('./connection');\n\nmodule.exports = Client;\n\n// JSTP client\n//   rawClient - underlying network client\n//   applicationProvider - application provider\n//\nfunction Client(rawClient, applicationProvider) {\n  events.EventEmitter.call(this);\n\n  this.rawClient = rawClient;\n  this.applicationProvider = applicationProvider;\n\n  common.forwardMultipleEvents(rawClient, this, [\n    'connect',\n    'error',\n    'close'\n  ]);\n}\n\nutil.inherits(Client, events.EventEmitter);\n\n// Connect to a server\n//   callback - callback function\n//\nClient.prototype.connect = function(callback) {\n  this.rawClient.connect(function(error) {\n    if (error) {\n      return callback(error);\n    }\n\n    var transport = this.rawClient.createTransport();\n    var connection = new Connection(transport, null, this);\n\n    callback(null, connection);\n  }.bind(this));\n};\n\n// Connect from the server\n//   callback - callback function\n//\nClient.prototype.disconnect = function(callback) {\n  this.rawClient.disconnect(callback);\n};\n\n// Get the application\n//\nClient.prototype.getApplication = function() {\n  return this.applicationProvider.getApplication();\n};\n\n// Helper methods that calls 'connect' and then performs handshake\n//   appName - name of the application to connect to\n//     (see Connection#handshake(appName, username, password, callback))\n//   username - user login (or null for anonymous session)\n//   password - user password (or null for anonymous session)\n//   callback - callback function with signature (error, connection, sessionId)\n//\nClient.prototype.connectAndHandshake =\n  function(appName, username, password, callback) {\n    this.connect(function(error, connection) {\n      if (error) {\n        return callback(error);\n      }\n\n      connection.handshake(appName, username, password, function(error, sid) {\n        if (error) {\n          return callback(error);\n        }\n\n        callback(null, connection, sid);\n      });\n    });\n  };\n\n// Helper methods that calls 'connect', performs handshake and loads\n// introspection of specified interfaces\n//   appName - name of the application to connect to\n//     (see Connection#handshake(appName, username, password, callback))\n//   username - user login (or null for anonymous session)\n//   password - user password (or null for anonymous session)\n//   interfaces - array of names of interfaces to inspect\n//   callback - callback function with signature\n//     (error, connection, sessionId, api)\n//\nClient.prototype.connectAndInspect =\n  function(appName, username, password, interfaces, callback) {\n    this.connectAndHandshake(appName, username, password,\n      handshakeCallback.bind(this, interfaces, callback));\n  };\n\n// Internal function, part of Client#connectAndInspect method\n//\nfunction handshakeCallback(interfaces, callback, error, connection, sid) {\n  if (error) {\n    return callback(error);\n  }\n\n  var errors = {};\n  var hasErrors = false;\n\n  var collector = new metasync.DataCollector(interfaces.length, function(api) {\n    if (hasErrors) {\n      api._errors = errors;\n    }\n\n    callback(null, connection, sid, api);\n  });\n\n  interfaces.forEach(function(interfaceName) {\n    connection.inspectInterface(interfaceName, function(error, appInterface) {\n      if (error) {\n        appInterface = null;\n        errors[interfaceName] = error;\n        hasErrors = true;\n      }\n\n      collector.collect(interfaceName, appInterface);\n    });\n  });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/client.js\n// module id = 13\n// module chunks = 0","'use strict';\n\nvar constants = {};\nmodule.exports = constants;\n\nconstants.WEBSOCKET_PROTOCOL_NAME = 'metarhia-jstp';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/internal-constants.js\n// module id = 14\n// module chunks = 0","'use strict';\n\nvar vm = require('vm');\nvar serializerFactory = require('./serializer-factory');\n\nvar PARSE_TIMEOUT = 30;\n\nvar serializer = {};\nmodule.exports = serializer;\n\n// Parse a string representing an object in JSTP Object Serialization format\n//   string - a string to parse\n//\nserializer.interprete = function interprete(string) {\n  var sandbox = vm.createContext({});\n  var script = vm.createScript('\"use strict\";(' + string + ')');\n  var exported = script.runInNewContext(sandbox, {\n    timeout: PARSE_TIMEOUT\n  });\n\n  if (typeof(exported) === 'object' && !Array.isArray(exported)) {\n    for (var key in exported) {\n      if (exported.hasOwnProperty(key)) {\n        sandbox[key] = exported[key];\n      }\n    }\n  }\n\n  return exported;\n};\n\n// Serialize a JavaScript object into a string in JSTP Object Serialization\n// format\n//\nserializer.dump = serializerFactory.createSerializer({\n  date: function(date) {\n    var string = date.toISOString();\n    return 'new Date(\\'' + string + '\\')';\n  },\n\n  function: function(fn) {\n    return fn.toString();\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/object-serialization.js\n// module id = 15\n// module chunks = 0","/* eslint-env browser, commonjs */\n'use strict';\n\nvar events = require('events');\nvar util = require('util');\n\nvar Client = require('./client');\nvar common = require('./common');\nvar constants = require('./internal-constants');\n\nvar ws = {};\nmodule.exports = ws;\n\n// Create a JSTP client that will transfer data over a WebSocket connection\n//   url - WebSocket endpoint URL\n//   appProvider - client application provider\n//\nws.createClient = function(url, appProvider) {\n  var wsClient = new W3CWebSocketClient(url);\n  var jstpClient = new Client(wsClient, appProvider);\n\n  return jstpClient;\n};\n\n// Client WebSocket connection for JSTP\n//   url - WebSocket endpoint URL\n//\nfunction W3CWebSocketClient(url) {\n  events.EventEmitter.call(this);\n\n  this.url = url;\n  this.socket = null;\n  this.socketEventEmitter = null;\n  this.socketDidOpen = false;\n}\n\nutil.inherits(W3CWebSocketClient, events.EventEmitter);\nws.W3CWebSocketClient = W3CWebSocketClient;\n\n// Connect to the server\n//  callback - callback function\n//\nW3CWebSocketClient.prototype.connect = function(callback) {\n  if (this.socketDidOpen) {\n    if (callback) {\n      callback(new Error('Already connected'));\n    }\n    return;\n  }\n\n  try {\n    this.socket = new WebSocket(this.url, constants.WEBSOCKET_PROTOCOL_NAME);\n  } catch (error) {\n    if (callback) {\n      callback(error);\n    }\n    return;\n  }\n\n  this.socketEventEmitter = new events.EventEmitter();\n\n  this.socket.onopen = this._onOpen.bind(this);\n  this.socket.onclose = this._onClose.bind(this);\n  this.socket.onerror = this._onError.bind(this);\n  this.socket.onmessage = this._onMessage.bind(this);\n\n  this.socketEventEmitter.once('connectFailed', function(error) {\n    if (callback) {\n      callback(error);\n    }\n  });\n\n  this.socketEventEmitter.once('open', function() {\n    if (callback) {\n      callback();\n    }\n  });\n};\n\n// Disconnect from the server\n//\nW3CWebSocketClient.prototype.disconnect = function(callback) {\n  this._ensureConnected();\n\n  if (callback) {\n    this.connection.once('close', callback);\n  }\n\n  this.socket.close();\n};\n\n// Create a JSTP transport from the underlying WebSocket connection\n//\nW3CWebSocketClient.prototype.createTransport = function() {\n  this._ensureConnected();\n  return new W3CWebSocketTransport(this.socket, this.socketEventEmitter);\n};\n\n// Check if the client is in the connected state and throw an error otherwise\n//\nW3CWebSocketClient.prototype._ensureConnected = function() {\n  if (!this.socketDidOpen) {\n    throw new Error('Not connected yet');\n  }\n};\n\n// W3C WebSocket open event handler\n//\nW3CWebSocketClient.prototype._onOpen = function() {\n  this.socketDidOpen = true;\n  this.socketEventEmitter.emit('open');\n};\n\n// W3C WebSocket close event handler\n//\nW3CWebSocketClient.prototype._onClose = function() {\n  this.socketDidOpen = false;\n  this.socketEventEmitter.emit('close');\n};\n\n// W3C WebSocket error event handler\n//\nW3CWebSocketClient.prototype._onError = function(error) {\n  if (this.socketDidOpen) {\n    this.socketEventEmitter.emit('error', error);\n  } else {\n    this.socketEventEmitter.emit('connectFailed', error);\n  }\n};\n\n// W3C WebSocket error event handler\n//\nW3CWebSocketClient.prototype._onMessage = function(message) {\n  this.socketEventEmitter.emit('message', message);\n};\n\n// W3C WebSocket transport for JSTP\n//   socket - WebSocket instance\n//   socketEventEmitter - an EventEmitter that proxies socket events\n//\nfunction W3CWebSocketTransport(socket, socketEventEmitter) {\n  events.EventEmitter.call(this);\n\n  this.socket = socket;\n  this.socketEventEmitter = socketEventEmitter;\n\n  common.forwardMultipleEvents(socketEventEmitter, this, [\n    'close',\n    'error'\n  ]);\n\n  this.socketEventEmitter.on('message', this._onMessage.bind(this));\n}\n\nutil.inherits(W3CWebSocketTransport, events.EventEmitter);\nws.W3CWebSocketTransport = W3CWebSocketTransport;\n\n// Get the address of a remote host\n//\nW3CWebSocketTransport.prototype.getRemoteAddress = function() {\n  return this.socket.url;\n};\n\n// Send data over the connection\n//   data - Buffer or string\n//\nW3CWebSocketTransport.prototype.send = function(data) {\n  if (Buffer.isBuffer(data)) {\n    data = data.toString();\n  }\n\n  this.socket.send(data);\n};\n\n// End the connection optionally sending the last chunk of data\n//   data - Buffer or string (optional)\n//\nW3CWebSocketTransport.prototype.end = function(data) {\n  if (data) {\n    this.send(data);\n  }\n\n  this.socket.close();\n};\n\n// WebSocket message handler\n//   message - WebSocket message\n//\nW3CWebSocketTransport.prototype._onMessage = function(message) {\n  var data = typeof(message.data) === 'string' ?\n    message.data :\n    new Buffer(message.data).toString();\n\n  this.emit('data', '[' + data + ']');\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/transport.ws.browser.js\n// module id = 16\n// module chunks = 0","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 17\n// module chunks = 0","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ieee754/index.js\n// module id = 18\n// module chunks = 0","\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/indexof/index.js\n// module id = 19\n// module chunks = 0","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isarray/index.js\n// module id = 20\n// module chunks = 0","'use strict';\n\nvar metasync = {};\nmodule.exports = metasync;\n\n// Functional Asyncronous Composition\n//   fns - array of function([data,] callback)\n//     data - incoming data\n//     callback - function(data)\n//       data - outgoing data\n//   done - on `done` callback(data)\n//     data - hash with of functions results\n//   data - incoming data\n//\nmetasync.composition = function(fns, done, data) {\n  if (fns.length === 1) {\n    metasync.parallel(fns[0], done, data);\n  } else {\n    metasync.sequential(fns, done, data);\n  }\n};\n\n// Parallel execution\n//   fns - array of function([data,] callback)\n//     data - incoming data\n//     callback - function(data)\n//       data - outgoing data\n//   done - on `done` callback(data)\n//     data - hash with of functions results\n//   data - incoming data\n//\nmetasync.parallel = function(fns, done, data) {\n  var counter = 0,\n      len = fns.length,\n      finished = false;\n  data = data || {};\n\n  if (len < 1) {\n    if (done) done(data);\n  } else {\n    fns.forEach(function(fn) {\n      var finish = function(result) {\n        if (fn.name && result) data[fn.name] = result;\n        if (result instanceof Error) {\n          if (!finished) {\n            if (done) done(result);\n          }\n          finished = true;\n        } else {\n          if (++counter >= len) {\n            if (done) done(data);\n          }\n        }\n      };\n      if (Array.isArray(fn)) metasync.composition(fn, finish, data);\n      else {\n        if (fn.length === 2) fn(data, finish);\n        else fn(finish);\n      }\n    });\n  }\n};\n\n// Sequential execution\n//   fns - array of function([data,] callback)\n//     data - incoming data\n//     callback - function(data)\n//       data - outgoing data\n//   done - on `done` callback(data)\n//     data - hash with of functions results\n//   data - incoming data\n//\nmetasync.sequential = function(fns, done, data) {\n  var i = -1,\n      len = fns.length;\n  data = data || {};\n\n  function next() {\n    var fn;\n    var finish = function finish(result) {\n      if (fn.name && result) data[fn.name] = result;\n      if (result instanceof Error) {\n        if (done) done(result);\n      } else next();\n    };\n    if (++i >= len) {\n      if (done) done(data);\n    } else {\n      fn = fns[i];\n      if (Array.isArray(fn)) metasync.composition(fn, finish, data);\n      else {\n        if (fn.length === 2) fn(data, finish);\n        else fn(finish);\n      }\n    }\n  }\n\n  if (len > 0) next();\n  else if (done) done(data);\n};\n\n// Data Collector\n//   expected - number of `collect()` calls expected\n//   done - on `done` callback(data)\n//\nmetasync.DataCollector = function(expected, done) {\n  this.expected = expected;\n  this.data = {};\n  this.count = 0;\n  this.done = done;\n};\n\n// Push data to collector\n//   key - key in result data\n//   data - value in result data\n//\nmetasync.DataCollector.prototype.collect = function(key, data) {\n  this.count++;\n  this.data[key] = data;\n  if (this.expected === this.count) this.done(this.data);\n};\n\n// Asynchrous filter\n// filter :: [a] -> (a -> (Boolean -> Void) -> Void) -> ([a] -> Void)\n//\n// Arguments:\n//   items - incoming array\n//   fn - function(value, callback)\n//     value - item from items array\n//     callback - callback function(accepted)\n//       accepted - true/false returned from fn\n//   done - on `done` function(result)\n//     result - filtered array\n//\nmetasync.filter = function(items, fn, done) {\n  var result = [],\n      counter = 0;\n\n  function finish() {\n    // Callbacks might be called in any possible order,\n    // hence sort the filtered array\n    // by element's index in the original itemsection\n    result.sort(function(x, y) { return x.index - y.index; });\n\n    // Only value is needed in resulting array\n    result = result.map(function(x) { return x.value; });\n\n    // Return a result using callback;\n    if (done) done(result);\n  }\n\n  items.forEach(function(value, index) {\n    fn(value, function(accepted) {\n      if (accepted) result.push({ index: index, value: value });\n      if (++counter === items.length) finish();\n    });\n  });\n};\n\n// Asynchronous find\n// find :: [a] -> (a -> (Boolean -> Void) -> Void) -> (a -> Void)\n//\n// Arguments:\n//   items - incoming array\n//   fn - function(value, callback)\n//     value - item from items array\n//     callback - callback function(accepted)\n//       accepted - true/false returned from fn\n//   done - on `done` function(result)\n//     result - filtered array\n//\nmetasync.find = function(items, fn, done) {\n  var i = 0,\n      len = items.length;\n\n  function next() {\n    if (i === len) {\n      if (done) done();\n    } else {\n      fn(items[i], function(accepted) {\n        if (accepted) {\n          if (done) done(items[i]);\n        } else {\n          i++;\n          next();\n        }\n      });\n    }\n  }\n\n  if (len > 0) next();\n  else if (done) done();\n};\n\n// Asynchronous series\n//   items - incoming array\n//   fn - function(value, callback)\n//     value - item from items array\n//     callback - callback function(accepted)\n//       accepted - true/false returned from fn\n//   done - on `done` function(result)\n//     result - filtered array\n//\nmetasync.series = function(items, fn, done) {\n  var i = -1,\n      len = items.length;\n\n  function next() {\n    i++;\n    if (i >= len) {\n      if (done) done();\n    } else fn(items[i], function(result) {\n      if (result instanceof Error) {\n        if (done) done(result);\n      } else next();\n    });\n  }\n\n  next();\n};\n\n// Asynchronous each\n//   items - incoming array\n//   fn - function(value, callback)\n//     value - item from items array\n//     callback - callback function(accepted)\n//       accepted - true/false returned from fn\n//   done - on `done` function(result)\n//     result - filtered array\n//\nmetasync.each = function(items, fn, done) {\n  var counter = 0,\n      len = items.length,\n      finished = false;\n\n  if (len < 1) {\n    if (done) done();\n  } else {\n    items.forEach(function(item) {\n      fn(item, function(result) {\n        if (result instanceof Error) {\n          if (!finished) {\n            if (done) done(result);\n          }\n          finished = true;\n        } else {\n          counter++;\n          if (counter >= len) {\n            if (done) done();\n          }\n        }\n      });\n    });\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/metasync/metasync.js\n// module id = 21\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/util/~/inherits/inherits_browser.js\n// module id = 22\n// module chunks = 0","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/util/support/isBufferBrowser.js\n// module id = 23\n// module chunks = 0","var indexOf = require('indexof');\n\nvar Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar defineProp = (function() {\n    try {\n        Object.defineProperty({}, '_', {});\n        return function(obj, name, value) {\n            Object.defineProperty(obj, name, {\n                writable: true,\n                enumerable: false,\n                configurable: true,\n                value: value\n            })\n        };\n    } catch(e) {\n        return function(obj, name, value) {\n            obj[name] = value;\n        };\n    }\n}());\n\nvar globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',\n'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',\n'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',\n'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',\n'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];\n\nfunction Context() {}\nContext.prototype = {};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInContext = function (context) {\n    if (!(context instanceof Context)) {\n        throw new TypeError(\"needs a 'context' argument.\");\n    }\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    var wEval = win.eval, wExecScript = win.execScript;\n\n    if (!wEval && wExecScript) {\n        // win.eval() magically appears when this is called in IE:\n        wExecScript.call(win, 'null');\n        wEval = win.eval;\n    }\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n    forEach(globals, function (key) {\n        if (context[key]) {\n            win[key] = context[key];\n        }\n    });\n    \n    var winKeys = Object_keys(win);\n\n    var res = wEval.call(win, this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        // Avoid copying circular objects like `top` and `window` by only\n        // updating existing context properties or new properties in the `win`\n        // that was only introduced after the eval.\n        if (key in context || indexOf(winKeys, key) === -1) {\n            context[key] = win[key];\n        }\n    });\n\n    forEach(globals, function (key) {\n        if (!(key in context)) {\n            defineProp(context, key, win[key]);\n        }\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInNewContext = function (context) {\n    var ctx = Script.createContext(context);\n    var res = this.runInContext(ctx);\n\n    forEach(Object_keys(ctx), function (key) {\n        context[key] = ctx[key];\n    });\n\n    return res;\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    var copy = new Context();\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vm-browserify/index.js\n// module id = 24\n// module chunks = 0"],"sourceRoot":""}